<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WFRP Character Sheet</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: #d4c5a0;
            min-height: 100vh;
            padding: 20px;
        }

        .character-sheet {
            max-width: 1200px;
            margin: 0 auto;
            background: #faf8f3;
            border: 3px solid #3e2f1f;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        /* Header */
        .sheet-header {
            background: #3e2f1f;
            color: #faf8f3;
            padding: 15px 20px;
            border-bottom: 2px solid #2a1f14;
        }

        .header-grid {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            align-items: end;
        }

        .header-field {
            display: flex;
            flex-direction: column;
        }

        .header-field label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            color: #c4b5a0;
        }

        .header-field input {
            background: rgba(250, 248, 243, 0.9);
            border: 1px solid #2a1f14;
            color: #2a1f14;
            padding: 6px 8px;
            font-family: 'Georgia', serif;
            font-size: 14px;
        }

        .character-name input {
            font-size: 18px;
            font-weight: bold;
        }

        /* Main Content */
        .sheet-content {
            padding: 0;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            background: #3e2f1f;
            border-bottom: 3px solid #2a1f14;
            margin: 0;
            padding: 0;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: #3e2f1f;
            color: #c4b5a0;
            border: none;
            font-family: 'Georgia', serif;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-right: 1px solid #2a1f14;
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button:hover {
            background: #4a3828;
            color: #faf8f3;
        }

        .tab-button.active {
            background: #faf8f3;
            color: #3e2f1f;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Characteristics Table */
        .characteristics-section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: #3e2f1f;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid #3e2f1f;
            padding-bottom: 5px;
        }

        .characteristics-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border: 2px solid #3e2f1f;
        }

        .characteristics-table th {
            background: #3e2f1f;
            color: #faf8f3;
            padding: 8px 6px;
            text-align: center;
            font-size: 11px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid #2a1f14;
        }

        .characteristics-table td {
            border: 1px solid #8b7355;
            padding: 4px;
            text-align: center;
            position: relative;
        }

        .characteristics-table tr:nth-child(even) {
            background: #f5f0e8;
        }

        .char-name-cell {
            font-weight: bold;
            text-align: left !important;
            padding-left: 10px !important;
            font-size: 12px;
            color: #3e2f1f;
            background: #e8dfd0;
        }

        .characteristics-table input {
            width: 100%;
            border: none;
            text-align: center;
            padding: 6px 2px;
            font-size: 14px;
            font-weight: bold;
            background: transparent;
        }

        .characteristics-table input:focus {
            outline: 2px solid #8b7355;
            background: #fffef5;
        }

        .current-cell {
            background: #e8dfd0;
            font-weight: bold;
        }

        .current-cell input {
            font-size: 16px;
            color: #3e2f1f;
        }

        /* Skills Section */
        .skills-section {
            margin-bottom: 25px;
        }

        .skills-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .skills-filter {
            padding: 5px 10px;
            border: 1px solid #8b7355;
            font-family: 'Georgia', serif;
            background: white;
        }

        .skills-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border: 2px solid #3e2f1f;
            font-size: 12px;
        }

        .skills-table th {
            background: #3e2f1f;
            color: #faf8f3;
            padding: 6px 4px;
            text-align: center;
            font-size: 10px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid #2a1f14;
        }

        .skills-table td {
            border: 1px solid #8b7355;
            padding: 3px;
            text-align: center;
        }

        .skills-table tr:nth-child(even) {
            background: #f5f0e8;
        }

        .skill-name-cell {
            text-align: left !important;
            padding-left: 8px !important;
            font-weight: bold;
            color: #3e2f1f;
        }

        .skills-table input[type="number"] {
            width: 40px;
            border: none;
            text-align: center;
            padding: 2px;
            font-size: 12px;
            background: transparent;
        }

        .skills-table input[type="checkbox"] {
            transform: scale(1.2);
        }

        .advance-btn {
            width: 20px;
            height: 20px;
            border: 1px solid #8b7355;
            background: #f5f0e8;
            cursor: pointer;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .advance-btn:hover {
            background: #e8dfd0;
        }

        .skill-total {
            font-weight: bold;
            color: #3e2f1f;
            background: #e8dfd0 !important;
        }

        /* Secondary Characteristics Table */
        .secondary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .secondary-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border: 2px solid #3e2f1f;
        }

        .secondary-table th {
            background: #3e2f1f;
            color: #faf8f3;
            padding: 6px;
            text-align: left;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid #2a1f14;
        }

        .secondary-table td {
            border: 1px solid #8b7355;
            padding: 6px;
        }

        .secondary-table input {
            width: 100%;
            border: none;
            padding: 4px;
            font-size: 14px;
            background: transparent;
            text-align: center;
        }

        .secondary-table input:focus {
            outline: 2px solid #8b7355;
            background: #fffef5;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            padding: 12px 24px;
            background: #3e2f1f;
            color: #faf8f3;
            border: 2px solid #2a1f14;
            font-family: 'Georgia', serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .control-btn:hover {
            background: #2a1f14;
            transform: translateY(-2px);
        }

        /* Google Drive Integration Styles */
        .google-drive-section {
            background: #f9f7f1;
            border: 2px solid #e8dfd0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 20px;
        }

        .google-drive-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #3e2f1f;
        }

        .google-drive-status .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
        }

        .google-drive-status.connected .status-indicator {
            background: #28a745;
        }

        .google-drive-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .google-drive-btn {
            padding: 8px 16px;
            background: #4285f4;
            color: white;
            border: 1px solid #3367d6;
            border-radius: 4px;
            font-family: 'Georgia', serif;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .google-drive-btn:hover {
            background: #3367d6;
        }

        .google-drive-btn:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
            border-color: #999;
        }

        .google-drive-btn.disconnect {
            background: #dc3545;
            border-color: #c82333;
        }

        .google-drive-btn.disconnect:hover {
            background: #c82333;
        }

        .google-drive-btn.backup {
            background: #28a745;
            border-color: #1e7e34;
        }

        .google-drive-btn.backup:hover {
            background: #1e7e34;
        }

        .google-drive-btn.restore {
            background: #ffc107;
            border-color: #e0a800;
            color: #212529;
        }

        .google-drive-btn.restore:hover {
            background: #e0a800;
        }

        .google-drive-btn.export {
            background: #6f42c1;
            border-color: #6f42c1;
        }

        .google-drive-btn.export:hover {
            background: #5a32a3;
        }

        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Backup modal styles */
        .backup-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .backup-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #faf8f3;
            border: 3px solid #3e2f1f;
            padding: 20px;
            min-width: 500px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .backup-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e8dfd0;
            border-radius: 5px;
            margin: 10px 0;
        }

        .backup-item {
            padding: 10px;
            border-bottom: 1px solid #e8dfd0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .backup-item:hover {
            background: #f9f7f1;
        }

        .backup-item.selected {
            background: #e8f5e8;
            border-color: #28a745;
        }

        .backup-item-name {
            font-weight: bold;
            color: #3e2f1f;
            margin-bottom: 2px;
        }

        .backup-item-details {
            font-size: 11px;
            color: #666;
        }

        /* Mobile responsiveness for Google Drive UI */
        @media (max-width: 768px) {
            .google-drive-section {
                margin: 10px;
                padding: 10px;
            }

            .google-drive-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .google-drive-btn {
                justify-content: center;
                padding: 10px;
            }

            .backup-modal-content {
                min-width: 300px;
                max-width: 95%;
                margin: 10px;
            }
        }

        /* Auto-Save Status Indicator Styles */
        .save-status-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(250, 248, 243, 0.9);
            border: 1px solid rgba(232, 223, 208, 0.6);
            border-radius: 4px;
            padding: 4px 8px;
            font-family: 'Georgia', serif;
            font-size: 10px;
            color: rgba(62, 47, 31, 0.7);
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            opacity: 1;
        }
        
        .save-status-container.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .save-status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        .save-status-container.saved-local {
            border-color: rgba(40, 167, 69, 0.4);
        }

        .save-status-container.saved-local .save-status-indicator {
            background: #28a745;
        }

        .save-status-container.saved-cloud {
            border-color: rgba(0, 123, 255, 0.4);
        }

        .save-status-container.saved-cloud .save-status-indicator {
            background: #007bff;
        }

        .save-status-container.syncing {
            border-color: rgba(255, 193, 7, 0.6);
        }

        .save-status-container.syncing .save-status-indicator {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }

        .save-status-container.error {
            border-color: rgba(220, 53, 69, 0.6);
        }

        .save-status-container.error .save-status-indicator {
            background: #dc3545;
        }

        .save-status-container.offline {
            border-color: rgba(108, 117, 125, 0.4);
        }

        .save-status-container.offline .save-status-indicator {
            background: #6c757d;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .save-status-text {
            font-weight: bold;
            white-space: nowrap;
        }

        /* Auto-restore notification styles */
        .auto-restore-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #faf8f3;
            border: 3px solid #3e2f1f;
            border-radius: 10px;
            padding: 20px;
            max-width: 500px;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: 'Georgia', serif;
        }

        .auto-restore-notification h3 {
            color: #3e2f1f;
            margin-bottom: 15px;
            text-align: center;
        }

        .auto-restore-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .auto-restore-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-family: 'Georgia', serif;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .auto-restore-btn.primary {
            background: #3e2f1f;
            color: #faf8f3;
        }

        .auto-restore-btn.primary:hover {
            background: #2a1f14;
        }

        .auto-restore-btn.secondary {
            background: #8b7355;
            color: #faf8f3;
        }

        .auto-restore-btn.secondary:hover {
            background: #6d5a43;
        }

        /* Mobile responsiveness for auto-save UI */
        @media (max-width: 768px) {
            .save-status-container {
                bottom: 10px;
                right: 10px;
                padding: 3px 6px;
                font-size: 9px;
            }

            .save-status-indicator {
                width: 6px;
                height: 6px;
            }

            .auto-restore-notification {
                max-width: 90%;
                margin: 10px;
            }
        }

        /* Career System Styles */
        .career-section {
            background: #faf8f3;
            border: 1px solid #e8dfd0;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .career-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .career-title {
            color: #3e2f1f;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .career-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 100px;
            gap: 15px;
            margin-bottom: 15px;
            align-items: end;
        }

        .career-field {
            display: flex;
            flex-direction: column;
        }

        .career-field label {
            color: #3e2f1f;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .career-field select {
            padding: 8px;
            font-family: Georgia, serif;
            border: 1px solid #8b7355;
            border-radius: 4px;
            background: white;
            font-size: 13px;
        }

        .career-field select:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .tier-info {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 5px;
            padding: 12px;
            margin-top: 15px;
        }

        .tier-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .tier-name {
            font-weight: bold;
            color: #2d4a2d;
            font-size: 14px;
        }

        .tier-status {
            background: #2d4a2d;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-details {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .tier-category {
            background: white;
            border-radius: 4px;
            padding: 10px;
        }

        .tier-category-title {
            font-weight: bold;
            color: #3e2f1f;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-list {
            font-size: 11px;
            line-height: 1.4;
            color: #555;
        }

        .tier-list div {
            margin-bottom: 2px;
        }

        /* Career Skills/Talents Highlighting */
        .career-skill {
            background: #e8f5e8 !important;
            border: 1px solid #c3e6c3 !important;
        }

        .career-talent {
            background: #e8f5e8 !important;
            border: 1px solid #c3e6c3 !important;
            position: relative;
        }

        .career-talent::after {
            content: "â˜…";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #2d4a2d;
            font-size: 12px;
        }

        /* Career characteristic advancement styling */
        .career-available {
            background: #e8f5e8 !important;
            border-left: 4px solid #4a9b4a !important;
        }
        .career-tier-1 {
            background: #e8f5e8 !important;
            border-left: 4px solid #4a9b4a !important;
        }
        .career-tier-2 {
            background: #f5e8e0 !important;
            border-left: 4px solid #b87333 !important;
        }
        .career-tier-3 {
            background: #f0f0f5 !important;
            border-left: 4px solid #8b8b94 !important;
        }
        .career-tier-4 {
            background: #fdf5e6 !important;
            border-left: 4px solid #d4af37 !important;
        }

        .career-future {
            background: #f5f5e8 !important;
            border-left: 4px solid #ccb366 !important;
        }

        /* Characteristic Advance Indicators */
        .characteristic-row {
            position: relative;
        }

        .advance-limit-indicator {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #2d4a2d;
            font-weight: bold;
            background: rgba(232, 245, 232, 0.8);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .advance-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Character Setup Wizard Styling */
        .setup-step {
            padding: 5px 10px;
            border-radius: 15px;
            background: #e8dfd0;
            color: #666;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .setup-step.active {
            background: #3e2f1f;
            color: #faf8f3;
        }

        .setup-step.completed {
            background: #4a9b4a;
            color: white;
        }

        /* Mobile responsiveness for career system */
        @media (max-width: 768px) {
            .career-controls {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .tier-details {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .tier-category {
                padding: 8px;
            }
        }

        /* Species Creation Wizard Styles */
        .wizard-step {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #c4b5a0;
            color: #3e2f1f;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid #3e2f1f;
        }

        .wizard-step.active {
            background: #3e2f1f;
            color: #faf8f3;
        }

        .wizard-step.completed {
            background: #228b22;
            color: white;
            border-color: #228b22;
        }

        .wizard-content {
            min-height: 400px;
        }

        .char-advance-group {
            text-align: center;
            padding: 10px;
            border: 1px solid #d0c5a0;
            border-radius: 5px;
            background: #f9f7f1;
        }

        .char-advance-group label {
            display: block;
            font-weight: bold;
            color: #3e2f1f;
            margin-bottom: 8px;
        }

        .char-advance-group input {
            border: 1px solid #c4b5a0;
            border-radius: 3px;
            padding: 4px;
            text-align: center;
        }

        .skill-checkbox-item, .talent-checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid #d0c5a0;
            border-radius: 5px;
            background: #f9f7f1;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .skill-checkbox-item:hover, .talent-checkbox-item:hover {
            background: #f0eadb;
        }

        .skill-checkbox-item.disabled, .talent-checkbox-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-checkbox-item input, .talent-checkbox-item input {
            margin-right: 8px;
        }

        /* Experience & Status Grid */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .info-box {
            border: 2px solid #3e2f1f;
            background: white;
            padding: 10px;
        }

        .info-box-title {
            font-size: 11px;
            font-weight: bold;
            color: #3e2f1f;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            text-align: center;
            border-bottom: 1px solid #8b7355;
            padding-bottom: 3px;
        }

        .info-box input {
            width: 100%;
            border: 1px solid #8b7355;
            padding: 5px;
            text-align: center;
            font-size: 14px;
            margin-top: 5px;
        }

        /* Session Notes Specific Styles */
        #session-editor {
            font-family: Georgia, serif;
            line-height: 1.6;
        }

        #session-editor h1, #session-editor h2, #session-editor h3 {
            color: #3e2f1f;
            margin: 15px 0 10px 0;
        }

        #session-editor h1 { font-size: 20px; }
        #session-editor h2 { font-size: 18px; }
        #session-editor h3 { font-size: 16px; }

        #session-editor ul, #session-editor ol {
            margin: 10px 0;
            padding-left: 25px;
        }

        #session-editor li {
            margin-bottom: 5px;
        }

        #session-editor p {
            margin: 8px 0;
        }

        #session-editor strong {
            color: #3e2f1f;
        }

        /* Editor toolbar styles */
        #editor-toolbar button:hover,
        #editor-toolbar select:hover {
            background: #f0f0f0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-grid {
                grid-template-columns: 1fr;
            }
            
            .secondary-grid {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .characteristics-table {
                font-size: 12px;
            }
            
            .characteristics-table input {
                font-size: 12px;
            }

            .skills-table {
                font-size: 10px;
            }

            .skills-controls {
                flex-direction: column;
                align-items: stretch;
            }

            /* Session Notes Mobile Styles */
            .tab-navigation {
                flex-wrap: wrap;
            }

            .tab-button {
                min-width: 80px;
                font-size: 11px;
                padding: 12px 8px;
            }

            #session-metadata {
                padding: 10px;
            }

            #session-metadata > div:first-child {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            #editor-toolbar {
                padding: 5px;
                gap: 3px;
                flex-wrap: wrap;
            }

            #editor-toolbar button,
            #editor-toolbar select {
                padding: 4px 6px;
                font-size: 11px;
            }

            #session-editor {
                min-height: 300px;
                font-size: 13px;
                padding: 10px;
            }

            /* Session list modal mobile */
            #session-list-modal > div {
                min-width: 90%;
                max-width: 95%;
                margin: 20px;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .tab-button {
                font-size: 10px;
                padding: 10px 6px;
            }
        }
    </style>
</head>
<body>
    <!-- Auto-Save Status Indicator -->
    <div id="save-status-container" class="save-status-container saved-local fade-out">
        <div class="save-status-indicator"></div>
        <span class="save-status-text" id="save-status-text">Ready</span>
    </div>

    <div class="character-sheet">
        <!-- Character Setup Button -->
        <div style="text-align: center; margin: 10px 0;">
            <button onclick="startCharacterSetup()" style="padding: 12px 24px; background: #8b0000; color: white; border: 2px solid #660000; cursor: pointer; font-size: 14px; font-weight: bold; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);" title="Begin guided character creation process">
                ðŸŽ­ Character Setup Wizard
            </button>
        </div>

        <!-- Header Section -->
        <div class="sheet-header">
            <div class="header-grid">
                <div class="header-field character-name">
                    <label>Character Name</label>
                    <input type="text" id="character-name" placeholder="Enter name...">
                </div>
                <div class="header-field">
                    <label>Species</label>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <select id="species" style="flex: 1; padding: 5px; font-family: Georgia, serif; border: 1px solid #8b7355;">
                            <option value="">Select Species</option>
                            <option value="Human">Human</option>
                            <option value="Dwarf">Dwarf</option>
                            <option value="Halfling">Halfling</option>
                            <option value="High Elf">High Elf</option>
                            <option value="Wood Elf">Wood Elf</option>
                        </select>
                        <button onclick="manualOpenSpeciesWizard()" style="padding: 8px 12px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer; font-size: 11px; border-radius: 3px;" title="Open Species Creation Wizard">Wizard</button>
                    </div>
                </div>
                <div class="header-field">
                    <label>Class</label>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <select id="class" style="flex: 1; padding: 5px; font-family: Georgia, serif; border: 1px solid #8b7355;" onchange="handleClassSelection()">
                            <option value="">Select Class</option>
                            <option value="Academic">Academic</option>
                            <option value="Burgher">Burgher</option>
                            <option value="Courtier">Courtier</option>
                            <option value="Peasant">Peasant</option>
                            <option value="Ranger">Ranger</option>
                            <option value="Riverfolk">Riverfolk</option>
                            <option value="Rogue">Rogue</option>
                            <option value="Warrior">Warrior</option>
                        </select>
                        <button onclick="manualOpenClassWizard()" style="padding: 8px 12px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer; font-size: 11px; border-radius: 3px;" title="Open Class Trappings Wizard">Wizard</button>
                    </div>
                </div>
                <div class="header-field">
                    <label>Player</label>
                    <input type="text" id="player" placeholder="Player Name">
                </div>
                <div class="header-field">
                    <label>Tier</label>
                    <select id="global-tier" onchange="handleGlobalTierChange()" style="padding: 5px; font-family: Georgia, serif; border: 1px solid #8b7355;">
                        <option value="1">Tier 1</option>
                        <option value="2">Tier 2</option>
                        <option value="3">Tier 3</option>
                        <option value="4">Tier 4</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Career System Section -->
        <div class="career-section" id="career-section">
            <div class="career-header">
                <div class="career-title">Career Path</div>
            </div>
            
            <div class="career-controls">
                <div class="career-field">
                    <label>Career</label>
                    <select id="career-select" onchange="handleCareerSelection()">
                        <option value="">Select Career</option>
                    </select>
                </div>
                
                <div class="career-field">
                    <label>Current Tier</label>
                    <select id="tier-select" onchange="handleTierSelection()" disabled>
                        <option value="1">Tier 1</option>
                        <option value="2">Tier 2</option>
                        <option value="3">Tier 3</option>
                        <option value="4">Tier 4</option>
                    </select>
                </div>
                
                <div class="career-field">
                    <label>Class</label>
                    <div id="career-class" style="padding: 8px; font-size: 13px; color: #666; font-style: italic;">-</div>
                </div>
            </div>
            
            <div class="career-actions" id="career-actions" style="display: none; margin: 15px 0;">
                <button id="enter-career-btn" onclick="confirmCareerSelection()" 
                        style="padding: 10px 20px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; border-radius: 4px; font-family: Georgia, serif; cursor: pointer;">
                    Enter Career
                </button>
                <button id="cancel-career-btn" onclick="cancelCareerSelection()" 
                        style="padding: 10px 20px; background: #666; color: white; border: 1px solid #444; border-radius: 4px; font-family: Georgia, serif; cursor: pointer; margin-left: 10px;">
                    Cancel
                </button>
            </div>
            
            <div id="tier-info" class="tier-info" style="display: none;">
                <div class="tier-info-header">
                    <div class="tier-name" id="tier-name">-</div>
                    <div class="tier-status" id="tier-status">-</div>
                </div>
                
                <div class="tier-details">
                    <div class="tier-category">
                        <div class="tier-category-title">Skills</div>
                        <div class="tier-list" id="tier-skills">-</div>
                    </div>
                    
                    <div class="tier-category">
                        <div class="tier-category-title">Talents</div>
                        <div class="tier-list" id="tier-talents">-</div>
                    </div>
                    
                    <div class="tier-category">
                        <div class="tier-category-title">Trappings</div>
                        <div class="tier-list" id="tier-trappings">-</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Google Drive Integration Section -->
        <div class="google-drive-section" id="google-drive-section">
            <div class="google-drive-status" id="google-drive-status">
                <div class="status-indicator"></div>
                <span id="google-drive-status-text">Not connected to Google Drive</span>
            </div>
            <div class="google-drive-controls">
                <button class="google-drive-btn" id="google-signin-btn" onclick="signInToGoogle()">
                    ðŸ”— Connect Google Drive
                </button>
                <button class="google-drive-btn disconnect" id="google-signout-btn" onclick="signOutFromGoogle()" style="display: none;">
                    â›” Disconnect
                </button>
                <button class="google-drive-btn backup" id="backup-character-btn" onclick="backupCharacterToDrive()" disabled>
                    ðŸ’¾ Backup Character
                </button>
                <button class="google-drive-btn restore" id="restore-character-btn" onclick="openRestoreDialog()" disabled>
                    ðŸ“‚ Restore Character
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="sheet-content">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="showTab('character-tab')">Character</button>
                <button class="tab-button" onclick="showTab('combat-equipment-tab')">Combat & Equipment</button>
                <button class="tab-button" onclick="showTab('magic-afflictions-tab')">Magic & Afflictions</button>
                <button class="tab-button" onclick="showTab('session-notes-tab')">Session Notes</button>
            </div>

            <!-- Tab 1: Character Basics -->
            <div id="character-tab" class="tab-content active">
            <!-- Primary Characteristics Table -->
            <div class="characteristics-section">
                <div class="section-title">Characteristics</div>
                <table class="characteristics-table">
                    <thead>
                        <tr>
                            <th style="width: 30%;">Characteristic</th>
                            <th style="width: 15%;">Initial</th>
                            <th style="width: 15%;">Advances</th>
                            <th style="width: 15%;" class="current-cell">Current</th>
                            <th style="width: 25%;">Advance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr data-characteristic="ws">
                            <td class="char-name-cell">Weapon Skill (WS)</td>
                            <td><input type="number" id="ws-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="ws-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="ws-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('ws')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="ws-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="bs">
                            <td class="char-name-cell">Ballistic Skill (BS)</td>
                            <td><input type="number" id="bs-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="bs-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="bs-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('bs')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="bs-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="s">
                            <td class="char-name-cell">Strength (S)</td>
                            <td><input type="number" id="s-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="s-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="s-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('s')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="s-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="t">
                            <td class="char-name-cell">Toughness (T)</td>
                            <td><input type="number" id="t-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="t-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="t-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('t')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="t-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="i">
                            <td class="char-name-cell">Initiative (I)</td>
                            <td><input type="number" id="i-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="i-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="i-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('i')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="i-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="agi">
                            <td class="char-name-cell">Agility (Ag)</td>
                            <td><input type="number" id="agi-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="agi-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="agi-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('agi')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="agi-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="dex">
                            <td class="char-name-cell">Dexterity (Dex)</td>
                            <td><input type="number" id="dex-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="dex-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="dex-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('dex')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="dex-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="int">
                            <td class="char-name-cell">Intelligence (Int)</td>
                            <td><input type="number" id="int-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="int-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="int-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('int')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="int-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="wp">
                            <td class="char-name-cell">Willpower (WP)</td>
                            <td><input type="number" id="wp-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="wp-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="wp-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('wp')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="wp-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                        <tr data-characteristic="fel">
                            <td class="char-name-cell">Fellowship (Fel)</td>
                            <td><input type="number" id="fel-initial" placeholder="20" min="0" max="100"></td>
                            <td><input type="number" id="fel-advances" placeholder="0" min="0"></td>
                            <td class="current-cell"><input type="number" id="fel-current" placeholder="20" readonly></td>
                            <td style="text-align: center;">
                                <button onclick="window.advanceCharacteristic('fel')" style="padding: 5px 10px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                                <span id="fel-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(25 XP)</span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Skills Section -->
            <div class="characteristics-section skills-section">
                <div class="section-title">Skills</div>
                <div class="skills-controls">
                    <select class="skills-filter" id="skills-filter">
                        <option value="all">All Skills</option>
                        <option value="career">Career Skills</option>
                        <option value="basic">Basic Skills</option>
                        <option value="advanced">Advanced Skills</option>
                    </select>
                    <button class="control-btn" onclick="window.addSkill()" style="padding: 5px 10px; font-size: 12px;">+ Add Skill</button>
                </div>
                
                <!-- Unified Skills Table -->
                <table class="skills-table" id="skills-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">Skill</th>
                            <th style="width: 8%;">Char</th>
                            <th style="width: 8%;">Type</th>
                            <th style="width: 8%;">Career</th>
                            <th style="width: 8%;">Adv</th>
                            <th style="width: 8%;">Total</th>
                            <th style="width: 20%;">Advance</th>
                            <th style="width: 13%;">Notes</th>
                            <th style="width: 2%;">Del</th>
                        </tr>
                    </thead>
                    <tbody id="skills-tbody">
                    </tbody>
                </table>

                <!-- Add Skill Modal -->
                <div id="add-skill-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 400px;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Skill</h3>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Skill:</label>
                            <select id="skill-select" style="width: 100%; padding: 5px;" onchange="window.toggleSpecialisationField()">
                                <option value="">Select a skill...</option>
                            </select>
                        </div>
                        <div id="specialisation-field" style="margin-bottom: 15px; display: none;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Specialisation:</label>
                            <input type="text" id="specialisation-input" placeholder="e.g. Fighting, Battle, Bow..." style="width: 100%; padding: 5px;">
                        </div>
                        <div style="text-align: center;">
                            <button class="control-btn" onclick="window.confirmAddSkill()" style="margin-right: 10px; padding: 8px 16px;">Add Skill</button>
                            <button class="control-btn" onclick="window.closeAddSkillModal()" style="padding: 8px 16px;">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
<!-- Talents Section -->
            <div class="characteristics-section">
                <div class="section-title">Talents</div>
                <div class="talents-controls" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                    <button class="control-btn" onclick="window.addTalent()" style="padding: 5px 10px; font-size: 12px;">+ Add Talent</button>
                    <input type="text" id="talents-search" placeholder="Search talents..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white;">
                </div>
                
                <table class="skills-table" id="talents-table">
                    <thead>
                        <tr>
                            <th style="width: 18%;">Talent</th>
                            <th style="width: 10%;">Times Taken</th>
                            <th style="width: 12%;">Advance</th>
                            <th style="width: 35%;">Description</th>
                            <th style="width: 22%;">Notes</th>
                            <th style="width: 3%;">Del</th>
                        </tr>
                    </thead>
                    <tbody id="talents-tbody">
                    </tbody>
                </table>

                <!-- Add Talent Modal -->
                <div id="add-talent-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 500px; max-width: 600px; max-height: 70vh; overflow-y: auto;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Talent</h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Search Talents:</label>
                            <input type="text" id="talent-search-modal" placeholder="Type to search..." style="width: 100%; padding: 5px;" oninput="window.filterTalentOptions()">
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Select Talent:</label>
                            <select id="talent-select" size="8" style="width: 100%; padding: 5px;" onchange="window.showTalentDetails()">
                            </select>
                        </div>
                        
                        <div id="talent-details" style="display: none; margin-bottom: 15px; padding: 10px; background: #e8dfd0; border: 1px solid #8b7355;">
                            <h4 style="color: #3e2f1f; margin-bottom: 10px;">Talent Details</h4>
                            <p><strong>Name:</strong> <span id="detail-talent-name"></span></p>
                            <p><strong>Max:</strong> <span id="detail-talent-max"></span></p>
                            <p><strong>Tests:</strong> <span id="detail-talent-tests"></span></p>
                            <p style="margin-top: 10px;"><strong>Description:</strong></p>
                            <p id="detail-talent-description" style="font-style: italic; line-height: 1.4;"></p>
                        </div>
                        
                        <div id="talent-customisation" style="display: none; margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Specialisation/Details:</label>
                            <input type="text" id="talent-customisation-input" placeholder="e.g., specific skill, weapon group, etc." style="width: 100%; padding: 5px;">
                        </div>
                        
                        <div id="talent-times-taken" style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Number to Add:</label>
                            <input type="number" id="talent-times-input" value="1" min="1" max="10" style="width: 100px; padding: 5px;">
                        </div>
                        
                        <div style="margin-bottom: 15px; padding: 10px; background: #f0e6d2; border: 1px solid #8b7355; border-radius: 3px;">
                            <label style="display: flex; align-items: center; color: #3e2f1f; font-size: 14px; cursor: pointer;">
                                <input type="checkbox" id="talent-xp-override" style="margin-right: 8px;">
                                <strong>Add for Free</strong> <span style="margin-left: 8px; font-size: 12px; color: #666;">(mutation, story reward, etc.)</span>
                            </label>
                        </div>
                        
                        <div style="text-align: center;">
                            <button class="control-btn" onclick="window.confirmAddTalent()" style="margin-right: 10px; padding: 8px 16px;">Add Talent</button>
                            <button class="control-btn" onclick="window.closeAddTalentModal()" style="padding: 8px 16px;">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Secondary Characteristics -->
            <div class="characteristics-section">
                <div class="section-title">Secondary Characteristics</div>
                <div class="secondary-grid">
                    <table class="secondary-table">
                        <tr>
                            <th>Wounds</th>
                            <td style="width: 40%;"><input type="number" id="wounds-current" placeholder="12"></td>
                            <td style="width: 10%; text-align: center;">/</td>
                            <td style="width: 40%;"><input type="number" id="wounds-max" placeholder="12" readonly style="background: #f5f5f0; color: #666;" title="Auto-calculated based on species and characteristics"></td>
                        </tr>
                    </table>

                    <table class="secondary-table">
                        <tr>
                            <th>Movement</th>
                            <td><input type="number" id="movement" placeholder="4"></td>
                        </tr>
                        <tr>
                            <th>Walk</th>
                            <td><input type="number" id="walk" placeholder="8" readonly></td>
                        </tr>
                        <tr>
                            <th>Run</th>
                            <td><input type="number" id="run" placeholder="16" readonly></td>
                        </tr>
                    </table>
                </div>
            </div>


            <!-- Fate, Fortune, Resilience & Resolve -->
            <div class="characteristics-section">
                <div class="section-title">Fate & Fortune / Resilience & Resolve</div>
                <div class="secondary-grid">
                    <div style="background: #f8f6f0; border: 2px solid #3e2f1f; padding: 15px; border-radius: 5px;">
                        <h4 style="color: #3e2f1f; margin-top: 0; margin-bottom: 10px; font-size: 14px;">Fate & Fortune</h4>
                        
                        <!-- Fate Points -->
                        <div style="display: flex; align-items: center; margin-bottom: 10px; gap: 10px;">
                            <label style="width: 60px; color: #3e2f1f; font-weight: bold; font-size: 13px;">Fate:</label>
                            <button onclick="window.updateFate(-1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">âˆ’</button>
                            <input type="number" id="fate" placeholder="0" style="width: 50px; text-align: center; border: 1px solid #8b7355;">
                            <button onclick="window.updateFate(1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">+</button>
                        </div>
                        
                        <!-- Fortune Points -->
                        <div style="display: flex; align-items: center; margin-bottom: 10px; gap: 10px;">
                            <label style="width: 60px; color: #3e2f1f; font-weight: bold; font-size: 13px;">Fortune:</label>
                            <button onclick="window.updateFortune(-1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">âˆ’</button>
                            <input type="number" id="fortune-current" placeholder="0" style="width: 40px; text-align: center; border: 1px solid #8b7355;">
                            <span style="color: #666; font-size: 13px;">/</span>
                            <span id="fortune-max" style="color: #666; font-size: 13px; width: 20px;">0</span>
                            <button onclick="window.updateFortune(1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">+</button>
                            <button onclick="window.restoreFortune()" style="padding: 3px 8px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer; margin-left: 5px;">Restore</button>
                        </div>
                    </div>
                    
                    <div style="background: #f0f6f8; border: 2px solid #3e2f1f; padding: 15px; border-radius: 5px;">
                        <h4 style="color: #3e2f1f; margin-top: 0; margin-bottom: 10px; font-size: 14px;">Resilience & Resolve</h4>
                        
                        <!-- Resilience Points -->
                        <div style="display: flex; align-items: center; margin-bottom: 10px; gap: 10px;">
                            <label style="width: 70px; color: #3e2f1f; font-weight: bold; font-size: 13px;">Resilience:</label>
                            <button onclick="window.updateResilience(-1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">âˆ’</button>
                            <input type="number" id="resilience" placeholder="0" style="width: 50px; text-align: center; border: 1px solid #8b7355;">
                            <button onclick="window.updateResilience(1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">+</button>
                        </div>
                        
                        <!-- Resolve Points -->
                        <div style="display: flex; align-items: center; margin-bottom: 10px; gap: 10px;">
                            <label style="width: 70px; color: #3e2f1f; font-weight: bold; font-size: 13px;">Resolve:</label>
                            <button onclick="window.updateResolve(-1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">âˆ’</button>
                            <input type="number" id="resolve-current" placeholder="0" style="width: 40px; text-align: center; border: 1px solid #8b7355;">
                            <span style="color: #666; font-size: 13px;">/</span>
                            <span id="resolve-max" style="color: #666; font-size: 13px; width: 20px;">0</span>
                            <button onclick="window.updateResolve(1)" style="width: 25px; height: 25px; cursor: pointer; background: #e8dfd0; border: 1px solid #8b7355;">+</button>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <table class="secondary-table" style="width: 100%;">
                        <tr>
                            <th style="width: 20%;">Motivation</th>
                            <td><input type="text" id="motivation" placeholder="What drives your character forward?" style="width: 100%; border: none;"></td>
                        </tr>
                    </table>
                </div>
            </div>


            <!-- Experience & Status -->
            <div class="info-grid">
                <div class="info-box">
                    <div class="info-box-title">Experience Points</div>
                    <div style="display: flex; gap: 2px; margin-bottom: 5px;">
                        <button onclick="window.openXPEarnDialog()" style="flex: 1; padding: 5px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer; font-size: 11px;">Add Session XP</button>
                        <button onclick="window.openXPHistoryDialog()" style="flex: 1; padding: 5px; background: #5a4a3a; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer; font-size: 11px;">View History</button>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 2px;"><span>Total XP:</span><span id="xp-total-display">0</span></div>
                    <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 2px;"><span>Current XP:</span><span id="xp-current-display">0</span></div>
                    <div style="display: flex; justify-content: space-between; font-size: 11px;"><span>Spent XP:</span><span id="xp-spent-display">0</span></div>
                    <input type="hidden" id="xp-total" value="0">
                    <input type="hidden" id="xp-spent" value="0">
                </div>
                <div class="info-box">
                    <div class="info-box-title">Status</div>
                    <select id="status-tier" style="width: 100%; padding: 5px; text-align: center; font-size: 14px; margin-top: 5px; border: 1px solid #8b7355;">
                        <option value="Brass">Brass</option>
                        <option value="Silver">Silver</option>
                        <option value="Gold">Gold</option>
                    </select>
                    <input type="number" id="status-standing" placeholder="Standing">
                </div>
                <div class="info-box">
                    <div class="info-box-title">Sin Points</div>
                    <input type="number" id="sin-points" placeholder="0" min="0">
                </div>
                <div class="info-box">
                    <div class="info-box-title">Notes</div>
                    <textarea id="quick-notes" style="width: 100%; height: 60px; margin-top: 5px; border: 1px solid #8b7355; padding: 5px;" placeholder="Quick notes..."></textarea>
                </div>
            </div>


            </div> <!-- End Tab 1 -->

            <!-- Tab 2: Combat & Equipment -->
            <div id="combat-equipment-tab" class="tab-content">

            <!-- Conditions & Status Effects -->
            <div class="section">
                <div class="section-title">Conditions & Status Effects</div>
                
                <!-- Penalty Summary -->
                <div id="condition-penalties-summary" style="background: #fff8dc; border: 2px solid #d4a574; padding: 10px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #8b4513; margin: 0 0 8px 0; font-size: 14px;">ðŸ“Š Active Penalties</h4>
                    <div id="penalty-text" style="color: #8b4513; font-size: 13px; font-weight: bold;"></div>
                </div>
                
                <!-- Conditions Controls -->
                <div class="conditions-controls" style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                    <button class="control-btn" onclick="window.openAddConditionModal()" style="padding: 5px 10px; font-size: 12px;">+ Add Condition</button>
                    <button class="control-btn" onclick="window.removeAllConditions()" style="padding: 5px 10px; font-size: 12px; background: #c41e3a; color: white;">Clear All</button>
                    <input type="text" id="conditions-search" placeholder="Search active conditions..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white; flex: 1; min-width: 200px;">
                </div>
                
                <!-- Active Conditions Display -->
                <div id="active-conditions-display" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 10px; margin-bottom: 15px;">
                    <!-- Conditions will be dynamically populated here -->
                </div>
                
                <!-- No Conditions Message -->
                <div id="no-conditions-message" style="text-align: center; padding: 20px; color: #666; font-style: italic; display: none;">
                    No conditions currently affecting this character.
                </div>

                <!-- Add Condition Modal -->
                <div id="add-condition-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 500px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add WFRP Condition</h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Select Condition:</label>
                            <select id="condition-select" style="width: 100%; padding: 8px; font-size: 14px;" onchange="window.showConditionDetails()">
                                <option value="">-- Choose a condition --</option>
                            </select>
                        </div>
                        
                        <div id="condition-details" style="display: none; margin-bottom: 15px; padding: 15px; background: #e8dfd0; border: 2px solid #8b7355; border-radius: 5px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #3e2f1f; margin: 0;" id="detail-condition-name"></h4>
                                <span id="condition-severity-badge" style="padding: 3px 8px; font-size: 11px; color: white; border-radius: 3px; font-weight: bold;"></span>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong style="color: #3e2f1f;">Stackable:</strong> 
                                <span id="detail-condition-stackable" style="font-weight: bold;"></span>
                            </div>
                            <div>
                                <strong style="color: #3e2f1f;">Effects:</strong>
                                <p id="detail-condition-effects" style="font-style: italic; line-height: 1.4; margin: 5px 0; color: #333;"></p>
                            </div>
                        </div>
                        
                        <div id="stacks-input-section" style="margin-bottom: 15px; display: none;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Number of Stacks to Add:</label>
                            <input type="number" id="condition-stacks-input" value="1" min="1" max="10" style="width: 80px; padding: 5px; text-align: center;">
                            <span style="margin-left: 10px; color: #666; font-size: 13px;">This condition can stack - add multiple at once if needed</span>
                        </div>
                        
                        <div style="text-align: center;">
                            <button class="control-btn" onclick="window.confirmAddCondition()" style="margin-right: 10px; padding: 8px 16px;">Add Condition</button>
                            <button class="control-btn" onclick="window.closeAddConditionModal()" style="padding: 8px 16px;">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Combat Section -->
            <div class="characteristics-section">
                <div class="section-title">Combat</div>
                
                <!-- Weapons Table -->
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Weapons</h4>
                        <button class="control-btn" onclick="window.addWeapon()" style="padding: 5px 10px; font-size: 12px;">+ Add Weapon</button>
                    </div>
                    <table class="skills-table" id="weapons-table">
                        <thead>
                            <tr>
                                <th style="width: 22%;">Weapon</th>
                                <th style="width: 10%;">Group</th>
                                <th style="width: 8%;">Enc</th>
                                <th style="width: 10%;">Range</th>
                                <th style="width: 12%;">Damage</th>
                                <th style="width: 28%;">Qualities & Flaws</th>
                                <th style="width: 8%;">Equipped</th>
                                <th style="width: 2%;">Del</th>
                            </tr>
                        </thead>
                        <tbody id="weapons-tbody">
                        </tbody>
                    </table>
                </div>

                <!-- Armour Table -->
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Armour</h4>
                        <button class="control-btn" onclick="window.addArmour()" style="padding: 5px 10px; font-size: 12px;">+ Add Armour</button>
                    </div>
                    <table class="skills-table" id="armour-table">
                        <thead>
                            <tr>
                                <th style="width: 22%;">Armour</th>
                                <th style="width: 10%;">Type</th>
                                <th style="width: 8%;">Enc</th>
                                <th style="width: 8%;">Head</th>
                                <th style="width: 8%;">Arms</th>
                                <th style="width: 8%;">Body</th>
                                <th style="width: 8%;">Legs</th>
                                <th style="width: 18%;">Qualities & Flaws</th>
                                <th style="width: 8%;">Worn</th>
                                <th style="width: 2%;">Del</th>
                            </tr>
                        </thead>
                        <tbody id="armour-tbody">
                        </tbody>
                    </table>
                </div>

                <!-- Armour Points Summary -->
                <div style="margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">Total Armour Points</h4>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Head</div>
                            <input type="number" id="total-ap-head" value="0" readonly style="text-align: center; font-weight: bold;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Arms</div>
                            <input type="number" id="total-ap-arms" value="0" readonly style="text-align: center; font-weight: bold;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Body</div>
                            <input type="number" id="total-ap-body" value="0" readonly style="text-align: center; font-weight: bold;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Legs</div>
                            <input type="number" id="total-ap-legs" value="0" readonly style="text-align: center; font-weight: bold;">
                        </div>
                    </div>
                </div>
            </div>


            <!-- Equipment & Inventory Section -->
            <div class="characteristics-section">
                <div class="section-title">Equipment & Inventory</div>
                
                <!-- Money Tracker -->
                <div style="margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">Wealth</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Gold Crowns</div>
                            <input type="number" id="money-gold" value="0" min="0" onchange="window.updateEncumbrance()" style="text-align: center;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Silver Shillings</div>
                            <input type="number" id="money-silver" value="0" min="0" onchange="window.updateEncumbrance()" style="text-align: center;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Brass Pennies</div>
                            <input type="number" id="money-brass" value="0" min="0" onchange="window.updateEncumbrance()" style="text-align: center;">
                        </div>
                    </div>
                </div>

                <!-- Encumbrance Tracker -->
                <div style="margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">Encumbrance</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Current Enc</div>
                            <input type="number" id="current-enc" value="0" readonly style="text-align: center; font-weight: bold;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Max Enc (SB+TB)</div>
                            <input type="number" id="max-enc" value="0" readonly style="text-align: center;">
                        </div>
                        <div class="info-box" style="padding: 8px;">
                            <div class="info-box-title" style="font-size: 10px;">Status</div>
                            <input type="text" id="enc-status" value="Unencumbered" readonly style="text-align: center; font-size: 12px;">
                        </div>
                    </div>
                    <div style="font-size: 11px; color: #8b7355; line-height: 1.4;">
                        <div id="enc-details" style="padding: 5px; background: #f5f0e8; border: 1px solid #d4c5a0;">
                            <strong>Encumbrance Breakdown:</strong>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                                <div>â€¢ Weapons (equipped): <span id="enc-weapons">0</span></div>
                                <div>â€¢ Armour (worn -1 Enc): <span id="enc-armour">0</span></div>
                                <div>â€¢ Trappings: <span id="enc-trappings">0</span></div>
                                <div>â€¢ Money (200 coins = 1 Enc): <span id="enc-money">0</span></div>
                            </div>
                            <div style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #d4c5a0;">
                                <strong>Current Penalties:</strong> <span id="enc-penalties" style="color: green;">None</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Trappings/Inventory -->
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Trappings & Equipment</h4>
                        <button class="control-btn" onclick="window.addTrapping()" style="padding: 5px 10px; font-size: 12px;">+ Add Item</button>
                    </div>
                    <table class="skills-table" id="trappings-table">
                        <thead>
                            <tr>
                                <th style="width: 30%;">Item</th>
                                <th style="width: 10%;">Quantity</th>
                                <th style="width: 10%;">Enc (each)</th>
                                <th style="width: 10%;">Total Enc</th>
                                <th style="width: 15%;">Location</th>
                                <th style="width: 23%;">Notes</th>
                                <th style="width: 2%;">Del</th>
                            </tr>
                        </thead>
                        <tbody id="trappings-tbody">
                        </tbody>
                    </table>
                </div>

                <!-- Ammunition & Consumables -->
                <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="color: #3e2f1f; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Ammunition & Consumables</h4>
                        <button class="control-btn" onclick="window.addConsumable()" style="padding: 5px 10px; font-size: 12px;">+ Add Consumable</button>
                    </div>
                    <table class="skills-table" id="consumables-table">
                        <thead>
                            <tr>
                                <th style="width: 20%;">Item</th>
                                <th style="width: 15%;">Current</th>
                                <th style="width: 10%;">Maximum</th>
                                <th style="width: 25%;">Qualities & Flaws</th>
                                <th style="width: 28%;">Notes</th>
                                <th style="width: 2%;">Del</th>
                            </tr>
                        </thead>
                        <tbody id="consumables-tbody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Critical Wounds & Injuries -->
            <div class="section">
                <div class="section-title">Critical Wounds & Injuries</div>
                
                <!-- Wound Penalties Summary -->
                <div id="wound-penalties-summary" style="background: #ffe4e6; border: 2px solid #c41e3a; padding: 10px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #8b0000; margin: 0 0 8px 0; font-size: 14px;">ðŸ©¸ Active Wound Penalties</h4>
                    <div id="wound-penalty-text" style="color: #8b0000; font-size: 13px; font-weight: bold;"></div>
                </div>
                
                <!-- Wounds Controls -->
                <div class="wounds-controls" style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                    <button class="control-btn" onclick="window.openAddWoundModal()" style="padding: 5px 10px; font-size: 12px;">+ Add Critical Wound</button>
                    <button class="control-btn" onclick="window.openWoundReferenceModal()" style="padding: 5px 10px; font-size: 12px; background: #4682b4; color: white;">ðŸ“– WFRP Reference</button>
                    <button class="control-btn" onclick="window.removeAllWounds()" style="padding: 5px 10px; font-size: 12px; background: #c41e3a; color: white;">Clear All</button>
                    <input type="text" id="wounds-search" placeholder="Search active wounds..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white; flex: 1; min-width: 200px;">
                </div>
                
                <!-- Active Wounds Display -->
                <div id="active-wounds-display" style="margin-bottom: 15px;">
                    <table style="width: 100%; border-collapse: collapse; background: #faf8f3; border: 2px solid #8b7355;">
                        <thead>
                            <tr style="background: #e8dfd0; color: #3e2f1f; font-weight: bold;">
                                <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Name</th>
                                <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Location</th>
                                <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Healing Progress</th>
                                <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Effects</th>
                                <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="wounds-tbody">
                            <!-- Wounds will be dynamically populated here -->
                        </tbody>
                    </table>
                </div>
                
                <!-- No Wounds Message -->
                <div id="no-wounds-message" style="text-align: center; padding: 20px; color: #666; font-style: italic; display: none;">
                    No critical wounds currently affecting this character.
                </div>

                <!-- Add Critical Wound Modal -->
                <div id="add-wound-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 600px; max-width: 700px; max-height: 80vh; overflow-y: auto;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Critical Wound</h3>
                        
                        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                            <div style="flex: 1;">
                                <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Wound Name:</label>
                                <input type="text" id="wound-name-input" style="width: 100%; padding: 8px; font-family: Georgia, serif;" placeholder="Enter wound name...">
                            </div>
                            <div style="flex: 1;">
                                <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Location:</label>
                                <select id="wound-location-select" style="width: 100%; padding: 8px; font-family: Georgia, serif;">
                                    <option value="">-- Select Location --</option>
                                    <option value="Head">Head</option>
                                    <option value="Right Arm">Right Arm</option>
                                    <option value="Left Arm">Left Arm</option>
                                    <option value="Body">Body</option>
                                    <option value="Right Leg">Right Leg</option>
                                    <option value="Left Leg">Left Leg</option>
                                </select>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                            <div style="flex: 1;">
                                <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Wounds Value:</label>
                                <input type="number" id="wound-wounds-input" style="width: 100%; padding: 8px; font-family: Georgia, serif;" min="0" placeholder="Wounds dealt...">
                            </div>
                            <div style="flex: 1;">
                                <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Healing Time (Days):</label>
                                <input type="number" id="wound-healing-time-input" style="width: 100%; padding: 8px; font-family: Georgia, serif;" min="0" placeholder="Days to heal...">
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Effects Description:</label>
                            <textarea id="wound-effects-input" style="width: 100%; padding: 8px; font-family: Georgia, serif; height: 80px; resize: vertical;" placeholder="Describe the wound effects, penalties, and conditions..."></textarea>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Notes:</label>
                            <textarea id="wound-notes-input" style="width: 100%; padding: 8px; font-family: Georgia, serif; height: 60px; resize: vertical;" placeholder="Additional notes, medical attention required, etc..."></textarea>
                        </div>
                        
                        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                            <div>
                                <input type="checkbox" id="wound-permanent-checkbox" style="margin-right: 5px;">
                                <label for="wound-permanent-checkbox" style="color: #3e2f1f; font-weight: bold;">Permanent Injury</label>
                                <div style="font-size: 12px; color: #666; margin-top: 2px;">This wound never fully heals</div>
                            </div>
                            <div>
                                <input type="checkbox" id="wound-surgery-checkbox" style="margin-right: 5px;">
                                <label for="wound-surgery-checkbox" style="color: #3e2f1f; font-weight: bold;">Surgery Required</label>
                                <div style="font-size: 12px; color: #666; margin-top: 2px;">Needs surgical intervention</div>
                            </div>
                        </div>
                        
                        <div style="text-align: center;">
                            <button class="control-btn" onclick="window.confirmAddWound()" style="margin-right: 10px; padding: 8px 16px;">Add Wound</button>
                            <button class="control-btn" onclick="window.closeAddWoundModal()" style="padding: 8px 16px;">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- WFRP Reference Modal -->
                <div id="wound-reference-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; width: 90%; max-width: 900px; height: 80vh; overflow-y: auto;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">WFRP 4th Edition Critical Wounds Reference</h3>
                        
                        <!-- Location Tabs -->
                        <div style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #8b7355;">
                            <button onclick="window.showWoundLocation('Head')" id="wound-tab-Head" style="padding: 8px 16px; background: #e8dfd0; border: none; color: #3e2f1f; font-weight: bold; cursor: pointer; border-top: 2px solid #8b7355; border-left: 2px solid #8b7355; border-right: 2px solid #8b7355;">Head</button>
                            <button onclick="window.showWoundLocation('Arm')" id="wound-tab-Arm" style="padding: 8px 16px; background: #f5f5f0; border: none; color: #666; cursor: pointer; border-top: 2px solid #8b7355; border-left: 2px solid #8b7355; border-right: 2px solid #8b7355;">Arms</button>
                            <button onclick="window.showWoundLocation('Body')" id="wound-tab-Body" style="padding: 8px 16px; background: #f5f5f0; border: none; color: #666; cursor: pointer; border-top: 2px solid #8b7355; border-left: 2px solid #8b7355; border-right: 2px solid #8b7355;">Body</button>
                            <button onclick="window.showWoundLocation('Leg')" id="wound-tab-Leg" style="padding: 8px 16px; background: #f5f5f0; border: none; color: #666; cursor: pointer; border-top: 2px solid #8b7355; border-left: 2px solid #8b7355; border-right: 2px solid #8b7355;">Legs</button>
                        </div>
                        
                        <!-- Search Box -->
                        <div style="margin-bottom: 15px;">
                            <input type="text" id="wound-reference-search" placeholder="Search wounds by name or effects..." style="width: 100%; padding: 8px; font-family: Georgia, serif; border: 2px solid #8b7355;">
                        </div>
                        
                        <!-- Wound Tables -->
                        <div id="wound-reference-content" style="max-height: 500px; overflow-y: auto;">
                            <!-- Content will be populated by showWoundLocation() -->
                        </div>
                        
                        <div style="text-align: center; margin-top: 15px;">
                            <button class="control-btn" onclick="window.closeWoundReferenceModal()" style="padding: 8px 16px;">Close</button>
                        </div>
                    </div>
                </div>
            </div>
            </div> <!-- End Tab 2 -->

            <!-- Tab 3: Magic & Afflictions -->
            <div id="magic-afflictions-tab" class="tab-content">

            <!-- Spells & Prayers -->
            <div class="section">
                <div class="section-title">Spells & Prayers</div>
                <div class="spells-controls" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                    <button class="control-btn" onclick="window.addSpell()" style="padding: 5px 10px; font-size: 12px;">+ Add Spell/Prayer</button>
                    <input type="text" id="spells-search" placeholder="Search spells..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white;">
                    <select id="spells-filter" style="padding: 5px; border: 1px solid #8b7355; font-family: 'Georgia', serif;">
                        <option value="all">All Types</option>
                        <option value="arcane">Arcane Spells</option>
                        <option value="divine">Divine Prayers</option>
                        <option value="memorised">Memorised Only</option>
                    </select>
                </div>
                
                <table class="skills-table" id="spells-table">
                    <thead>
                        <tr>
                            <th style="width: 18%;">Name</th>
                            <th style="width: 8%;">CN</th>
                            <th style="width: 12%;">Range</th>
                            <th style="width: 12%;">Target</th>
                            <th style="width: 10%;">Duration</th>
                            <th style="width: 28%;">Effect</th>
                            <th style="width: 8%;">Mem</th>
                            <th style="width: 4%;">Del</th>
                        </tr>
                    </thead>
                    <tbody id="spells-tbody">
                    </tbody>
                </table>
            </div>

            <!-- Corruption & Mutations -->
            <div class="section">
                <div class="section-title">Corruption & Mutations</div>
                
                <!-- Corruption Tracking -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; padding: 15px; background: #f8f6f0; border: 2px solid #8b7355; border-radius: 5px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Corruption Points:</label>
                        <input type="number" id="corruption-points" value="0" min="0" style="width: 80px; padding: 5px; text-align: center; font-weight: bold;" onchange="window.updateCorruptionStatus()">
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Threshold:</label>
                        <div id="corruption-threshold" style="padding: 5px; text-align: center; font-weight: bold; color: #666; background: #e8dfd0; border-radius: 3px;">0</div>
                        <div style="font-size: 10px; color: #666; text-align: center; margin-top: 2px;">(WP Bonus + T Bonus)</div>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Physical Mutations:</label>
                        <div id="physical-mutation-counter" style="padding: 5px; text-align: center; font-weight: bold; color: #666; background: #e8dfd0; border-radius: 3px;">0/0</div>
                        <div style="font-size: 10px; color: #666; text-align: center; margin-top: 2px;">(Current/T Bonus)</div>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Mental Corruptions:</label>
                        <div id="mental-corruption-counter" style="padding: 5px; text-align: center; font-weight: bold; color: #666; background: #e8dfd0; border-radius: 3px;">0/0</div>
                        <div style="font-size: 10px; color: #666; text-align: center; margin-top: 2px;">(Current/WP Bonus)</div>
                    </div>
                </div>
                
                <!-- Corruption Status Warnings -->
                <div id="corruption-test-warning" style="background: #fff2dc; border: 2px solid #ff8c00; padding: 10px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #cc7000; margin: 0 0 8px 0; font-size: 14px;">âš ï¸ Corruption Test Required</h4>
                    <div style="color: #cc7000; font-size: 13px;">Corruption exceeds threshold! Make a Challenging (+0) Endurance Test or gain a mutation.</div>
                </div>
                
                <div id="character-destruction-warning" style="background: #ffe4e6; border: 2px solid #c41e3a; padding: 10px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #8b0000; margin: 0 0 8px 0; font-size: 14px;">ðŸ’€ CHARACTER AT RISK</h4>
                    <div id="destruction-warning-text" style="color: #8b0000; font-size: 13px; font-weight: bold;"></div>
                </div>
                
                <div id="character-lost-warning" style="background: #2d1b1b; border: 2px solid #000; padding: 15px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #c41e3a; margin: 0 0 8px 0; font-size: 16px; text-align: center;">ðŸ’€ CHARACTER LOST TO CHAOS ðŸ’€</h4>
                    <div style="color: #c41e3a; font-size: 14px; text-align: center; font-weight: bold;">This character has been consumed by mutation and is no longer playable.</div>
                </div>
                
                <!-- Fellowship Warning -->
                <div id="fellowship-warning" style="background: #fff8dc; border: 2px solid #d4a574; padding: 10px; margin-bottom: 15px; border-radius: 5px; display: none;">
                    <h4 style="color: #8b4513; margin: 0 0 8px 0; font-size: 14px;">ðŸ‘¥ Fellowship Penalties</h4>
                    <div id="fellowship-warning-text" style="color: #8b4513; font-size: 13px;"></div>
                    <div style="color: #8b4513; font-size: 11px; margin-top: 8px; font-style: italic;">GM guidance: Apply circumstantial penalties based on situation and NPCs' reactions.</div>
                </div>
                
                <!-- Add Mutation Controls -->
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                    <button class="control-btn" onclick="window.openAddMutationModal()" style="padding: 5px 10px; font-size: 12px;">+ Add Mutation</button>
                    <input type="text" id="mutations-search" placeholder="Search mutations..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white; flex: 1; min-width: 200px;" oninput="window.displayMutations()">
                </div>
                
                <!-- Active Mutations Display -->
                <div id="active-mutations-display" style="margin-bottom: 15px;">
                    <!-- Mutations will be dynamically populated here -->
                </div>
                
                <!-- No Mutations Message -->
                <div id="no-mutations-message" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                    No mutations or corruptions currently affecting this character.
                </div>
                
                <!-- Add Mutation Modal -->
                <div id="add-mutation-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 600px; max-width: 700px; max-height: 80vh; overflow-y: auto;">
                        <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Mutation or Corruption</h3>
                        
                        <!-- Species Mutation Guidance -->
                        <div id="species-guidance" style="background: #e8dfd0; padding: 10px; margin-bottom: 15px; border-radius: 5px;">
                            <div style="font-size: 12px; color: #3e2f1f;"><strong>Species Mutation Distribution:</strong></div>
                            <div id="species-guidance-text" style="font-size: 11px; color: #666; margin-top: 3px;"></div>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Mutation Type:</label>
                            <select id="mutation-type-select" style="width: 100%; padding: 8px; font-size: 14px;" onchange="window.updateMutationOptions()">
                                <option value="">-- Choose Type --</option>
                                <option value="physical">Physical Mutation</option>
                                <option value="mental">Mental Corruption</option>
                            </select>
                        </div>
                        
                        <div id="mutation-selection" style="margin-bottom: 15px; display: none;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Specific Mutation:</label>
                            <select id="mutation-select" style="width: 100%; padding: 8px; font-size: 14px;" onchange="window.showMutationDetails()">
                                <option value="">-- Choose Mutation --</option>
                            </select>
                        </div>
                        
                        <!-- Mutation Details Display -->
                        <div id="mutation-details" style="display: none; background: #f8f6f0; padding: 15px; border: 1px solid #8b7355; border-radius: 5px; margin-bottom: 15px;">
                            <h4 id="detail-mutation-name" style="color: #3e2f1f; margin: 0 0 8px 0;"></h4>
                            <div id="detail-mutation-description" style="margin-bottom: 8px; font-style: italic;"></div>
                            <div><strong>Effects:</strong> <span id="detail-mutation-effects"></span></div>
                            <div id="detail-mutation-obvious" style="margin-top: 8px; font-size: 12px;"></div>
                            <div id="detail-mutation-fellowship" style="margin-top: 8px; font-size: 12px; color: #8b4513;"></div>
                        </div>
                        
                        <div style="text-align: right; margin-top: 20px;">
                            <button onclick="window.closeAddMutationModal()" style="padding: 8px 16px; margin-right: 10px; background: #ccc; border: none; cursor: pointer;">Cancel</button>
                            <button id="confirm-add-mutation-btn" onclick="window.confirmAddMutation()" style="padding: 8px 16px; background: #4682b4; color: white; border: none; cursor: pointer;" disabled>Add Mutation</button>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Diseases & Ailments -->
            <div class="section">
                <div class="section-title">Diseases & Ailments</div>
                
                <!-- Disease Controls -->
                <div class="disease-controls" style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                    <button class="control-btn" onclick="window.openAddDiseaseModal()" style="padding: 5px 10px; font-size: 12px;">+ Add Disease</button>
                    <button class="control-btn" onclick="window.removeAllDiseases()" style="padding: 5px 10px; font-size: 12px; background: #c41e3a; color: white;">Clear All</button>
                    <input type="text" id="diseases-search" placeholder="Search active diseases..." style="padding: 5px 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; background: white; flex: 1; min-width: 200px;">
                </div>
                
                <!-- Active Diseases Display -->
                <div id="active-diseases-display" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; margin-bottom: 15px;">
                    <!-- Diseases will be dynamically populated here -->
                </div>
                
                <!-- No Diseases Message -->
                <div id="no-diseases-message" style="text-align: center; padding: 20px; color: #666; font-style: italic; display: none;">
                    No diseases currently affecting this character.
                </div>
                
                <!-- Active Symptoms Summary -->
                <div class="symptom-effects-summary" id="symptom-effects-summary" style="display: none; padding: 15px; background: #fff4e0; border: 2px solid #ff8c00; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="color: #8b4513; margin: 0 0 8px 0; font-size: 14px;">ðŸ“Š Active Symptom Effects</h4>
                    <div id="symptom-effects-text" style="color: #8b4513; font-size: 13px; font-weight: bold;"></div>
                </div>
                
                <!-- Test Reminders -->
                <div class="disease-reminders" style="margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; margin: 0 0 10px 0; font-size: 14px;">Upcoming Tests & Reminders</h4>
                    <textarea id="test-reminders" rows="3" placeholder="Endurance tests needed, treatment schedules, recovery milestones..." style="width: 100%; padding: 10px; border: 1px solid #8b7355; font-family: 'Georgia', serif; resize: vertical; background: white;"></textarea>
                </div>
                
                <!-- Cross-Reference Warnings -->
                <div class="status-interactions" id="status-interactions" style="display:none; padding: 15px; background: #ffe4e6; border: 2px solid #c41e3a; border-radius: 5px;">
                    <h5 style="color: #8b0000; margin: 0 0 8px 0; font-size: 14px;">âš ï¸ Status Effect Interactions</h5>
                    <div class="interaction-warnings" id="interaction-warnings" style="color: #8b0000; font-size: 13px;"></div>
                </div>

                <!-- Add Disease Modal -->
                <div id="add-disease-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 10px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-top: 0; color: #3e2f1f; text-align: center;">Add Disease</h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Select Disease:</label>
                            <select id="disease-select" style="width: 100%; padding: 8px; font-size: 14px;" onchange="window.showDiseaseDetails()">
                                <option value="">-- Choose a disease --</option>
                            </select>
                        </div>
                        
                        <div id="disease-details" style="margin-bottom: 20px; display: none; padding: 15px; background: #f8f6f0; border-radius: 5px;">
                            <div id="disease-info"></div>
                            <div id="disease-symptoms" style="margin-top: 10px;"></div>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Contract Date:</label>
                            <input type="date" id="disease-contract-date" style="width: 100%; padding: 5px;">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">Notes:</label>
                            <textarea id="disease-notes-input" rows="3" placeholder="Additional notes about contraction, symptoms, treatment..." style="width: 100%; padding: 8px; resize: vertical;"></textarea>
                        </div>
                        
                        <div style="text-align: center;">
                            <button class="control-btn" onclick="window.confirmAddDisease()" style="margin-right: 10px; padding: 8px 16px;">Add Disease</button>
                            <button class="control-btn" onclick="window.closeAddDiseaseModal()" style="padding: 8px 16px;">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>


            </div> <!-- End Tab 3 -->

            <!-- Tab 4: Session Notes -->
            <div id="session-notes-tab" class="tab-content">
                
                <!-- Session Notes Header -->
                <div class="section" style="margin-bottom: 20px;">
                    <div class="section-title">Session Notes</div>
                    
                    <!-- Session Management Controls -->
                    <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                        <button class="control-btn" onclick="createNewSession()" style="padding: 8px 16px; font-size: 12px;">ðŸ“ New Session</button>
                        <button class="control-btn" onclick="showSessionList()" style="padding: 8px 16px; font-size: 12px;">ðŸ“‹ View All Sessions</button>
                        <button class="control-btn" onclick="exportCurrentSession()" style="padding: 8px 16px; font-size: 12px;">ðŸ“„ Export Current</button>
                        <button class="control-btn" onclick="exportAllSessions()" style="padding: 8px 16px; font-size: 12px;">ðŸ“š Export All</button>
                        <button class="google-drive-btn export" id="export-session-notes-btn" onclick="exportSessionToGoogleDocs()" disabled style="padding: 8px 16px; font-size: 12px;">ðŸ“ Export to Google Docs</button>
                    </div>
                    
                    <!-- Session Metadata -->
                    <div id="session-metadata" style="background: #f9f7f1; padding: 15px; border-radius: 5px; margin-bottom: 15px; border: 2px solid #e8dfd0;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 10px;">
                            <div>
                                <label style="font-size: 11px; color: #3e2f1f; font-weight: bold; display: block; margin-bottom: 3px;">Session Number</label>
                                <input type="number" id="session-number" style="width: 100%; padding: 5px; border: 1px solid #8b7355; font-family: Georgia, serif;" min="1">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #3e2f1f; font-weight: bold; display: block; margin-bottom: 3px;">Session Date</label>
                                <input type="date" id="session-date" style="width: 100%; padding: 5px; border: 1px solid #8b7355; font-family: Georgia, serif;">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #3e2f1f; font-weight: bold; display: block; margin-bottom: 3px;">GM Name</label>
                                <input type="text" id="gm-name" style="width: 100%; padding: 5px; border: 1px solid #8b7355; font-family: Georgia, serif;" placeholder="Game Master">
                            </div>
                            <div>
                                <label style="font-size: 11px; color: #3e2f1f; font-weight: bold; display: block; margin-bottom: 3px;">Campaign Name</label>
                                <input type="text" id="campaign-name" style="width: 100%; padding: 5px; border: 1px solid #8b7355; font-family: Georgia, serif;" placeholder="Campaign">
                            </div>
                        </div>
                        <div>
                            <label style="font-size: 11px; color: #3e2f1f; font-weight: bold; display: block; margin-bottom: 3px;">Location/Setting</label>
                            <input type="text" id="session-location" style="width: 100%; padding: 5px; border: 1px solid #8b7355; font-family: Georgia, serif;" placeholder="Current location in the campaign">
                        </div>
                    </div>
                    
                    <!-- Current Session Info -->
                    <div id="current-session-info" style="background: #e8f4fd; padding: 10px; border-radius: 5px; margin-bottom: 15px; border: 2px solid #b8d4ea;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-weight: bold; color: #3e2f1f;">Current Session: <span id="current-session-title">No session selected</span></span>
                            <div>
                                <span style="font-size: 11px; color: #666;">Auto-save: </span>
                                <span id="auto-save-status" style="font-size: 11px; color: #28a745;">âœ“ Saved</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Rich Text Editor Toolbar -->
                    <div id="editor-toolbar" style="background: #f5f5f0; padding: 8px; border: 1px solid #8b7355; border-bottom: none; display: flex; gap: 5px; flex-wrap: wrap;">
                        <button type="button" onclick="formatText('bold')" style="padding: 5px 8px; border: 1px solid #8b7355; background: white; cursor: pointer; font-weight: bold;" title="Bold">B</button>
                        <button type="button" onclick="formatText('italic')" style="padding: 5px 8px; border: 1px solid #8b7355; background: white; cursor: pointer; font-style: italic;" title="Italic">I</button>
                        <button type="button" onclick="formatText('underline')" style="padding: 5px 8px; border: 1px solid #8b7355; background: white; cursor: pointer; text-decoration: underline;" title="Underline">U</button>
                        <span style="border-left: 1px solid #8b7355; margin: 0 5px;"></span>
                        <button type="button" onclick="formatText('insertUnorderedList')" style="padding: 5px 8px; border: 1px solid #8b7355; background: white; cursor: pointer;" title="Bullet List">â€¢ List</button>
                        <button type="button" onclick="formatText('insertOrderedList')" style="padding: 5px 8px; border: 1px solid #8b7355; background: white; cursor: pointer;" title="Numbered List">1. List</button>
                        <span style="border-left: 1px solid #8b7355; margin: 0 5px;"></span>
                        <select onchange="formatHeading(this.value)" style="padding: 4px; border: 1px solid #8b7355; background: white; font-family: Georgia, serif;">
                            <option value="">Normal</option>
                            <option value="h1">Heading 1</option>
                            <option value="h2">Heading 2</option>
                            <option value="h3">Heading 3</option>
                        </select>
                        <span style="border-left: 1px solid #8b7355; margin: 0 5px;"></span>
                        <!-- WFRP Templates -->
                        <select onchange="insertTemplate(this.value)" style="padding: 4px; border: 1px solid #8b7355; background: white; font-family: Georgia, serif;">
                            <option value="">Insert Template</option>
                            <option value="combat">Combat Encounter</option>
                            <option value="npc">NPC Interaction</option>
                            <option value="skill-test">Skill Test</option>
                            <option value="treasure">Treasure/Reward</option>
                            <option value="session-start">Session Start</option>
                            <option value="session-end">Session End</option>
                        </select>
                    </div>
                    
                    <!-- Rich Text Editor -->
                    <div id="session-editor" 
                         contenteditable="true" 
                         style="min-height: 400px; padding: 15px; border: 1px solid #8b7355; background: white; font-family: Georgia, serif; font-size: 14px; line-height: 1.6; overflow-y: auto;"
                         oninput="onEditorInput()"
                         placeholder="Start writing your session notes here...">
                    </div>
                    
                    <!-- Word Count -->
                    <div style="text-align: right; margin-top: 5px; font-size: 11px; color: #666;">
                        Word count: <span id="word-count">0</span> words
                    </div>
                </div>
                
            </div> <!-- End Tab 4 -->
        </div>
    </div>

    <!-- Session List Modal -->
    <div id="session-list-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 600px; max-width: 800px; max-height: 80vh; overflow-y: auto; border-radius: 10px;">
            <h3 style="color: #3e2f1f; margin-bottom: 15px;">Session List</h3>
            
            <div id="session-list-content" style="margin-bottom: 20px;">
                <!-- Session list will be populated here -->
            </div>
            
            <div style="text-align: right;">
                <button onclick="closeSessionList()" class="control-btn" style="padding: 8px 16px; background: #8b0000; color: white;">Close</button>
            </div>
        </div>
    </div>

    <!-- XP History Modal -->
    <div id="xp-history-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 700px; max-width: 900px; max-height: 80vh; overflow-y: auto; border-radius: 10px;">
            <h3 style="color: #3e2f1f; margin-bottom: 15px;">Experience Points History</h3>
            
            <!-- XP Summary -->
            <div style="background: #f9f7f1; padding: 15px; border-radius: 5px; margin-bottom: 20px; border: 2px solid #e8dfd0;">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                    <div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Total Earned</div>
                        <div style="font-size: 16px; font-weight: bold; color: #3e2f1f;" id="xp-history-total">0</div>
                    </div>
                    <div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Total Spent</div>
                        <div style="font-size: 16px; font-weight: bold; color: #8b0000;" id="xp-history-spent">0</div>
                    </div>
                    <div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Current Available</div>
                        <div style="font-size: 16px; font-weight: bold; color: #28a745;" id="xp-history-current">0</div>
                    </div>
                </div>
            </div>
            
            <!-- XP Log Entries -->
            <div style="margin-bottom: 20px;">
                <h4 style="color: #3e2f1f; margin-bottom: 10px;">XP Log</h4>
                <div id="xp-log-content" style="max-height: 400px; overflow-y: auto;">
                    <!-- XP log entries will be populated here -->
                </div>
            </div>
            
            <!-- Controls -->
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <button onclick="clearXPHistory()" class="control-btn" style="padding: 8px 16px; background: #d44; color: white;">Clear All History</button>
                <button onclick="closeXPHistory()" class="control-btn" style="padding: 8px 16px; background: #8b0000; color: white;">Close</button>
            </div>
        </div>
    </div>

    <!-- Character Setup Wizard Modal -->
    <div id="character-setup-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 700px; max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2 style="color: #3e2f1f; margin-bottom: 20px; text-align: center;">Character Creation Wizard</h2>
            
            <!-- Warning Section -->
            <div id="setup-warning" style="background: #ffe6e6; border: 2px solid #cc0000; padding: 15px; margin-bottom: 20px; border-radius: 5px;">
                <h4 style="color: #cc0000; margin: 0 0 10px 0;">âš ï¸ Warning</h4>
                <p style="margin: 0; color: #333;">This will clear all current character data and start fresh. This action cannot be undone.</p>
                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
                    <button onclick="confirmDataReset()" style="padding: 8px 16px; background: #cc0000; color: white; border: none; border-radius: 3px; cursor: pointer;">Continue & Clear Data</button>
                    <button onclick="closeSetupWizard()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
                </div>
            </div>
            
            <!-- Wizard Steps -->
            <div id="setup-steps" style="display: none;">
                <!-- Progress indicator -->
                <div style="display: flex; justify-content: center; margin-bottom: 30px; gap: 10px;">
                    <div class="wizard-step" id="setup-step-indicator-0">0</div>
                    <div class="wizard-step" id="setup-step-indicator-1">1</div>
                    <div class="wizard-step" id="setup-step-indicator-2">2</div>
                    <div class="wizard-step" id="setup-step-indicator-3">3</div>
                    <div class="wizard-step" id="setup-step-indicator-4">4</div>
                    <div class="wizard-step" id="setup-step-indicator-5">5</div>
                    <div class="wizard-step" id="setup-step-indicator-6">6</div>
                </div>
                
                <!-- Step 0: Species Selection -->
                <div id="setup-wizard-step-0" class="wizard-content">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 0: Choose Your Species</h3>
                    <p style="margin-bottom: 15px; color: #666;">Select your character's species to begin the creation process.</p>
                    <div style="margin: 20px 0;">
                        <select id="setup-species-select" onchange="handleSetupSpeciesSelection()" style="padding: 10px; font-size: 16px; width: 100%; border: 1px solid #8b7355;">
                            <option value="">Select Species</option>
                            <option value="Human">Human</option>
                            <option value="Dwarf">Dwarf</option>
                            <option value="Halfling">Halfling</option>
                            <option value="High Elf">High Elf</option>
                            <option value="Wood Elf">Wood Elf</option>
                        </select>
                    </div>
                    <div id="setup-species-info" style="display: none; background: #f5f2e8; padding: 15px; border-radius: 5px; margin-top: 20px;">
                        <!-- Species info will be populated dynamically -->
                    </div>
                </div>

                <!-- Step 1: Species Characteristics -->
                <div id="setup-wizard-step-1" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 1: Species Characteristics</h3>
                    <div id="setup-species-details" style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                        <!-- Species info will be populated dynamically -->
                    </div>
                    
                    <div id="setup-characteristics-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                        <!-- Characteristics will be populated dynamically -->
                    </div>
                </div>
                
                <!-- Step 2: Skills Selection -->
                <div id="setup-wizard-step-2" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 2: Skills Selection</h3>
                    <div id="setup-skills-content">
                        <!-- Skills content will be populated dynamically -->
                    </div>
                </div>
                
                <!-- Step 3: Talents Selection -->
                <div id="setup-wizard-step-3" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 3: Talents Selection</h3>
                    <div id="setup-talents-content">
                        <!-- Talents content will be populated dynamically -->
                    </div>
                </div>

                <!-- Step 4: Class Selection -->
                <div id="setup-wizard-step-4" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 4: Class Selection</h3>
                    <div id="setup-class-content">
                        <!-- Class content will be populated dynamically -->
                    </div>
                </div>

                <!-- Step 5: Trappings -->
                <div id="setup-wizard-step-5" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 5: Class Trappings</h3>
                    <div id="setup-trappings-content">
                        <!-- Trappings content will be populated dynamically -->
                    </div>
                </div>

                <!-- Step 6: Career Selection -->
                <div id="setup-wizard-step-6" class="wizard-content" style="display: none;">
                    <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 6: Career Selection</h3>
                    <div id="setup-career-content">
                        <!-- Career content will be populated dynamically -->
                    </div>
                </div>
                
                <!-- Navigation buttons -->
                <div style="display: flex; justify-content: space-between; margin-top: 30px;">
                    <button id="setup-wizard-prev-btn" class="control-btn" onclick="previousSetupStep()" style="padding: 10px 20px;" disabled>â† Previous</button>
                    <button id="setup-wizard-next-btn" class="control-btn" onclick="nextSetupStep()" style="padding: 10px 20px;">Next â†’</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Google Drive Backup/Restore Modal -->
    <div id="backup-restore-modal" class="backup-modal">
        <div class="backup-modal-content">
            <h3 style="color: #3e2f1f; margin-bottom: 15px;">Restore Character from Google Drive</h3>
            
            <div style="margin-bottom: 15px;">
                <p style="color: #666; font-size: 12px; margin-bottom: 10px;">
                    Select a backup to restore. This will overwrite your current character data.
                </p>
            </div>

            <div id="backup-list" class="backup-list">
                <div style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                    Loading backups...
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
                <div>
                    <button onclick="refreshBackupList()" class="google-drive-btn" style="padding: 8px 16px;">
                        ðŸ”„ Refresh
                    </button>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="restoreSelectedBackup()" class="google-drive-btn restore" id="restore-selected-btn" disabled>
                        ðŸ“‚ Restore Selected
                    </button>
                    <button onclick="closeBackupRestoreModal()" class="control-btn" style="padding: 8px 16px; background: #8b0000; color: white;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Spell Modal -->
    <div id="add-spell-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 600px; max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Spell or Prayer</h3>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Source:</label>
                <select id="spell-source-input" style="width: 100%; padding: 5px;" onchange="window.toggleSpellSource()">
                    <option value="srd">Select from SRD</option>
                    <option value="custom">Custom Spell/Prayer</option>
                </select>
            </div>
            
            <!-- SRD Spell Selection -->
            <div id="srd-spell-section" style="display: none; margin-bottom: 15px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Filter by Category:</label>
                        <select id="srd-category-filter" style="width: 100%; padding: 5px;" onchange="window.filterSRDSpells()">
                            <option value="">All Categories</option>
                            <option value="petty">Petty Magic</option>
                            <option value="arcane">Arcane Spells</option>
                            <option value="winds">8 Winds of Magic</option>
                            <option value="blessings">Blessings (Divine Petty)</option>
                            <option value="divine">Miracles (Divine)</option>
                            <option value="witch">Witch Magic (Witchcraft & Hedge Craft)</option>
                            <option value="dark">Dark Magic</option>
                            <option value="chaos">Chaos Magic</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Filter by Lore:</label>
                        <select id="srd-lore-filter" style="width: 100%; padding: 5px;" onchange="window.filterSRDSpells()">
                            <option value="">All Lores</option>
                        </select>
                    </div>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Search:</label>
                    <input type="text" id="srd-spell-search" placeholder="Type to search by name..." style="width: 100%; padding: 5px;" oninput="window.filterSRDSpells()">
                </div>
                
                <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Select Spell: <span id="srd-spell-count" style="font-weight: normal; color: #666;"></span></label>
                <select id="srd-spell-select" size="8" style="width: 100%; padding: 5px;" onchange="window.showSRDSpellDetails()">
                </select>
                
                <div id="srd-spell-details" style="display: none; margin-top: 10px; padding: 10px; background: #e8dfd0; border: 1px solid #8b7355;">
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">Spell Details</h4>
                    <p><strong>Name:</strong> <span id="srd-detail-name"></span></p>
                    <p><strong>Lore:</strong> <span id="srd-detail-lore"></span></p>
                    <p><strong>CN:</strong> <span id="srd-detail-cn"></span></p>
                    <p><strong>Range:</strong> <span id="srd-detail-range"></span></p>
                    <p><strong>Target:</strong> <span id="srd-detail-target"></span></p>
                    <p><strong>Duration:</strong> <span id="srd-detail-duration"></span></p>
                    <p style="margin-top: 10px;"><strong>Effect:</strong></p>
                    <p id="srd-detail-effect" style="white-space: pre-wrap;"></p>
                </div>
            </div>
            
            <!-- Custom Spell Entry -->
            <div id="custom-spell-section">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Name:</label>
                        <input type="text" id="spell-name-input" style="width: 100%; padding: 5px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Lore/Type:</label>
                        <select id="spell-lore-input" style="width: 100%; padding: 5px;">
                        </select>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">CN:</label>
                        <input type="text" id="spell-cn-input" style="width: 100%; padding: 5px;" placeholder="6">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Range:</label>
                        <input type="text" id="spell-range-input" style="width: 100%; padding: 5px;" placeholder="Touch">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Target:</label>
                        <input type="text" id="spell-target-input" style="width: 100%; padding: 5px;" placeholder="1 Creature">
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Duration:</label>
                    <input type="text" id="spell-duration-input" style="width: 100%; padding: 5px;" placeholder="Instant">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Effect:</label>
                    <textarea id="spell-effect-input" style="width: 100%; padding: 5px; height: 100px; font-family: 'Georgia', serif;"></textarea>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Ingredients (optional):</label>
                    <input type="text" id="spell-ingredients-input" style="width: 100%; padding: 5px;" placeholder="Any special ingredients or material components">
                </div>
            </div>
            
            <!-- Memorised checkbox -->
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; color: #3e2f1f;">
                    <input type="checkbox" id="spell-memorised-input" style="margin-right: 5px;">
                    Currently Memorised/Prepared
                </label>
            </div>
            
            <div style="text-align: center;">
                <button class="control-btn" onclick="window.confirmAddSpell()" style="margin-right: 10px; padding: 8px 16px;">Add Spell</button>
                <button class="control-btn" onclick="window.closeAddSpellModal()" style="padding: 8px 16px;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Species Creation Wizard Modal -->
    <div id="species-wizard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 700px; max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2 style="color: #3e2f1f; margin-bottom: 20px; text-align: center;">Species Creation Wizard</h2>
            
            <!-- Progress indicator -->
            <div style="display: flex; justify-content: center; margin-bottom: 30px; gap: 10px;">
                <div class="wizard-step" id="step-indicator-1">1</div>
                <div class="wizard-step" id="step-indicator-2">2</div>
                <div class="wizard-step" id="step-indicator-3">3</div>
                <div class="wizard-step" id="step-indicator-4">4</div>
                <div class="wizard-step" id="step-indicator-5">5</div>
                <div class="wizard-step" id="step-indicator-6">6</div>
            </div>
            
            <!-- Step 1: Species Information and Characteristics -->
            <div id="wizard-step-1" class="wizard-content">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 1: Species Characteristics</h3>
                <div id="species-info" style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <!-- Species info will be populated dynamically -->
                </div>
                
                <h4 style="color: #3e2f1f; margin-bottom: 10px;">Enter Characteristics</h4>
                <p style="margin-bottom: 15px; color: #666;">Roll 2d10 for each characteristic and enter your dice result (2-20). The total will be calculated automatically.</p>
                
                <div id="characteristics-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-bottom: 20px;">
                    <!-- Characteristics will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 2: Wounds, Fate, and Resilience -->
            <div id="wizard-step-2" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 2: Wounds, Fate, and Resilience</h3>
                
                <div style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">Wounds Calculation</h4>
                    <p style="margin-bottom: 10px; color: #666;">Formula: <span id="wounds-formula">SB + (2 Ã— TB) + WPB</span></p>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <span>Calculated Wounds:</span>
                        <strong id="calculated-wounds" style="font-size: 18px; color: #3e2f1f;">0</strong>
                    </div>
                </div>
                
                <div style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">Fate and Resilience Distribution</h4>
                    <p style="margin-bottom: 15px; color: #666;">
                        Base Values: <span id="base-fate-resilience">Fate 0, Resilience 0</span><br>
                        You have <span id="extra-points-remaining">0</span> extra points to distribute between Fate and Resilience.
                    </p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div class="char-advance-group">
                            <label>Fate Points</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="base-fate">0</span>
                                <span>+</span>
                                <input type="number" id="extra-fate" min="0" max="5" value="0" style="width: 50px; text-align: center;" onchange="updateExtraPointsDistribution()">
                                <span>=</span>
                                <strong id="total-fate">0</strong>
                            </div>
                        </div>
                        <div class="char-advance-group">
                            <label>Resilience Points</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="base-resilience">0</span>
                                <span>+</span>
                                <input type="number" id="extra-resilience" min="0" max="5" value="0" style="width: 50px; text-align: center;" onchange="updateExtraPointsDistribution()">
                                <span>=</span>
                                <strong id="total-resilience">0</strong>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: #f5f2e8; padding: 15px; border-radius: 5px;">
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">Movement</h4>
                    <p>Movement: <strong id="species-movement">4</strong></p>
                </div>
            </div>
            
            <!-- Step 3: Skills Selection (5 advances) -->
            <div id="wizard-step-3" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 3: Skill Selection (5 Advances)</h3>
                <p style="margin-bottom: 15px; color: #666;">Select 3 skills from your species list to receive +5 advances each. Remaining: <span id="remaining-skill-points-1">3</span></p>
                
                <div id="species-skills-list-1" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <!-- Skills will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 4: Skills Selection (3 advances) -->
            <div id="wizard-step-4" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 4: Skill Selection (3 Advances)</h3>
                <p style="margin-bottom: 15px; color: #666;">Select 3 additional skills from your species list to receive +3 advances each. Remaining: <span id="remaining-skill-points-2">3</span></p>
                
                <div id="species-skills-list-2" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <!-- Skills will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 5: Talents Selection -->
            <div id="wizard-step-5" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 5: Talent Selection</h3>
                
                <div id="random-talents-section" style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">Fixed Species Talents (Automatic)</h4>
                    <div id="random-talents-list">
                        <!-- Fixed talents will be populated dynamically -->
                    </div>
                </div>
                
                <h4 style="color: #3e2f1f; margin-bottom: 10px;">Talent Choices</h4>
                <p style="margin-bottom: 15px; color: #666;">Make your talent selections below:</p>
                
                <div id="species-talents-list" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                    <!-- Talents will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 6: Confirmation -->
            <div id="wizard-step-6" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 6: Confirmation</h3>
                <p style="margin-bottom: 20px; color: #666;">Review your character creation choices below. Click "Apply to Character" to finalize your character.</p>
                
                <div id="creation-summary" style="background: #f5f2e8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <!-- Summary will be populated dynamically -->
                </div>
            </div>
            
            <!-- Navigation buttons -->
            <div style="display: flex; justify-content: space-between; margin-top: 30px;">
                <button id="wizard-prev-btn" class="control-btn" onclick="previousWizardStep()" style="padding: 10px 20px;" disabled>â† Previous</button>
                <button id="wizard-next-btn" class="control-btn" onclick="nextWizardStep()" style="padding: 10px 20px;">Next â†’</button>
                <button id="wizard-apply-btn" class="control-btn" onclick="applySpeciesCreation()" style="padding: 10px 20px; display: none;">Apply to Character</button>
                <button id="wizard-cancel-btn" class="control-btn" onclick="closeSpeciesWizard()" style="padding: 10px 20px; background: #8b0000; color: white;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Class Trappings Wizard -->
    <div id="class-wizard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; min-width: 700px; max-width: 900px; max-height: 80vh; overflow-y: auto; border-radius: 10px;">
            <h2 style="color: #3e2f1f; margin-bottom: 20px; text-align: center;">Class Trappings Wizard</h2>
            
            <!-- Progress Indicator -->
            <div style="display: flex; justify-content: center; margin-bottom: 30px;">
                <div id="class-step-indicator-1" class="wizard-step active" style="margin: 0 10px;">1. Overview</div>
                <div id="class-step-indicator-2" class="wizard-step" style="margin: 0 10px;">2. Customisation</div>
                <div id="class-step-indicator-3" class="wizard-step" style="margin: 0 10px;">3. Confirmation</div>
            </div>
            
            <!-- Step 1: Overview -->
            <div id="class-wizard-step-1" class="wizard-content">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 1: Class Overview</h3>
                <div id="class-overview">
                    <!-- Class info will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 2: Customisation -->
            <div id="class-wizard-step-2" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 2: Customisation</h3>
                <div id="class-customisation">
                    <!-- Customisation options will be populated dynamically -->
                </div>
            </div>
            
            <!-- Step 3: Confirmation -->
            <div id="class-wizard-step-3" class="wizard-content" style="display: none;">
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Step 3: Confirmation</h3>
                <div id="class-confirmation">
                    <!-- Confirmation summary will be populated dynamically -->
                </div>
            </div>
            
            <!-- Navigation -->
            <div style="display: flex; justify-content: space-between; margin-top: 30px;">
                <button id="class-wizard-prev-btn" class="control-btn" onclick="previousClassWizardStep()" style="padding: 10px 20px;" disabled>â† Previous</button>
                <button id="class-wizard-next-btn" class="control-btn" onclick="nextClassWizardStep()" style="padding: 10px 20px;">Next â†’</button>
                <button id="class-wizard-apply-btn" class="control-btn" onclick="applyClassTrappings()" style="padding: 10px 20px; display: none;">Add to Character Sheet</button>
                <button id="class-wizard-cancel-btn" class="control-btn" onclick="closeClassWizard()" style="padding: 10px 20px; background: #8b0000; color: white;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <button class="control-btn" onclick="saveCharacter()">ðŸ’¾ Save</button>
        <button class="control-btn" onclick="loadCharacter()">ðŸ“‚ Load</button>
    </div>

    <script>
        // =============== GOOGLE DRIVE INTEGRATION ===============
        
        // Google API Configuration
        const CLIENT_ID = '637522870817-2ld474hirluo4psaennlrb7gma6tng70.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyBju-TVMXLsUql-i8-pDfwdRUIe0mC3WgE';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const DOCS_DISCOVERY_DOC = 'https://docs.googleapis.com/$discovery/rest?version=v1';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/documents';

        let gapi;
        let tokenClient;
        let isSignedIn = false;
        let wfrpFolderId = null;
        let selectedBackupId = null;

        // Initialize Google APIs when page loads
        function initializeGoogleAPIs() {
            if (typeof window.gapi !== 'undefined') {
                gapi = window.gapi;
                gapi.load('client', initializeGapiClient);
            }

            if (typeof window.google !== 'undefined') {
                tokenClient = window.google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: (response) => {
                        if (response.error) {
                            console.error('OAuth error:', response.error);
                            showNotification('Failed to sign in to Google Drive', 'error');
                            return;
                        }
                        isSignedIn = true;
                        updateGoogleDriveUI();
                        showNotification('Successfully connected to Google Drive!', 'success');
                    },
                });
            }
        }

        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: [DISCOVERY_DOC, DOCS_DISCOVERY_DOC],
                });
                console.log('Google API client initialized');
            } catch (error) {
                console.error('Error initializing Google API client:', error);
            }
        }

        // Sign in to Google Drive
        function signInToGoogle() {
            if (!tokenClient) {
                showNotification('Google APIs not loaded. Please refresh the page.', 'error');
                return;
            }

            // Check if user is already signed in
            if (gapi.client.getToken()) {
                isSignedIn = true;
                updateGoogleDriveUI();
                showNotification('Already connected to Google Drive', 'success');
                return;
            }

            // Request access token
            tokenClient.requestAccessToken();
        }

        // Sign out from Google Drive
        function signOutFromGoogle() {
            const token = gapi.client.getToken();
            if (token) {
                window.google.accounts.oauth2.revoke(token.access_token, () => {
                    gapi.client.setToken('');
                    isSignedIn = false;
                    updateGoogleDriveUI();
                    showNotification('Disconnected from Google Drive', 'info');
                });
            }
        }

        // Update UI based on Google Drive connection status
        function updateGoogleDriveUI() {
            const statusElement = document.getElementById('google-drive-status');
            const statusText = document.getElementById('google-drive-status-text');
            const signInBtn = document.getElementById('google-signin-btn');
            const signOutBtn = document.getElementById('google-signout-btn');
            const backupBtn = document.getElementById('backup-character-btn');
            const restoreBtn = document.getElementById('restore-character-btn');
            const exportBtn = document.getElementById('export-session-notes-btn');

            // Check if offline
            const offline = !isOnline();

            if (isSignedIn && !offline) {
                statusElement.classList.add('connected');
                statusText.textContent = 'Connected to Google Drive';
                signInBtn.style.display = 'none';
                signOutBtn.style.display = 'flex';
                backupBtn.disabled = false;
                restoreBtn.disabled = false;
                exportBtn.disabled = false;
            } else if (isSignedIn && offline) {
                statusElement.classList.remove('connected');
                statusText.textContent = 'Connected to Google Drive (offline)';
                signInBtn.style.display = 'none';
                signOutBtn.style.display = 'flex';
                backupBtn.disabled = true;
                restoreBtn.disabled = true;
                exportBtn.disabled = true;
            } else if (offline) {
                statusElement.classList.remove('connected');
                statusText.textContent = 'Offline - Google Drive unavailable';
                signInBtn.style.display = 'flex';
                signOutBtn.style.display = 'none';
                backupBtn.disabled = true;
                restoreBtn.disabled = true;
                exportBtn.disabled = true;
                signInBtn.disabled = true;
            } else {
                statusElement.classList.remove('connected');
                statusText.textContent = 'Not connected to Google Drive';
                signInBtn.style.display = 'flex';
                signOutBtn.style.display = 'none';
                backupBtn.disabled = true;
                restoreBtn.disabled = true;
                exportBtn.disabled = true;
                signInBtn.disabled = false;
            }
        }

        // Create or find WFRP Characters folder
        async function ensureWFRPFolder() {
            if (wfrpFolderId) return wfrpFolderId;

            try {
                // Search for existing WFRP Characters folder
                const response = await gapi.client.drive.files.list({
                    q: "name='WFRP Characters' and mimeType='application/vnd.google-apps.folder' and trashed=false",
                    fields: 'files(id, name)'
                });

                if (response.result.files.length > 0) {
                    wfrpFolderId = response.result.files[0].id;
                    console.log('Found existing WFRP Characters folder:', wfrpFolderId);
                } else {
                    // Create new folder
                    const createResponse = await gapi.client.drive.files.create({
                        resource: {
                            name: 'WFRP Characters',
                            mimeType: 'application/vnd.google-apps.folder'
                        },
                        fields: 'id'
                    });
                    wfrpFolderId = createResponse.result.id;
                    console.log('Created new WFRP Characters folder:', wfrpFolderId);
                }

                return wfrpFolderId;
            } catch (error) {
                console.error('Error ensuring WFRP folder:', error);
                throw error;
            }
        }

        // OLD backup function removed to prevent infinite recursion

        // Gather character data for backup (using existing save logic)
        function gatherCharacterDataForBackup() {
            // Use the same logic as the existing saveCharacter function
            const characterData = {
                name: document.getElementById('character-name').value,
                species: document.getElementById('species').value,
                class: document.getElementById('class').value,
                career: document.getElementById('career').value,
                characteristics: {},
                wounds: {
                    current: document.getElementById('wounds-current').value,
                    max: document.getElementById('wounds-max').value
                },
                movement: document.getElementById('movement').value,
                fate: document.getElementById('fate').value,
                fortune: document.getElementById('fortune-current').value,
                resilience: document.getElementById('resilience').value,
                resolve: document.getElementById('resolve-current').value,
                motivation: document.getElementById('motivation').value,
                experience: {
                    total: document.getElementById('xp-total').value,
                    spent: document.getElementById('xp-spent').value
                },
                status: {
                    tier: document.getElementById('status-tier').value,
                    standing: document.getElementById('status-standing').value
                },
                sinPoints: document.getElementById('sin-points').value,
                notes: document.getElementById('quick-notes').value,
                skills: typeof characterSkills !== 'undefined' ? characterSkills : [],
                addedSkills: typeof addedSkills !== 'undefined' ? addedSkills : [],
                weapons: typeof weapons !== 'undefined' ? weapons : [],
                armour: typeof armour !== 'undefined' ? armour : [],
                trappings: typeof trappings !== 'undefined' ? trappings : [],
                consumables: typeof consumables !== 'undefined' ? consumables : [],
                talents: typeof talents !== 'undefined' ? talents : [],
                activeConditions: typeof activeConditions !== 'undefined' ? activeConditions : [],
                criticalWounds: typeof criticalWounds !== 'undefined' ? criticalWounds : [],
                spells: typeof spells !== 'undefined' ? spells : [],
                corruptionPoints: document.getElementById('corruption-points').value,
                mutations: typeof mutations !== 'undefined' ? mutations : [],
                diseaseTracking: {
                    activeDiseases: typeof character !== 'undefined' && character.diseaseTracking ? character.diseaseTracking.activeDiseases || [] : [],
                    testReminders: document.getElementById('test-reminders').value || ''
                },
                money: {
                    gold: document.getElementById('money-gold').value,
                    silver: document.getElementById('money-silver').value,
                    brass: document.getElementById('money-brass').value
                },
                xpLog: typeof xpLog !== 'undefined' ? xpLog : [],
                sessionNotes: typeof sessionNotes !== 'undefined' ? sessionNotes : [],
                backupTimestamp: new Date().toISOString(),
                backupVersion: '1.0'
            };

            // Save characteristics
            if (typeof characteristics !== 'undefined') {
                characteristics.forEach(char => {
                    const initialElement = document.getElementById(`${char}-initial`);
                    const advancesElement = document.getElementById(`${char}-advances`);
                    if (initialElement && advancesElement) {
                        characterData.characteristics[char] = {
                            initial: initialElement.value,
                            advances: advancesElement.value
                        };
                    }
                });
            }

            return characterData;
        }

        // Show notification to user
        function showNotification(message, type = 'info') {
            // Create notification element if it doesn't exist
            let notification = document.getElementById('google-drive-notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'google-drive-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 5px;
                    color: white;
                    font-family: Georgia, serif;
                    font-size: 14px;
                    z-index: 10000;
                    max-width: 300px;
                    word-wrap: break-word;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    transform: translateX(400px);
                    transition: transform 0.3s ease;
                `;
                document.body.appendChild(notification);
            }

            // Set background color based on type
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                info: '#17a2b8',
                warning: '#ffc107'
            };
            notification.style.backgroundColor = colors[type] || colors.info;
            notification.textContent = message;

            // Show notification
            notification.style.transform = 'translateX(0)';

            // Hide after 4 seconds
            setTimeout(() => {
                notification.style.transform = 'translateX(400px)';
            }, 4000);
        }

        // =============== RESTORE FUNCTIONALITY ===============
        
        // Open restore dialog
        async function openRestoreDialog() {
            if (!isSignedIn) {
                showNotification('Please connect to Google Drive first', 'error');
                return;
            }

            const modal = document.getElementById('backup-restore-modal');
            modal.style.display = 'block';
            await loadBackupList();
        }

        // Close backup/restore modal
        function closeBackupRestoreModal() {
            const modal = document.getElementById('backup-restore-modal');
            modal.style.display = 'none';
            selectedBackupId = null;
            updateRestoreButton();
        }

        // Load list of available backups
        async function loadBackupList() {
            const backupList = document.getElementById('backup-list');
            
            try {
                backupList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666; font-style: italic;">Loading backups...</div>';

                // Ensure WFRP folder exists
                await ensureWFRPFolder();

                // Search for backup files
                const response = await gapi.client.drive.files.list({
                    q: `'${wfrpFolderId}' in parents and name contains 'backup' and name contains '.json' and trashed=false`,
                    fields: 'files(id, name, description, modifiedTime, size)',
                    orderBy: 'modifiedTime desc'
                });

                const files = response.result.files;

                if (files.length === 0) {
                    backupList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666; font-style: italic;">No backups found. Create a backup first!</div>';
                    return;
                }

                // Generate backup list HTML
                let listHTML = '';
                files.forEach(file => {
                    const modifiedDate = new Date(file.modifiedTime).toLocaleDateString();
                    const modifiedTime = new Date(file.modifiedTime).toLocaleTimeString();
                    const fileSizeKB = Math.round(file.size / 1024);
                    
                    // Extract character name from filename
                    const characterName = file.name.split('_backup_')[0].replace(/_/g, ' ');
                    
                    listHTML += `
                        <div class="backup-item" onclick="selectBackup('${file.id}', this)">
                            <div class="backup-item-name">${characterName}</div>
                            <div class="backup-item-details">
                                ${modifiedDate} at ${modifiedTime} â€¢ ${fileSizeKB} KB
                                <br>File: ${file.name}
                            </div>
                        </div>
                    `;
                });

                backupList.innerHTML = listHTML;

            } catch (error) {
                console.error('Error loading backup list:', error);
                backupList.innerHTML = '<div style="text-align: center; padding: 20px; color: #dc3545;">Error loading backups: ' + error.message + '</div>';
            }
        }

        // Refresh backup list
        async function refreshBackupList() {
            await loadBackupList();
            showNotification('Backup list refreshed', 'info');
        }

        // Select a backup file
        function selectBackup(fileId, element) {
            // Remove selection from all items
            const allItems = document.querySelectorAll('.backup-item');
            allItems.forEach(item => item.classList.remove('selected'));

            // Select current item
            element.classList.add('selected');
            selectedBackupId = fileId;
            updateRestoreButton();
        }

        // Update restore button state
        function updateRestoreButton() {
            const restoreBtn = document.getElementById('restore-selected-btn');
            restoreBtn.disabled = !selectedBackupId;
        }

        // OLD restore function removed to prevent infinite recursion

        // Restore character data from backup
        async function restoreCharacterData(characterData) {
            // Load basic info
            document.getElementById('character-name').value = characterData.name || '';
            document.getElementById('species').value = characterData.species || '';
            document.getElementById('class').value = characterData.class || '';
            if (characterData.player) document.getElementById('player').value = characterData.player;
            
            // Restore career data
            if (characterData.careerData) {
                // Wait for career data to be loaded, then restore career selection
                if (careersData && characterData.careerData.careerName) {
                    const career = careersData.careers.find(c => c.name === characterData.careerData.careerName);
                    if (career) {
                        document.getElementById('career-select').value = characterData.careerData.careerName;
                        document.getElementById('tier-select').value = characterData.careerData.tier || 1;
                        currentTier = characterData.careerData.tier || 1;
                        selectCareer(career);
                    }
                }
            } else if (characterData.career) {
                // Fallback for old save format
                document.getElementById('career-select').value = characterData.career;
            }
            
            // Load characteristics
            if (characterData.characteristics && typeof characteristics !== 'undefined') {
                characteristics.forEach(char => {
                    if (characterData.characteristics[char]) {
                        const initialElement = document.getElementById(`${char}-initial`);
                        const advancesElement = document.getElementById(`${char}-advances`);
                        if (initialElement && advancesElement) {
                            initialElement.value = characterData.characteristics[char].initial || '';
                            advancesElement.value = characterData.characteristics[char].advances || '';
                            // Trigger update
                            initialElement.dispatchEvent(new Event('input'));
                        }
                    }
                });
            }
            
            // Load other stats
            if (characterData.wounds) {
                document.getElementById('wounds-current').value = characterData.wounds.current || '';
                document.getElementById('wounds-max').value = characterData.wounds.max || '';
            }
            
            document.getElementById('movement').value = characterData.movement || '';
            const movement = document.getElementById('movement');
            if (movement) movement.dispatchEvent(new Event('input'));
            
            if (characterData.experience) {
                document.getElementById('xp-total').value = characterData.experience.total || '0';
                document.getElementById('xp-spent').value = characterData.experience.spent || '0';
                if (typeof window.updateXPDisplay === 'function') {
                    window.updateXPDisplay();
                }
            }
            
            document.getElementById('fate').value = characterData.fate || '';
            document.getElementById('fortune-current').value = characterData.fortune || '';
            document.getElementById('resilience').value = characterData.resilience || '';
            document.getElementById('resolve-current').value = characterData.resolve || '';
            document.getElementById('motivation').value = characterData.motivation || '';
            
            if (characterData.status) {
                document.getElementById('status-tier').value = characterData.status.tier || 'Brass';
                document.getElementById('status-standing').value = characterData.status.standing || '';
            }
            
            document.getElementById('sin-points').value = characterData.sinPoints || '';
            document.getElementById('quick-notes').value = characterData.notes || '';
            
            // Restore complex data structures
            if (characterData.skills && typeof characterSkills !== 'undefined') {
                window.characterSkills = characterData.skills;
            }
            if (characterData.addedSkills && typeof addedSkills !== 'undefined') {
                window.addedSkills = characterData.addedSkills;
            }
            if (characterData.weapons && typeof weapons !== 'undefined') {
                window.weapons = characterData.weapons;
            }
            if (characterData.armour && typeof armour !== 'undefined') {
                window.armour = characterData.armour;
            }
            if (characterData.trappings && typeof trappings !== 'undefined') {
                window.trappings = characterData.trappings;
            }
            if (characterData.consumables && typeof consumables !== 'undefined') {
                window.consumables = characterData.consumables;
            }
            if (characterData.talents && typeof talents !== 'undefined') {
                window.talents = characterData.talents;
            }
            if (characterData.activeConditions && typeof activeConditions !== 'undefined') {
                window.activeConditions = characterData.activeConditions;
            }
            if (characterData.criticalWounds && typeof criticalWounds !== 'undefined') {
                window.criticalWounds = characterData.criticalWounds;
            }
            if (characterData.spells && typeof spells !== 'undefined') {
                window.spells = characterData.spells;
            }
            if (characterData.mutations && typeof mutations !== 'undefined') {
                window.mutations = characterData.mutations;
            }
            
            // Restore XP log
            if (characterData.xpLog && typeof xpLog !== 'undefined') {
                window.xpLog = characterData.xpLog;
                if (typeof saveXPLog === 'function') {
                    saveXPLog();
                }
            }
            
            // Restore session notes
            if (characterData.sessionNotes && typeof sessionNotes !== 'undefined') {
                window.sessionNotes = characterData.sessionNotes;
                if (typeof saveSessionNotes === 'function') {
                    saveSessionNotes();
                }
            }
            
            // Restore money
            if (characterData.money) {
                document.getElementById('money-gold').value = characterData.money.gold || '';
                document.getElementById('money-silver').value = characterData.money.silver || '';
                document.getElementById('money-brass').value = characterData.money.brass || '';
            }
            
            // Restore disease tracking
            if (characterData.diseaseTracking) {
                if (typeof character !== 'undefined' && character.diseaseTracking) {
                    character.diseaseTracking.activeDiseases = characterData.diseaseTracking.activeDiseases || [];
                }
                document.getElementById('test-reminders').value = characterData.diseaseTracking.testReminders || '';
            }
            
            document.getElementById('corruption-points').value = characterData.corruptionPoints || '';
            
            // Update displays
            try {
                if (typeof window.updateFateFortuneResilienceResolveDisplay === 'function') {
                    window.updateFateFortuneResilienceResolveDisplay();
                }
                if (typeof displaySkills === 'function') {
                    displaySkills();
                }
                if (typeof displayTalents === 'function') {
                    displayTalents();
                }
                if (typeof window.updateConditionDisplay === 'function') {
                    window.updateConditionDisplay();
                }
                if (typeof window.displayCriticalWounds === 'function') {
                    window.displayCriticalWounds();
                }
                if (typeof displaySpells === 'function') {
                    displaySpells();
                }
                if (typeof displayWeapons === 'function') {
                    displayWeapons();
                }
                if (typeof displayArmour === 'function') {
                    displayArmour();
                }
                if (typeof displayTrappings === 'function') {
                    displayTrappings();
                }
                if (typeof displayConsumables === 'function') {
                    displayConsumables();
                }
                if (typeof window.displayMutations === 'function') {
                    window.displayMutations();
                }
                if (typeof updateEncumbrance === 'function') {
                    setTimeout(() => {
                        updateEncumbrance();
                    }, 100);
                }
            } catch (error) {
                console.error('Error updating displays after restore:', error);
            }
        }

        // =============== GOOGLE DOCS EXPORT FUNCTIONALITY ===============
        
        // OLD export function removed to prevent infinite recursion

        // Format session data for Google Docs
        async function formatSessionForGoogleDocs(session, characterName) {
            const requests = [];
            let insertIndex = 1;

            // Helper function to add text with formatting
            function addText(text, formatting = {}) {
                const request = {
                    insertText: {
                        location: { index: insertIndex },
                        text: text
                    }
                };
                requests.push(request);

                if (Object.keys(formatting).length > 0) {
                    const formatRequest = {
                        updateTextStyle: {
                            range: {
                                startIndex: insertIndex,
                                endIndex: insertIndex + text.length
                            },
                            textStyle: formatting,
                            fields: Object.keys(formatting).join(',')
                        }
                    };
                    requests.push(formatRequest);
                }

                insertIndex += text.length;
            }

            // Helper function to add a line break
            function addLineBreak() {
                addText('\n');
            }

            // Document title
            addText(`${characterName} - Session ${session.number} Notes\n`, {
                bold: true,
                fontSize: { magnitude: 16, unit: 'PT' }
            });
            addLineBreak();

            // Session metadata
            addText('Session Information\n', {
                bold: true,
                fontSize: { magnitude: 14, unit: 'PT' }
            });

            if (session.date) {
                addText(`Date: ${session.date}\n`);
            }
            if (session.gmName) {
                addText(`Game Master: ${session.gmName}\n`);
            }
            if (session.campaignName) {
                addText(`Campaign: ${session.campaignName}\n`);
            }
            if (session.location) {
                addText(`Location: ${session.location}\n`);
            }

            addLineBreak();

            // Character summary (basic info)
            addText('Character Summary\n', {
                bold: true,
                fontSize: { magnitude: 14, unit: 'PT' }
            });

            const species = document.getElementById('species').value;
            const characterClass = document.getElementById('class').value;
            const career = document.getElementById('career').value;

            if (species) addText(`Species: ${species}\n`);
            if (characterClass) addText(`Class: ${characterClass}\n`);
            if (career) addText(`Career: ${career}\n`);

            addLineBreak();

            // Session notes content
            addText('Session Notes\n', {
                bold: true,
                fontSize: { magnitude: 14, unit: 'PT' }
            });

            // Convert HTML content to plain text with basic formatting
            const notesText = convertHtmlToPlainText(session.content);
            addText(notesText);

            addLineBreak();
            addLineBreak();

            // Footer
            addText(`Generated on ${new Date().toLocaleDateString()} from WFRP Character Manager`, {
                italic: true,
                fontSize: { magnitude: 10, unit: 'PT' }
            });

            return requests;
        }

        // Convert HTML content to plain text while preserving basic structure
        function convertHtmlToPlainText(html) {
            if (!html) return 'No session notes recorded.';

            // Create a temporary div to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            // Convert various HTML elements to text equivalents
            let text = tempDiv.innerHTML;

            // Convert headings
            text = text.replace(/<h[1-6][^>]*>/gi, '\n\n');
            text = text.replace(/<\/h[1-6]>/gi, '\n');

            // Convert paragraphs
            text = text.replace(/<p[^>]*>/gi, '\n');
            text = text.replace(/<\/p>/gi, '\n');

            // Convert line breaks
            text = text.replace(/<br[^>]*>/gi, '\n');

            // Convert lists
            text = text.replace(/<ul[^>]*>/gi, '\n');
            text = text.replace(/<\/ul>/gi, '\n');
            text = text.replace(/<ol[^>]*>/gi, '\n');
            text = text.replace(/<\/ol>/gi, '\n');
            text = text.replace(/<li[^>]*>/gi, 'â€¢ ');
            text = text.replace(/<\/li>/gi, '\n');

            // Convert bold and italic (preserve for now, Google Docs will handle)
            text = text.replace(/<strong[^>]*>/gi, '**');
            text = text.replace(/<\/strong>/gi, '**');
            text = text.replace(/<b[^>]*>/gi, '**');
            text = text.replace(/<\/b>/gi, '**');
            text = text.replace(/<em[^>]*>/gi, '*');
            text = text.replace(/<\/em>/gi, '*');
            text = text.replace(/<i[^>]*>/gi, '*');
            text = text.replace(/<\/i>/gi, '*');

            // Remove any remaining HTML tags
            text = text.replace(/<[^>]*>/g, '');

            // Decode HTML entities
            tempDiv.innerHTML = text;
            text = tempDiv.textContent || tempDiv.innerText || '';

            // Clean up excessive whitespace
            text = text.replace(/\n\s*\n\s*\n/g, '\n\n');
            text = text.trim();

            return text || 'No session notes recorded.';
        }

        // =============== ERROR HANDLING AND UTILITIES ===============
        
        // Check if user is online
        function isOnline() {
            return navigator.onLine;
        }

        // Enhanced error handling for Google API calls
        function handleGoogleAPIError(error, operation = 'Google Drive operation') {
            console.error(`${operation} error:`, error);
            
            let userMessage = `Failed to complete ${operation.toLowerCase()}`;
            
            if (!isOnline()) {
                userMessage = 'You appear to be offline. Please check your internet connection and try again.';
                showNotification(userMessage, 'error');
                return;
            }

            if (error.result && error.result.error) {
                const apiError = error.result.error;
                
                switch (apiError.code) {
                    case 401:
                        userMessage = 'Authentication expired. Please reconnect to Google Drive.';
                        // Force re-authentication
                        isSignedIn = false;
                        updateGoogleDriveUI();
                        break;
                    case 403:
                        if (apiError.message.includes('rate limit') || apiError.message.includes('quota')) {
                            userMessage = 'Google API rate limit exceeded. Please wait a moment and try again.';
                        } else {
                            userMessage = 'Permission denied. Please check your Google Drive permissions.';
                        }
                        break;
                    case 404:
                        userMessage = 'File or folder not found in Google Drive.';
                        break;
                    case 413:
                        userMessage = 'File too large for Google Drive upload.';
                        break;
                    case 500:
                    case 502:
                    case 503:
                        userMessage = 'Google Drive service temporarily unavailable. Please try again later.';
                        break;
                    default:
                        userMessage = `${operation} failed: ${apiError.message || 'Unknown error'}`;
                }
            } else if (error.message) {
                userMessage = `${operation} failed: ${error.message}`;
            }
            
            showNotification(userMessage, 'error');
        }

        // Safe retry mechanism - NO RECURSION
        async function retryOperation(operation, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await operation();
                } catch (error) {
                    console.log(`Attempt ${attempt} failed:`, error);
                    
                    if (attempt === maxRetries) {
                        throw new Error(`Operation failed after ${maxRetries} attempts: ${error.message}`);
                    }
                    
                    // Wait before retry (exponential backoff)
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        // Check Google API availability
        function checkGoogleAPIAvailability() {
            if (typeof window.gapi === 'undefined') {
                showNotification('Google APIs failed to load. Please refresh the page.', 'error');
                return false;
            }
            
            if (typeof window.google === 'undefined' || !window.google.accounts) {
                showNotification('Google Sign-In library failed to load. Please refresh the page.', 'error');
                return false;
            }
            
            return true;
        }

        // Enhanced initialization with error handling
        async function initializeGoogleAPIs() {
            if (!checkGoogleAPIAvailability()) {
                return;
            }

            try {
                if (typeof window.gapi !== 'undefined') {
                    gapi = window.gapi;
                    await new Promise((resolve, reject) => {
                        gapi.load('client', {
                            callback: resolve,
                            onerror: reject
                        });
                    });
                    await initializeGapiClient();
                }

                if (typeof window.google !== 'undefined') {
                    tokenClient = window.google.accounts.oauth2.initTokenClient({
                        client_id: CLIENT_ID,
                        scope: SCOPES,
                        callback: (response) => {
                            if (response.error) {
                                console.error('OAuth error:', response.error);
                                handleGoogleAPIError(response, 'Google Drive authentication');
                                return;
                            }
                            isSignedIn = true;
                            updateGoogleDriveUI();
                            showNotification('Successfully connected to Google Drive!', 'success');
                        },
                    });
                }

                console.log('Google APIs initialized successfully');
                
                // Check if user was previously signed in
                setTimeout(() => {
                    if (gapi.client.getToken()) {
                        isSignedIn = true;
                        updateGoogleDriveUI();
                    }
                }, 500);

            } catch (error) {
                console.error('Error initializing Google APIs:', error);
                showNotification('Failed to initialize Google Drive integration. Some features may be unavailable.', 'warning');
            }
        }

        // Safe backup with retry logic - NO RECURSION
        async function backupCharacterToDriveWithRetry() {
            if (!isOnline()) {
                showNotification('You are offline. Please connect to the internet to backup to Google Drive.', 'error');
                return;
            }

            if (!isSignedIn) {
                showNotification('Please connect to Google Drive first', 'error');
                return;
            }

            const backupBtn = document.getElementById('backup-character-btn');
            const originalContent = backupBtn.innerHTML;
            
            try {
                // Show loading state
                backupBtn.innerHTML = '<div class="loading-spinner"></div> Backing up...';
                backupBtn.disabled = true;

                // Retry the backup operation safely
                await retryOperation(async () => {
                    // Ensure WFRP folder exists
                    await ensureWFRPFolder();

                    // Gather character data
                    const characterData = gatherCharacterDataForBackup();
                    
                    // Create filename with character name and timestamp
                    const characterName = document.getElementById('character-name').value || 'Unknown_Character';
                    const sanitizedName = characterName.replace(/[^a-zA-Z0-9_-]/g, '_');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                    const filename = `${sanitizedName}_backup_${timestamp}.json`;

                    // Create file metadata
                    const fileMetadata = {
                        name: filename,
                        parents: [wfrpFolderId],
                        description: `WFRP Character backup for ${characterName} created on ${new Date().toLocaleDateString()}`
                    };

                    // Convert character data to JSON
                    const fileContent = JSON.stringify(characterData, null, 2);
                    
                    // Create form data for multipart upload
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(fileMetadata)], {type: 'application/json'}));
                    form.append('file', new Blob([fileContent], {type: 'application/json'}));

                    // Upload to Google Drive
                    const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + gapi.client.getToken().access_token
                        },
                        body: form
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    return result;
                }, 3);

                showNotification('Character backed up successfully!', 'success');

            } catch (error) {
                console.error('Backup error:', error);
                handleGoogleAPIError(error, 'Character backup');
            } finally {
                // Restore button state
                backupBtn.innerHTML = originalContent;
                backupBtn.disabled = false;
            }
        }

        // Safe restore with retry logic - NO RECURSION
        async function restoreSelectedBackupWithRetry() {
            if (!isOnline()) {
                showNotification('You are offline. Please connect to the internet to restore from Google Drive.', 'error');
                return;
            }

            if (!selectedBackupId) {
                showNotification('Please select a backup to restore', 'warning');
                return;
            }

            const confirmed = confirm('This will overwrite your current character data. Are you sure you want to restore this backup?');
            if (!confirmed) return;

            const restoreBtn = document.getElementById('restore-selected-btn');
            const originalContent = restoreBtn.innerHTML;

            try {
                // Show loading state
                restoreBtn.innerHTML = '<div class="loading-spinner"></div> Restoring...';
                restoreBtn.disabled = true;

                // Retry the restore operation safely
                await retryOperation(async () => {
                    // Download the backup file
                    const response = await gapi.client.drive.files.get({
                        fileId: selectedBackupId,
                        alt: 'media'
                    });

                    // Parse the character data
                    const characterData = JSON.parse(response.body);

                    // Restore the character data
                    await restoreCharacterData(characterData);

                    return characterData;
                }, 3);

                showNotification('Character restored successfully!', 'success');
                closeBackupRestoreModal();

            } catch (error) {
                console.error('Restore error:', error);
                handleGoogleAPIError(error, 'Character restore');
            } finally {
                // Restore button state
                restoreBtn.innerHTML = originalContent;
                updateRestoreButton();
            }
        }

        // Safe export with retry logic - NO RECURSION
        async function exportSessionToGoogleDocsWithRetry() {
            if (!isOnline()) {
                showNotification('You are offline. Please connect to the internet to export to Google Docs.', 'error');
                return;
            }

            if (!isSignedIn) {
                showNotification('Please connect to Google Drive first', 'error');
                return;
            }

            if (!currentSessionId) {
                showNotification('No session notes to export. Create a session first.', 'warning');
                return;
            }

            const exportBtn = document.getElementById('export-session-notes-btn');
            const originalContent = exportBtn.innerHTML;

            try {
                // Show loading state
                exportBtn.innerHTML = '<div class="loading-spinner"></div> Exporting...';
                exportBtn.disabled = true;

                // Retry the export operation safely
                const documentId = await retryOperation(async () => {
                    // Save current session first
                    if (typeof saveCurrentSession === 'function') {
                        saveCurrentSession();
                    }

                    // Get current session data
                    const session = sessionNotes.find(s => s.id === currentSessionId);
                    if (!session) {
                        throw new Error('Session not found');
                    }

                    // Ensure WFRP folder exists
                    await ensureWFRPFolder();

                    // Create the Google Doc
                    const characterName = document.getElementById('character-name').value || 'Unknown Character';
                    const docTitle = `${characterName} - Session ${session.number} Notes`;

                    // Create new Google Doc
                    const docResponse = await gapi.client.docs.documents.create({
                        resource: {
                            title: docTitle
                        }
                    });

                    const documentId = docResponse.result.documentId;

                    // Prepare document content
                    const content = await formatSessionForGoogleDocs(session, characterName);

                    // Insert content into the document
                    await gapi.client.docs.documents.batchUpdate({
                        documentId: documentId,
                        resource: {
                            requests: content
                        }
                    });

                    // Move the document to WFRP folder
                    await gapi.client.drive.files.update({
                        fileId: documentId,
                        addParents: wfrpFolderId,
                        fields: 'id, parents'
                    });

                    return documentId;
                }, 3);

                showNotification('Session notes exported successfully!', 'success');

                // Optionally open the document
                const openDoc = confirm('Session exported successfully! Would you like to open the Google Doc?');
                if (openDoc) {
                    window.open(`https://docs.google.com/document/d/${documentId}/edit`, '_blank');
                }

            } catch (error) {
                console.error('Export error:', error);
                handleGoogleAPIError(error, 'Session notes export');
            } finally {
                // Restore button state
                exportBtn.innerHTML = originalContent;
                exportBtn.disabled = false;
            }
        }

        // Online/offline event listeners
        window.addEventListener('online', function() {
            showNotification('Back online! Google Drive features are now available.', 'success');
            if (isSignedIn) {
                updateGoogleDriveUI();
            }
        });

        window.addEventListener('offline', function() {
            showNotification('You are now offline. Google Drive features are unavailable.', 'warning');
            updateGoogleDriveUI();
        });

        // Set the safe functions as the main functions
        window.backupCharacterToDrive = backupCharacterToDriveWithRetry;
        window.restoreSelectedBackup = restoreSelectedBackupWithRetry;
        window.exportSessionToGoogleDocs = exportSessionToGoogleDocsWithRetry;

        // Initialize Google APIs when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Define showTab function before initializing auto-save
            // (showTab is defined later in the file, so we'll initialize after a delay)
            setTimeout(() => {
                // Initialize auto-save system after showTab is defined
                initializeAutoSaveSystem();
            }, 100);
            
            // Add a small delay to ensure Google scripts are loaded
            setTimeout(() => {
                initializeGoogleAPIs();
            }, 1000);
        });

        // =============== AUTO-SAVE SYSTEM ===============
        
        // Auto-save configuration
        const AUTO_SAVE_CONFIG = {
            LOCAL_SAVE_DELAY: 2500,  // 2.5 seconds delay after user stops typing
            SAVE_KEYS: {
                CHARACTER: 'wfrp_character_autosave',
                SESSION_NOTES: 'wfrp_session_notes_autosave',
                TIMESTAMP: 'wfrp_autosave_timestamp',
                CURRENT_TAB: 'wfrp_current_tab',
                VERSION: 'wfrp_save_version'
            },
            MAX_AGE_HOURS: 24
        };

        // Auto-save state
        let autoSaveTimeout;
        let lastSaveTime = 0;
        let isAutoSaving = false;
        let currentActiveTab = 'character-tab';

        // Save status management
        let fadeOutTimer;
        function updateSaveStatus(status, message) {
            const container = document.getElementById('save-status-container');
            const text = document.getElementById('save-status-text');
            
            if (!container || !text) return;

            // Clear any existing fade timer
            clearTimeout(fadeOutTimer);
            
            // Remove all status classes and show the container
            container.className = 'save-status-container';
            container.classList.remove('fade-out');
            
            // Add new status class
            switch (status) {
                case 'saved-local':
                    container.classList.add('saved-local');
                    break;
                case 'saved-cloud':
                    container.classList.add('saved-cloud');
                    break;
                case 'syncing':
                    container.classList.add('syncing');
                    break;
                case 'error':
                    container.classList.add('error');
                    break;
                case 'offline':
                    container.classList.add('offline');
                    break;
            }
            
            text.textContent = message || 'Ready';
            
            // Fade out after 3 seconds for saved states
            if (status === 'saved-local' || status === 'saved-cloud' || status === 'offline') {
                fadeOutTimer = setTimeout(() => {
                    container.classList.add('fade-out');
                }, 3000);
            }
            // Keep visible for syncing and errors
            else if (status === 'syncing' || status === 'error') {
                // Stay visible
            }
        }

        // Comprehensive data collection function
        function gatherAllCharacterData() {
            try {
                // Start with the same structure as existing save functions
                const characterData = {
                    // Basic character info
                    name: document.getElementById('character-name')?.value || '',
                    species: document.getElementById('species')?.value || '',
                    class: document.getElementById('class')?.value || '',
                    career: document.getElementById('career-select')?.value || '',
                    player: document.getElementById('player')?.value || '',
                    
                    // Career system data
                    careerData: {
                        careerName: currentCareer ? currentCareer.name : null,
                        tier: currentTier,
                        className: currentCareer ? currentCareer.class : null
                    },
                    
                    // Characteristics
                    characteristics: {},
                    
                    // Core stats
                    wounds: {
                        current: document.getElementById('wounds-current')?.value || '',
                        max: document.getElementById('wounds-max')?.value || ''
                    },
                    movement: document.getElementById('movement')?.value || '',
                    fate: document.getElementById('fate')?.value || '',
                    fortune: document.getElementById('fortune-current')?.value || '',
                    resilience: document.getElementById('resilience')?.value || '',
                    resolve: document.getElementById('resolve-current')?.value || '',
                    motivation: document.getElementById('motivation')?.value || '',
                    
                    // Experience
                    experience: {
                        total: document.getElementById('xp-total')?.value || '0',
                        spent: document.getElementById('xp-spent')?.value || '0'
                    },
                    
                    // Status
                    status: {
                        tier: document.getElementById('status-tier')?.value || 'Brass',
                        standing: document.getElementById('status-standing')?.value || ''
                    },
                    
                    // Other stats
                    sinPoints: document.getElementById('sin-points')?.value || '',
                    corruptionPoints: document.getElementById('corruption-points')?.value || '',
                    notes: document.getElementById('quick-notes')?.value || '',
                    
                    // Money
                    money: {
                        gold: document.getElementById('money-gold')?.value || '',
                        silver: document.getElementById('money-silver')?.value || '',
                        brass: document.getElementById('money-brass')?.value || ''
                    },
                    
                    // Complex data structures (with safety checks)
                    skills: typeof characterSkills !== 'undefined' ? characterSkills : [],
                    addedSkills: typeof addedSkills !== 'undefined' ? addedSkills : [],
                    weapons: typeof weapons !== 'undefined' ? weapons : [],
                    armour: typeof armour !== 'undefined' ? armour : [],
                    trappings: typeof trappings !== 'undefined' ? trappings : [],
                    consumables: typeof consumables !== 'undefined' ? consumables : [],
                    talents: typeof talents !== 'undefined' ? talents : [],
                    activeConditions: typeof activeConditions !== 'undefined' ? activeConditions : [],
                    criticalWounds: typeof criticalWounds !== 'undefined' ? criticalWounds : [],
                    spells: typeof spells !== 'undefined' ? spells : [],
                    mutations: typeof mutations !== 'undefined' ? mutations : [],
                    xpLog: typeof xpLog !== 'undefined' ? xpLog : [],
                    
                    // Disease tracking
                    diseaseTracking: {
                        activeDiseases: (typeof character !== 'undefined' && character.diseaseTracking) ? character.diseaseTracking.activeDiseases || [] : [],
                        testReminders: document.getElementById('test-reminders')?.value || ''
                    },
                    
                    // Session notes
                    sessionNotes: typeof sessionNotes !== 'undefined' ? sessionNotes : [],
                    
                    // Auto-save metadata
                    autoSaveTimestamp: new Date().toISOString(),
                    currentTab: currentActiveTab,
                    version: '1.0'
                };

                // Save characteristics
                if (typeof characteristics !== 'undefined') {
                    characteristics.forEach(char => {
                        const initialElement = document.getElementById(`${char}-initial`);
                        const advancesElement = document.getElementById(`${char}-advances`);
                        if (initialElement && advancesElement) {
                            characterData.characteristics[char] = {
                                initial: initialElement.value || '',
                                advances: advancesElement.value || ''
                            };
                        }
                    });
                }

                return characterData;
            } catch (error) {
                console.error('Error gathering character data:', error);
                return null;
            }
        }

        // Debounced auto-save function
        function triggerAutoSave() {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(performAutoSave, AUTO_SAVE_CONFIG.LOCAL_SAVE_DELAY);
        }

        // Immediate auto-save (for critical events)
        function triggerImmediateAutoSave() {
            clearTimeout(autoSaveTimeout);
            performAutoSave();
        }

        // Perform the actual auto-save
        async function performAutoSave() {
            if (isAutoSaving) return;

            try {
                isAutoSaving = true;
                updateSaveStatus('syncing', 'Saving...');

                const characterData = gatherAllCharacterData();
                
                if (!characterData) {
                    throw new Error('Failed to gather character data');
                }

                // Save to localStorage
                localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CHARACTER, JSON.stringify(characterData));
                localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.TIMESTAMP, new Date().toISOString());
                localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CURRENT_TAB, currentActiveTab);
                localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.VERSION, '1.0');

                lastSaveTime = Date.now();
                updateSaveStatus('saved-local', 'Saved locally');

                // Try to backup to Google Drive if connected
                setTimeout(attemptCloudBackup, 1000);

            } catch (error) {
                console.error('Auto-save failed:', error);
                updateSaveStatus('error', 'Save failed');
            } finally {
                isAutoSaving = false;
            }
        }

        // Attempt to backup to Google Drive
        async function attemptCloudBackup() {
            if (!isSignedIn || !isOnline()) {
                updateSaveStatus('offline', isSignedIn ? 'Saved locally (offline)' : 'Saved locally');
                return;
            }

            try {
                updateSaveStatus('syncing', 'Syncing to Drive...');
                
                // Use existing Google Drive backup function
                await backupCharacterToDriveWithRetry();
                
                updateSaveStatus('saved-cloud', 'Backed up to Drive');
            } catch (error) {
                console.error('Cloud backup failed:', error);
                updateSaveStatus('saved-local', 'Saved locally (Drive sync failed)');
            }
        }

        // Auto-restore functionality
        function checkForAutoRestore() {
            try {
                const savedData = localStorage.getItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CHARACTER);
                const saveTimestamp = localStorage.getItem(AUTO_SAVE_CONFIG.SAVE_KEYS.TIMESTAMP);
                
                if (!savedData || !saveTimestamp) {
                    updateSaveStatus('saved-local', 'Ready');
                    return;
                }

                const saveDate = new Date(saveTimestamp);
                const hoursAgo = (new Date() - saveDate) / (1000 * 60 * 60);

                // Only auto-restore if save is less than 24 hours old
                if (hoursAgo > AUTO_SAVE_CONFIG.MAX_AGE_HOURS) {
                    // Clean up old saves
                    cleanupOldAutoSaves();
                    updateSaveStatus('saved-local', 'Ready');
                    return;
                }

                // Pre-restore the saved tab immediately to prevent UI flashing
                const savedTab = localStorage.getItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CURRENT_TAB);
                if (savedTab && window.showTab) {
                    try {
                        window.showTab(savedTab);
                    } catch (error) {
                        console.warn('Could not pre-restore tab:', error);
                    }
                }

                // Show restore dialog
                showAutoRestoreDialog(saveDate, savedData);

            } catch (error) {
                console.error('Error checking for auto-restore:', error);
                updateSaveStatus('saved-local', 'Ready');
            }
        }

        // Show auto-restore dialog
        function showAutoRestoreDialog(saveDate, savedData) {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001;';

            const notification = document.createElement('div');
            notification.className = 'auto-restore-notification';
            
            const timeAgo = getTimeAgoString(saveDate);
            
            notification.innerHTML = `
                <h3>Unsaved Changes Found</h3>
                <p style="text-align: center; margin-bottom: 10px; color: #666;">
                    Found character data auto-saved ${timeAgo}
                </p>
                <p style="text-align: center; margin-bottom: 15px; color: #3e2f1f;">
                    Would you like to restore your unsaved changes?
                </p>
                <div class="auto-restore-buttons">
                    <button class="auto-restore-btn primary" onclick="restoreAutoSavedData('${btoa(savedData)}', this)">
                        Restore Changes
                    </button>
                    <button class="auto-restore-btn secondary" onclick="startFresh(this)">
                        Start Fresh
                    </button>
                </div>
            `;

            overlay.appendChild(notification);
            document.body.appendChild(overlay);
        }

        // Restore auto-saved data
        window.restoreAutoSavedData = function(encodedData, buttonElement) {
            try {
                const savedData = atob(encodedData);
                const characterData = JSON.parse(savedData);
                
                // Restore all character data using existing restore logic
                restoreCharacterDataFromAutoSave(characterData);
                
                // Tab was already restored in checkForAutoRestore, just update the tracking
                const savedTab = localStorage.getItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CURRENT_TAB);
                if (savedTab) {
                    currentActiveTab = savedTab;
                }

                // Close the dialog
                buttonElement.closest('.auto-restore-notification').parentElement.remove();
                
                updateSaveStatus('saved-local', `Restored from ${getTimeAgoString(new Date(characterData.autoSaveTimestamp))}`);
                
                // Auto-save the restored data
                setTimeout(triggerAutoSave, 1000);

            } catch (error) {
                console.error('Error restoring auto-saved data:', error);
                alert('Failed to restore saved data. Starting fresh.');
                startFresh(buttonElement);
            }
        }

        // Start fresh (discard auto-saved data)
        window.startFresh = function(buttonElement) {
            cleanupOldAutoSaves();
            buttonElement.closest('.auto-restore-notification').parentElement.remove();
            updateSaveStatus('saved-local', 'Ready');
        }

        // Restore character data from auto-save
        function restoreCharacterDataFromAutoSave(characterData) {
            // Basic character info
            if (characterData.name) document.getElementById('character-name').value = characterData.name;
            if (characterData.species) document.getElementById('species').value = characterData.species;
            if (characterData.class) document.getElementById('class').value = characterData.class;
            if (characterData.player) document.getElementById('player').value = characterData.player;
            
            // Restore career data
            if (characterData.careerData && careersData) {
                if (characterData.careerData.careerName) {
                    const career = careersData.careers.find(c => c.name === characterData.careerData.careerName);
                    if (career) {
                        document.getElementById('career-select').value = characterData.careerData.careerName;
                        document.getElementById('tier-select').value = characterData.careerData.tier || 1;
                        currentTier = characterData.careerData.tier || 1;
                        selectCareer(career);
                    }
                }
            } else if (characterData.career) {
                // Fallback for old save format
                document.getElementById('career-select').value = characterData.career;
            }
            
            // Characteristics
            if (characterData.characteristics && typeof characteristics !== 'undefined') {
                characteristics.forEach(char => {
                    if (characterData.characteristics[char]) {
                        const initialElement = document.getElementById(`${char}-initial`);
                        const advancesElement = document.getElementById(`${char}-advances`);
                        if (initialElement) initialElement.value = characterData.characteristics[char].initial || '';
                        if (advancesElement) advancesElement.value = characterData.characteristics[char].advances || '';
                    }
                });
            }
            
            // Core stats
            if (characterData.wounds) {
                if (document.getElementById('wounds-current')) document.getElementById('wounds-current').value = characterData.wounds.current || '';
                if (document.getElementById('wounds-max')) document.getElementById('wounds-max').value = characterData.wounds.max || '';
            }
            
            if (document.getElementById('movement')) document.getElementById('movement').value = characterData.movement || '';
            if (document.getElementById('fate')) document.getElementById('fate').value = characterData.fate || '';
            if (document.getElementById('fortune-current')) document.getElementById('fortune-current').value = characterData.fortune || '';
            if (document.getElementById('resilience')) document.getElementById('resilience').value = characterData.resilience || '';
            if (document.getElementById('resolve-current')) document.getElementById('resolve-current').value = characterData.resolve || '';
            if (document.getElementById('motivation')) document.getElementById('motivation').value = characterData.motivation || '';
            
            // Experience
            if (characterData.experience) {
                if (document.getElementById('xp-total')) document.getElementById('xp-total').value = characterData.experience.total || '0';
                if (document.getElementById('xp-spent')) document.getElementById('xp-spent').value = characterData.experience.spent || '0';
            }
            
            // Status
            if (characterData.status) {
                if (document.getElementById('status-tier')) document.getElementById('status-tier').value = characterData.status.tier || 'Brass';
                if (document.getElementById('status-standing')) document.getElementById('status-standing').value = characterData.status.standing || '';
            }
            
            // Other stats
            if (document.getElementById('sin-points')) document.getElementById('sin-points').value = characterData.sinPoints || '';
            if (document.getElementById('corruption-points')) document.getElementById('corruption-points').value = characterData.corruptionPoints || '';
            if (document.getElementById('quick-notes')) document.getElementById('quick-notes').value = characterData.notes || '';
            
            // Money
            if (characterData.money) {
                if (document.getElementById('money-gold')) document.getElementById('money-gold').value = characterData.money.gold || '';
                if (document.getElementById('money-silver')) document.getElementById('money-silver').value = characterData.money.silver || '';
                if (document.getElementById('money-brass')) document.getElementById('money-brass').value = characterData.money.brass || '';
            }
            
            // Complex data structures
            if (characterData.skills && typeof characterSkills !== 'undefined') {
                window.characterSkills = characterData.skills;
                if (typeof displaySkills === 'function') displaySkills();
            }
            if (characterData.addedSkills && typeof addedSkills !== 'undefined') {
                window.addedSkills = characterData.addedSkills;
            }
            if (characterData.weapons && typeof weapons !== 'undefined') {
                window.weapons = characterData.weapons;
                if (typeof displayWeapons === 'function') displayWeapons();
            }
            if (characterData.armour && typeof armour !== 'undefined') {
                window.armour = characterData.armour;
                if (typeof displayArmour === 'function') displayArmour();
            }
            if (characterData.trappings && typeof trappings !== 'undefined') {
                window.trappings = characterData.trappings;
                if (typeof displayTrappings === 'function') displayTrappings();
            }
            if (characterData.consumables && typeof consumables !== 'undefined') {
                window.consumables = characterData.consumables;
                if (typeof displayConsumables === 'function') displayConsumables();
            }
            if (characterData.talents && typeof talents !== 'undefined') {
                window.talents = characterData.talents;
                if (typeof displayTalents === 'function') displayTalents();
            }
            if (characterData.spells && typeof spells !== 'undefined') {
                window.spells = characterData.spells;
                if (typeof displaySpells === 'function') displaySpells();
            }
            if (characterData.xpLog && typeof xpLog !== 'undefined') {
                window.xpLog = characterData.xpLog;
            }
            if (characterData.sessionNotes && typeof sessionNotes !== 'undefined') {
                window.sessionNotes = characterData.sessionNotes;
            }
            
            // Disease tracking
            if (characterData.diseaseTracking) {
                if (document.getElementById('test-reminders')) document.getElementById('test-reminders').value = characterData.diseaseTracking.testReminders || '';
            }
            
            // Update displays
            setTimeout(() => {
                try {
                    if (typeof updateEncumbrance === 'function') updateEncumbrance();
                    if (typeof window.updateXPDisplay === 'function') window.updateXPDisplay();
                    if (typeof updateTotalAP === 'function') updateTotalAP();
                } catch (error) {
                    console.error('Error updating displays:', error);
                }
            }, 500);
        }

        // Utility functions
        function getTimeAgoString(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            
            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins} minute${diffMins === 1 ? '' : 's'} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
            
            return date.toLocaleDateString() + ' at ' + date.toLocaleTimeString();
        }

        function cleanupOldAutoSaves() {
            Object.values(AUTO_SAVE_CONFIG.SAVE_KEYS).forEach(key => {
                localStorage.removeItem(key);
            });
        }

        // Event listener setup
        function setupAutoSaveEventListeners() {
            // Text inputs
            document.querySelectorAll('input[type="text"], input[type="number"], textarea, select').forEach(element => {
                if (element.id) {
                    element.addEventListener('input', triggerAutoSave);
                    element.addEventListener('change', triggerAutoSave);
                }
            });

            // Checkbox inputs
            document.querySelectorAll('input[type="checkbox"]').forEach(element => {
                element.addEventListener('change', triggerAutoSave);
            });

            // Tab switching - wrap only if not already wrapped
            if (window.showTab && !window.showTab._isWrapped) {
                const originalShowTab = window.showTab;
                window.showTab = function(tabId) {
                    // Call the original function first
                    const result = originalShowTab.call(this, tabId);
                    // Then update tracking and trigger save
                    currentActiveTab = tabId;
                    localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.CURRENT_TAB, tabId);
                    triggerAutoSave();
                    return result;
                };
                window.showTab._isWrapped = true;
            }

            // Window events
            window.addEventListener('beforeunload', (e) => {
                triggerImmediateAutoSave();
                // Note: Modern browsers ignore custom messages
                e.returnValue = '';
            });

            window.addEventListener('blur', triggerImmediateAutoSave);
            window.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    triggerImmediateAutoSave();
                }
            });

            // Monitor dynamic content changes
            const observer = new MutationObserver((mutations) => {
                let shouldSave = false;
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList' || mutation.type === 'characterData') {
                        shouldSave = true;
                    }
                });
                if (shouldSave) {
                    triggerAutoSave();
                }
            });

            // Observe changes to tables and dynamic content
            const tableContainers = document.querySelectorAll('tbody, .session-notes-content');
            tableContainers.forEach(container => {
                observer.observe(container, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            });

            // Override existing functions to trigger auto-save
            const functionsToOverride = [
                'addSkill', 'removeSkill', 'updateSkillAdvances',
                'addWeapon', 'removeWeapon', 'toggleWeaponEquipped',
                'addArmour', 'removeArmour', 'toggleArmourWorn',
                'addTrapping', 'removeTrapping', 'updateTrappingQuantity',
                'addConsumable', 'removeConsumable', 'adjustConsumable',
                'addTalent', 'removeTalent',
                'addSpell', 'removeSpell',
                'addSessionXP', 'spendXP',
                'saveCurrentSession'
            ];

            functionsToOverride.forEach(funcName => {
                const originalFunc = window[funcName];
                if (typeof originalFunc === 'function') {
                    window[funcName] = function(...args) {
                        const result = originalFunc.apply(this, args);
                        triggerAutoSave();
                        return result;
                    };
                }
            });
        }

        // Integration with existing manual save
        const originalSaveCharacter = window.saveCharacter;
        if (originalSaveCharacter) {
            window.saveCharacter = function() {
                // Call original save function
                const result = originalSaveCharacter.call(this);
                
                // Update auto-save timestamp
                localStorage.setItem(AUTO_SAVE_CONFIG.SAVE_KEYS.TIMESTAMP, new Date().toISOString());
                updateSaveStatus('saved-local', 'Manually saved');
                
                return result;
            };
        }

        // Auto-save system initialization
        function initializeAutoSaveSystem() {
            try {
                // Set up event listeners
                setupAutoSaveEventListeners();
                
                // Check for auto-restore after a short delay to ensure page is loaded
                setTimeout(checkForAutoRestore, 2000);
                
                console.log('Auto-save system initialized');
            } catch (error) {
                console.error('Error initializing auto-save system:', error);
                updateSaveStatus('error', 'Auto-save failed to initialize');
            }
        }

        // Tab switching functionality with enhanced error handling
        window.showTab = function(tabId, retryCount = 0) {
            try {
                // Validate that we have a valid tabId
                if (!tabId || typeof tabId !== 'string') {
                    console.warn('Invalid tabId provided, defaulting to character-tab');
                    tabId = 'character-tab';
                }

                // Hide all tabs
                const tabs = document.querySelectorAll('.tab-content');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Remove active class from all buttons
                const buttons = document.querySelectorAll('.tab-button');
                buttons.forEach(button => {
                    button.classList.remove('active');
                });
                
                // Show selected tab (with validation and retry logic)
                let targetTab = document.getElementById(tabId);
                if (targetTab) {
                    targetTab.classList.add('active');
                } else {
                    // If tab not found and this is first retry, wait and try again
                    if (retryCount < 1) {
                        console.warn(`Tab with ID '${tabId}' not found, retrying in 500ms...`);
                        setTimeout(() => window.showTab(tabId, retryCount + 1), 500);
                        return;
                    }
                    
                    // After retry, fallback to character-tab
                    console.warn(`Tab with ID '${tabId}' not found after retry, defaulting to character-tab`);
                    targetTab = document.getElementById('character-tab');
                    if (targetTab) {
                        targetTab.classList.add('active');
                        tabId = 'character-tab'; // Update the tabId for consistency
                    } else {
                        console.error('Critical: Even character-tab not found');
                        return; // Exit if we can't even find overview
                    }
                }
                
                // Add active class to corresponding button (safer approach)
                const targetButton = document.querySelector(`.tab-button[onclick*="${tabId}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                } else if (typeof event !== 'undefined' && event.target) {
                    // Fallback to event.target if available (for manual clicks)
                    event.target.classList.add('active');
                }
                
                // Update current active tab for auto-save only if not wrapped
                if (typeof currentActiveTab !== 'undefined') {
                    currentActiveTab = tabId;
                }
                
            } catch (error) {
                console.error('Error in showTab function:', error);
                // Ultimate fallback to character-tab
                try {
                    const characterTab = document.getElementById('character-tab');
                    if (characterTab) {
                        // Clear all active states first
                        document.querySelectorAll('.tab-content').forEach(tab => {
                            tab.classList.remove('active');
                        });
                        document.querySelectorAll('.tab-button').forEach(button => {
                            button.classList.remove('active');
                        });
                        
                        characterTab.classList.add('active');
                        if (typeof currentActiveTab !== 'undefined') {
                            currentActiveTab = 'character-tab';
                        }
                        
                        // Try to activate character button
                        const characterButton = document.querySelector('.tab-button[onclick*="character-tab"]');
                        if (characterButton) {
                            characterButton.classList.add('active');
                        }
                    }
                } catch (fallbackError) {
                    console.error('Critical error: Could not access character tab:', fallbackError);
                }
            }
        }

        // Initialize character data
        let character = {
            name: '',
            species: '',
            class: '',
            career: '',
            careerLevel: '',
            careerPath: '',
            status: '',
            age: '',
            height: '',
            hair: '',
            eyes: '',
            attributes: {
                WS: { initial: 0, advances: 0, current: 0 },
                BS: { initial: 0, advances: 0, current: 0 },
                S: { initial: 0, advances: 0, current: 0 },
                T: { initial: 0, advances: 0, current: 0 },
                I: { initial: 0, advances: 0, current: 0 },
                Ag: { initial: 0, advances: 0, current: 0 },
                Dex: { initial: 0, advances: 0, current: 0 },
                Int: { initial: 0, advances: 0, current: 0 },
                WP: { initial: 0, advances: 0, current: 0 },
                Fel: { initial: 0, advances: 0, current: 0 }
            },
            fate: { fortune: 0, fate: 0 },
            resilience: { resolve: 0, resilience: 0 },
            experience: { current: 0, spent: 0, total: 0 },
            movement: 4,
            wounds: { current: 0, max: 0 },
            skills: [],
            talents: [],
            trappings: [],
            wealth: { brass: 0, silver: 0, gold: 0 },
            psychology: '',
            motivation: '',
            shortTermAmbitions: '',
            longTermAmbitions: '',
            corruption: {
                points: 0,
                threshold: 0,
                physicalMutations: [],
                mentalCorruptions: [],
                awaitingTest: false
            },
            diseaseTracking: {
                activeDiseases: [], // Array of active disease objects with id, name, contractDate, notes, symptoms
                testReminders: "" // Upcoming tests/checks needed
            }
        };

        // Expose character to window for debugging
        window.character = character;

        // Global variables
        let characterSkills = {};
        let addedSkills = []; // Track all manually added skills
        let weapons = [];
        let armour = [];
        let trappings = [];
        let consumables = [];
        
        // Career System Variables
        let careersData = null;
        let currentCareer = null;
        let previewCareer = null;
        let currentTier = 1;
        let careersByClass = {};
        
        // Global Tier Change Handler
        function handleGlobalTierChange() {
            const globalTierSelect = document.getElementById('global-tier');
            const tierSelect = document.getElementById('tier-select');
            
            currentTier = parseInt(globalTierSelect.value);
            
            // Sync with the career tier select if it exists
            if (tierSelect) {
                tierSelect.value = currentTier;
            }
            
            // Update characteristic limits if we have a career selected
            if (currentCareer) {
                updateCharacteristicLimits();
                updateTierDisplay();
                saveCareerSelection();
            }
            
            console.log('Global tier changed to:', currentTier);
        }
        
        // WFRP 4th Edition Official Conditions
        const wfrpConditions = {
          "Ablaze": {
            stackable: true,
            severity: "severe",
            effects: { damage: "1d10/round", damagePerStack: "+1" },
            description: "You are on fire! At the end of every Round, suffer 1d10 Wounds (+1 per extra Ablaze). Remove with Athletics Test."
          },
          "Bleeding": {
            stackable: true,
            severity: "severe",
            effects: { damage: "1/round", diseaseResistance: -10 },
            description: "Lose 1 Wound/round, -10 to resist infections. Remove with Heal Test or healing spells."
          },
          "Blinded": {
            stackable: true,
            severity: "minor",
            effects: { sightTests: -10, enemyMeleeBonus: 10 },
            description: "Cannot see properly. -10 to sight Tests, enemies +10 to hit in melee."
          },
          "Broken": {
            stackable: true,
            severity: "moderate",
            effects: { allTests: -10, mustFlee: true },
            description: "Terrified and panicked. Must flee/hide, -10 to all Tests except running/hiding."
          },
          "Deafened": {
            stackable: true,
            severity: "minor",
            effects: { hearingTests: -10, flankingBonus: 10 },
            description: "-10 to hearing Tests, enemies from flank/rear get extra +10 to hit."
          },
          "Entangled": {
            stackable: true,
            severity: "positional",
            effects: { noMovement: true, movementTests: -10 },
            description: "Cannot move, -10 to movement Tests. Remove with opposed Strength Test."
          },
          "Fatigued": {
            stackable: true,
            severity: "minor",
            effects: { allTests: -10 },
            description: "Exhausted. -10 penalty to ALL Tests."
          },
          "Poisoned": {
            stackable: true,
            severity: "moderate",
            effects: { damage: "1/round", allTests: -10 },
            description: "Lose 1 Wound/round, -10 to all Tests. Remove with Endurance or Heal Tests."
          },
          "Prone": {
            stackable: false,
            severity: "positional",
            effects: { movementTests: -20, enemyMeleeBonus: 20 },
            description: "On the ground. -20 to movement Tests, enemies +20 to hit in melee."
          },
          "Stunned": {
            stackable: true,
            severity: "moderate",
            effects: { noActions: true, allTests: -10, enemyAdvantage: 1 },
            description: "Cannot take Actions, -10 to all Tests, enemies gain +1 Advantage."
          },
          "Surprised": {
            stackable: false,
            severity: "positional",
            effects: { noActions: true, noMovement: true, enemyMeleeBonus: 20 },
            description: "Cannot act or move, enemies +20 to hit."
          },
          "Unconscious": {
            stackable: false,
            severity: "severe",
            effects: { incapacitated: true, autoKill: true },
            description: "Knocked out. Cannot act, attackers auto-hit with killing blows."
          }
        };

        // WFRP 4th Edition Official Critical Wounds Reference Data
        const headCriticalWounds = {
          "01-03": { name: "Dramatic Injury", wounds: "T", effects: "Gain 1 Bleeding Condition. Once healed, +1 SL to social Tests (once only)", conditions: ["Bleeding"], location: "Head", severity: "minor" },
          "04-06": { name: "Rattling Blow", wounds: 1, effects: "Gain 1 Stunned Condition", conditions: ["Stunned"], location: "Head", severity: "minor" },
          "07-09": { name: "Poked Eye", wounds: 1, effects: "Gain 1 Blinded Condition", conditions: ["Blinded"], location: "Head", severity: "minor" },
          "10-15": { name: "Ear Bash", wounds: 1, effects: "Gain 1 Deafened Condition", conditions: ["Deafened"], location: "Head", severity: "minor" },
          "16-20": { name: "Minor Cut", wounds: 1, effects: "Gain 1 Bleeding Condition", conditions: ["Bleeding"], location: "Head", severity: "minor" },
          "21-25": { name: "Black Eye", wounds: 2, effects: "Gain 2 Blinded Conditions", conditions: ["Blinded", "Blinded"], location: "Head", severity: "minor" },
          "26-30": { name: "Sliced Ear", wounds: 2, effects: "Gain 2 Deafened and 1 Bleeding Condition", conditions: ["Deafened", "Deafened", "Bleeding"], location: "Head", severity: "minor" },
          "31-35": { name: "Struck Forehead", wounds: 2, effects: "Gain 2 Bleeding and 1 Blinded Condition (Blinded cannot be removed until Bleeding removed)", conditions: ["Bleeding", "Bleeding", "Blinded"], location: "Head", severity: "minor" },
          "36-40": { name: "Fractured Jaw", wounds: 2, effects: "Gain 2 Stunned Conditions. Broken Bone (Minor) injury", conditions: ["Stunned", "Stunned"], injuries: ["Broken Bone (Minor)"], location: "Head", severity: "moderate" },
          "41-45": { name: "Major Eye Wound", wounds: 3, effects: "Gain 1 Bleeding and 1 Blinded Condition (Blinded needs Medical Attention)", conditions: ["Bleeding", "Blinded"], location: "Head", severity: "moderate" },
          "46-50": { name: "Major Ear Wound", wounds: 3, effects: "-20 penalty to hearing Tests. Permanent loss if suffered again", permanentEffects: ["-20 hearing Tests"], location: "Head", severity: "moderate" },
          "51-55": { name: "Broken Nose", wounds: 3, effects: "Gain 2 Bleeding Conditions. Challenging (+0) Endurance Test or gain Stunned", conditions: ["Bleeding", "Bleeding"], location: "Head", severity: "moderate" },
          "56-60": { name: "Broken Jaw", wounds: 3, effects: "Gain 3 Stunned Conditions. Challenging (+0) Endurance Test or gain Unconscious. Broken Bone (Major)", conditions: ["Stunned", "Stunned", "Stunned"], injuries: ["Broken Bone (Major)"], location: "Head", severity: "moderate" },
          "61-65": { name: "Mangled Ear", wounds: 4, effects: "Gain 3 Deafened and 2 Bleeding Conditions. Lose ear - Amputation (Average)", conditions: ["Deafened", "Deafened", "Deafened", "Bleeding", "Bleeding"], amputations: ["Ear"], location: "Head", severity: "severe" },
          "66-75": { name: "Smashed Mouth", wounds: 4, effects: "Gain 2 Bleeding Conditions. Lose 1d10 teeth - Amputation (Easy)", conditions: ["Bleeding", "Bleeding"], amputations: ["1d10 Teeth"], location: "Head", severity: "severe" },
          "76-80": { name: "Concussive Blow", wounds: 4, effects: "Gain 1 Deafened, 2 Bleeding, 1d10 Stunned Conditions. Fatigued for 1d10 days", conditions: ["Deafened", "Bleeding", "Bleeding"], location: "Head", severity: "severe" },
          "81-85": { name: "Devastated Eye", wounds: 5, effects: "Gain 3 Blinded, 2 Bleeding, 1 Stunned Condition. Lose eye - Amputation (Difficult)", conditions: ["Blinded", "Blinded", "Blinded", "Bleeding", "Bleeding", "Stunned"], amputations: ["Eye"], location: "Head", severity: "severe" },
          "86-94": { name: "Disfiguring Blow", wounds: 5, effects: "Gain 3 Bleeding, 3 Blinded, 2 Stunned Conditions. Lose eye and nose - Amputation (Hard)", conditions: ["Bleeding", "Bleeding", "Bleeding", "Blinded", "Blinded", "Blinded", "Stunned", "Stunned"], amputations: ["Eye", "Nose"], location: "Head", severity: "severe" },
          "95-99": { name: "Mangled Jaw", wounds: 5, effects: "Gain 4 Bleeding, 3 Stunned Conditions. Broken Bone (Major), lose tongue and 1d10 teeth - Amputation (Hard)", conditions: ["Bleeding", "Bleeding", "Bleeding", "Bleeding", "Stunned", "Stunned", "Stunned"], injuries: ["Broken Bone (Major)"], amputations: ["Tongue", "1d10 Teeth"], location: "Head", severity: "severe" },
          "100+": { name: "Shattered Skull", wounds: "Death", effects: "Head caved in, instantly dead", fatal: true, location: "Head", severity: "fatal" }
        };

        const armCriticalWounds = {
          "01-10": { name: "Jolted Wrist", wounds: "T", effects: "Drop any item held in hand", location: "Arm", severity: "minor" },
          "11-20": { name: "Jarred Arm", wounds: "T", effects: "Drop items, hand useless for 1d10-TB Rounds (min 1). Treat as lost hand", location: "Arm", severity: "minor" },
          "21-25": { name: "Minor Cut", wounds: 1, effects: "Gain 1 Bleeding Condition", conditions: ["Bleeding"], location: "Arm", severity: "minor" },
          "26-40": { name: "Sprain", wounds: 1, effects: "Torn Muscle (Minor) injury", injuries: ["Torn Muscle (Minor)"], location: "Arm", severity: "minor" },
          "41-45": { name: "Torn Muscles", wounds: 1, effects: "Gain 1 Bleeding Condition and Torn Muscle (Minor) injury", conditions: ["Bleeding"], injuries: ["Torn Muscle (Minor)"], location: "Arm", severity: "minor" },
          "46-50": { name: "Bleeding Hand", wounds: 1, effects: "Gain 1 Bleeding Condition. Average (+20) Dexterity Test before using hand or drop item", conditions: ["Bleeding"], location: "Arm", severity: "minor" },
          "51-55": { name: "Wrenched Arm", wounds: 2, effects: "Drop items. Arm useless for 1d10 Rounds", location: "Arm", severity: "minor" },
          "56-60": { name: "Gaping Wound", wounds: 2, effects: "Gain 2 Bleeding Conditions. Until Surgery, arm damage causes extra Bleeding", conditions: ["Bleeding", "Bleeding"], location: "Arm", severity: "minor" },
          "61-75": { name: "Clean Break", wounds: 2, effects: "Drop items, Broken Bone (Minor). Difficult (-10) Endurance Test or gain Stunned", injuries: ["Broken Bone (Minor)"], location: "Arm", severity: "moderate" },
          "76-80": { name: "Ruptured Ligament", wounds: 2, effects: "Drop items. Torn Muscle (Major) injury", injuries: ["Torn Muscle (Major)"], location: "Arm", severity: "moderate" },
          "81-85": { name: "Deep Cut", wounds: 3, effects: "Gain 2 Bleeding, 1 Stunned Condition, Torn Muscle (Minor). Hard (-20) Endurance Test or Unconscious", conditions: ["Bleeding", "Bleeding", "Stunned"], injuries: ["Torn Muscle (Minor)"], location: "Arm", severity: "moderate" },
          "86-90": { name: "Crushed Elbow", wounds: 3, effects: "Drop items, Broken Bone (Major) injury", injuries: ["Broken Bone (Major)"], location: "Arm", severity: "moderate" },
          "91-95": { name: "Damaged Artery", wounds: 3, effects: "Gain 4 Bleeding Conditions", conditions: ["Bleeding", "Bleeding", "Bleeding", "Bleeding"], location: "Arm", severity: "moderate" },
          "96-109": { name: "Dislocated Shoulder", wounds: 4, effects: "Arm counts as lost. Gain 1 Stunned until Medical Attention. Extended Heal Test (6 SL) resets arm. -10 penalty 1d10 days after", conditions: ["Stunned"], location: "Arm", severity: "severe" },
          "110-115": { name: "Severed Finger", wounds: 4, effects: "Lose 1 finger - Amputation (Average). Gain 1 Bleeding", conditions: ["Bleeding"], amputations: ["Finger"], location: "Arm", severity: "severe" },
          "116-120": { name: "Cleft Hand", wounds: 4, effects: "Lose 1 finger - Amputation (Difficult). Gain 2 Bleeding, 1 Stunned. Lose more fingers without Medical Attention", conditions: ["Bleeding", "Bleeding", "Stunned"], amputations: ["Finger"], location: "Arm", severity: "severe" },
          "121-125": { name: "Mauled Bicep", wounds: 5, effects: "Drop items, Torn Muscle (Major), 2 Bleeding, 1 Stunned", conditions: ["Bleeding", "Bleeding", "Stunned"], injuries: ["Torn Muscle (Major)"], location: "Arm", severity: "severe" },
          "126-130": { name: "Mangled Hand", wounds: 5, effects: "Lose hand - Amputation (Hard). Gain 2 Bleeding. Hard (-20) Endurance Test or gain Stunned and Prone", conditions: ["Bleeding", "Bleeding"], amputations: ["Hand"], location: "Arm", severity: "severe" },
          "131-135": { name: "Sliced Tendons", wounds: 5, effects: "Arm useless - Amputation (Very Hard). Gain 3 Bleeding, 1 Stunned. Hard (-20) Endurance Test or Unconscious", conditions: ["Bleeding", "Bleeding", "Bleeding", "Stunned"], location: "Arm", severity: "severe" },
          "136+": { name: "Brutal Dismemberment", wounds: "Death", effects: "Arm severed. Die from shock and blood loss", fatal: true, location: "Arm", severity: "fatal" }
        };

        const bodyCriticalWounds = {
          "01-10": { name: "Winded", wounds: "T", effects: "Gain 1 Stunned. Average (+20) Endurance Test or Prone. Movement halved 1d10 Rounds", conditions: ["Stunned"], location: "Body", severity: "minor" },
          "11-20": { name: "'Tis But A Scratch!", wounds: 1, effects: "Gain 1 Bleeding Condition", conditions: ["Bleeding"], location: "Body", severity: "minor" },
          "21-25": { name: "Gut Blow", wounds: 1, effects: "Gain 1 Stunned. Easy (+40) Endurance Test or vomit and gain Prone", conditions: ["Stunned"], location: "Body", severity: "minor" },
          "26-30": { name: "Low Blow!", wounds: 1, effects: "Hard (-20) Endurance Test or gain 3 Stunned Conditions", location: "Body", severity: "minor" },
          "31-35": { name: "Twisted Back", wounds: 1, effects: "Torn Muscle (Minor) injury", injuries: ["Torn Muscle (Minor)"], location: "Body", severity: "minor" },
          "36-40": { name: "Bruised Ribs", wounds: 2, effects: "All Agility Tests -10 penalty for 1d10 days", temporaryEffects: ["-10 Agility Tests"], location: "Body", severity: "minor" },
          "41-45": { name: "Wrenched Collar Bone", wounds: 2, effects: "Random arm useless for 1d10 Rounds", location: "Body", severity: "minor" },
          "46-50": { name: "Ragged Wound", wounds: 2, effects: "Gain 2 Bleeding Conditions", conditions: ["Bleeding", "Bleeding"], location: "Body", severity: "minor" },
          "51-55": { name: "Cracked Ribs", wounds: 2, effects: "Gain 1 Stunned, Broken Bone (Minor) injury", conditions: ["Stunned"], injuries: ["Broken Bone (Minor)"], location: "Body", severity: "moderate" },
          "56-60": { name: "Gaping Wound", wounds: 3, effects: "Gain 3 Bleeding. Until Surgery, body damage causes extra Bleeding", conditions: ["Bleeding", "Bleeding", "Bleeding"], location: "Body", severity: "moderate" },
          "61-65": { name: "Painful Cut", wounds: 3, effects: "Gain 2 Bleeding, 1 Stunned. Hard (-20) Endurance Test or Unconscious. Scream unless 4+ SL", conditions: ["Bleeding", "Bleeding", "Stunned"], location: "Body", severity: "moderate" },
          "66-70": { name: "Arterial Damage", wounds: 3, effects: "Gain 4 Bleeding. Until Surgery, body damage causes 2 extra Bleeding", conditions: ["Bleeding", "Bleeding", "Bleeding", "Bleeding"], location: "Body", severity: "moderate" },
          "71-75": { name: "Pulled Back", wounds: 3, effects: "Torn Muscle (Major) injury", injuries: ["Torn Muscle (Major)"], location: "Body", severity: "moderate" },
          "76-80": { name: "Fractured Hip", wounds: 4, effects: "Gain 1 Stunned. Challenging (+0) Endurance Test or Prone. Broken Bone (Minor)", conditions: ["Stunned"], injuries: ["Broken Bone (Minor)"], location: "Body", severity: "severe" },
          "81-85": { name: "Major Chest Wound", wounds: 4, effects: "Gain 4 Bleeding. Until Surgery, body damage causes 2 extra Bleeding", conditions: ["Bleeding", "Bleeding", "Bleeding", "Bleeding"], location: "Body", severity: "severe" },
          "86-90": { name: "Gut Wound", wounds: 4, effects: "Contract Festering Wound disease, gain 2 Bleeding", conditions: ["Bleeding", "Bleeding"], diseases: ["Festering Wound"], location: "Body", severity: "severe" },
          "91-95": { name: "Smashed Rib Cage", wounds: 5, effects: "Gain 1 Stunned (Medical Attention only). Broken Bone (Major)", conditions: ["Stunned"], injuries: ["Broken Bone (Major)"], location: "Body", severity: "severe" },
          "96-110": { name: "Broken Collar Bone", wounds: 5, effects: "Gain Unconscious until Medical Attention. Broken Bone (Major)", conditions: ["Unconscious"], injuries: ["Broken Bone (Major)"], location: "Body", severity: "severe" },
          "111-115": { name: "Internal Bleeding", wounds: 5, effects: "Gain 1 Bleeding (Surgery only). Contract Blood Rot disease", conditions: ["Bleeding"], diseases: ["Blood Rot"], location: "Body", severity: "severe" },
          "116+": { name: "Torn Apart", wounds: "Death", effects: "Hacked in two. Top half lands randomly, blood showers nearby", fatal: true, location: "Body", severity: "fatal" }
        };

        const legCriticalWounds = {
          "01-10": { name: "Stubbed Toe", wounds: "T", effects: "Average (+20) Endurance Test or -10 Agility Tests until end of next turn", location: "Leg", severity: "minor" },
          "11-20": { name: "Lost Footing", wounds: "T", effects: "Challenging (+0) Athletics Test or gain Prone Condition", location: "Leg", severity: "minor" },
          "21-25": { name: "Twisted Ankle", wounds: 1, effects: "Agility Tests -10 penalty for 1d10 rounds", temporaryEffects: ["-10 Agility Tests"], location: "Leg", severity: "minor" },
          "26-40": { name: "Minor Cut", wounds: 1, effects: "Gain 1 Bleeding Condition", conditions: ["Bleeding"], location: "Leg", severity: "minor" },
          "41-45": { name: "Thigh Strike", wounds: 1, effects: "Gain 1 Bleeding. Average (+20) Endurance Test or Prone", conditions: ["Bleeding"], location: "Leg", severity: "minor" },
          "46-50": { name: "Sprained Ankle", wounds: 1, effects: "Torn Muscle (Minor) injury", injuries: ["Torn Muscle (Minor)"], location: "Leg", severity: "minor" },
          "51-55": { name: "Twisted Knee", wounds: 2, effects: "Agility Tests -20 penalty for 1d10 Rounds", temporaryEffects: ["-20 Agility Tests"], location: "Leg", severity: "minor" },
          "56-60": { name: "Badly Cut Toe", wounds: 2, effects: "Gain 1 Bleeding. After encounter, Challenging (+0) Endurance Test or lose 1 toe", conditions: ["Bleeding"], location: "Leg", severity: "minor" },
          "61-65": { name: "Bad Cut", wounds: 2, effects: "Gain 2 Bleeding. Challenging (+0) Endurance Test or Prone", conditions: ["Bleeding", "Bleeding"], location: "Leg", severity: "minor" },
          "66-70": { name: "Badly Twisted Knee", wounds: 2, effects: "Torn Muscle (Major) injury", injuries: ["Torn Muscle (Major)"], location: "Leg", severity: "moderate" },
          "71-75": { name: "Hacked Leg", wounds: 3, effects: "Gain 1 Prone, 2 Bleeding, Broken Bone (Minor)", conditions: ["Prone", "Bleeding", "Bleeding"], injuries: ["Broken Bone (Minor)"], location: "Leg", severity: "moderate" },
          "76-80": { name: "Torn Thigh", wounds: 3, effects: "Gain 3 Bleeding. Until Surgery, leg damage causes extra Bleeding", conditions: ["Bleeding", "Bleeding", "Bleeding"], location: "Leg", severity: "moderate" },
          "81-85": { name: "Ruptured Tendon", wounds: 3, effects: "Gain 1 Prone, 1 Stunned. Hard (-20) Endurance Test or Unconscious. Leg useless, Torn Muscle (Major)", conditions: ["Prone", "Stunned"], injuries: ["Torn Muscle (Major)"], location: "Leg", severity: "moderate" },
          "86-90": { name: "Cracked Shin", wounds: 4, effects: "Gain 1 Stunned, 1 Prone, Torn Muscle (Major), Broken Bone (Minor)", conditions: ["Stunned", "Prone"], injuries: ["Torn Muscle (Major)", "Broken Bone (Minor)"], location: "Leg", severity: "severe" },
          "91-95": { name: "Broken Knee", wounds: 4, effects: "Gain 1 Bleeding, 1 Prone, 1 Stunned, Broken Bone (Major)", conditions: ["Bleeding", "Prone", "Stunned"], injuries: ["Broken Bone (Major)"], location: "Leg", severity: "severe" },
          "96-105": { name: "Dislocated Knee", wounds: 4, effects: "Gain Prone. Hard (-20) Endurance Test or Stunned (Medical Attention only). Extended Heal Test (6 SL) resets knee. Movement halved, -10 penalty 1d10 days", conditions: ["Prone"], location: "Leg", severity: "severe" },
          "106-115": { name: "Crushed Foot", wounds: 4, effects: "Average (+20) Endurance Test or Prone and lose toes (1 + SL below 0). Gain 2 Bleeding. Surgery within 1d10 days or lose foot", conditions: ["Bleeding", "Bleeding"], location: "Leg", severity: "severe" },
          "116-120": { name: "Severed Foot", wounds: 5, effects: "Foot severed - Amputation (Hard). Gain 3 Bleeding, 2 Stunned, 1 Prone", conditions: ["Bleeding", "Bleeding", "Bleeding", "Stunned", "Stunned", "Prone"], amputations: ["Foot"], location: "Leg", severity: "severe" },
          "121-125": { name: "Cut Tendon", wounds: 5, effects: "Leg collapses. Gain 2 Bleeding, 2 Stunned, 1 Prone. Leg never works again - Amputation (Very Hard)", conditions: ["Bleeding", "Bleeding", "Stunned", "Stunned", "Prone"], location: "Leg", severity: "severe" },
          "126+": { name: "Shattered Pelvis", wounds: "Death", effects: "Pelvis shattered, leg severed. Die instantly from trauma", fatal: true, location: "Leg", severity: "fatal" }
        };

        // Combined critical wounds object for compatibility
        const wfrpCriticalWounds = {
          ...Object.fromEntries(Object.entries(headCriticalWounds).map(([key, wound]) => [`head_${key.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`, wound])),
          ...Object.fromEntries(Object.entries(armCriticalWounds).map(([key, wound]) => [`arm_${key.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`, wound])),
          ...Object.fromEntries(Object.entries(bodyCriticalWounds).map(([key, wound]) => [`body_${key.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`, wound])),
          ...Object.fromEntries(Object.entries(legCriticalWounds).map(([key, wound]) => [`leg_${key.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`, wound]))
        };

        const wfrpCriticalWoundsByLocation = {
          "Head": headCriticalWounds,
          "Arm": armCriticalWounds, 
          "Body": bodyCriticalWounds,
          "Leg": legCriticalWounds
        };
        // Official WFRP Injury Types and Healing Mechanics
        const injuryTypes = {
          "Broken Bone (Minor)": {
            effects: { 
              "Head": "-30 Language Tests", 
              "Body": "-30 Str/Agi, half Move", 
              "Arm": "Unusable as lost limb", 
              "Leg": "Unusable as lost limb" 
            },
            healing: "30+1d10 days, Average (+20) Endurance Test or permanent -5 penalty"
          },
          "Broken Bone (Major)": {
            effects: { 
              "Head": "-30 Language Tests", 
              "Body": "-30 Str/Agi, half Move", 
              "Arm": "Unusable as lost limb", 
              "Leg": "Unusable as lost limb" 
            },
            healing: "40+1d10 days, Challenging (+0) Endurance Test or permanent -10 penalty"
          },
          "Torn Muscle (Minor)": {
            effects: { 
              "general": "-10 Tests using location", 
              "Leg": "-10 Tests, half Movement" 
            },
            healing: "30-TB days"
          },
          "Torn Muscle (Major)": {
            effects: { 
              "general": "-20 Tests using location", 
              "Leg": "-20 Tests, half Movement" 
            },
            healing: "30-TB days (-20), then 30-TB days (-10)"
          }
        };

        const amputationEffects = {
          "Finger": "-5 Tests per finger lost, fumble on 1s (cumulative)",
          "Hand": "-20 two-handed Tests, cannot use two-handed weapons, -20 if primary hand",
          "Arm": "As hand but cannot strap shield",
          "Foot": "Half Move, -20 mobility Tests",
          "Leg": "As foot but cannot Dodge",
          "Eye": "-30 sight Tests if both lost, -5 Fellowship per socket visible",
          "Ear": "-20 hearing Tests if both lost, -5 Fellowship per ear lost when visible",
          "Nose": "-20 Fellowship, -30 smell Tests",
          "Tongue": "Auto-fail spoken Language Tests",
          "Teeth": "-1 Fellowship per 2 teeth lost"
        };

        // WFRP 4th Edition Corruption & Mutation System
        const physicalMutations = {
          "01-05": {
            name: "Animalistic Legs",
            description: "Your legs become those of a goat, with hooves",
            effect: "Move +1, obvious mutation affecting social interactions",
            modifiers: { movement: 1 },
            obvious: true,
            fellowshipImpact: "Disturbing animal legs cause fear and revulsion in civilized folk"
          },
          "06-10": {
            name: "Bestial Face", 
            description: "Face becomes that of a dog or wolf",
            effect: "Intimidate +10, obvious mutation affecting social interactions",
            modifiers: { intimidate: 10 },
            obvious: true,
            fellowshipImpact: "Bestial features mark you as touched by Chaos"
          },
          "11-15": {
            name: "Big Ears",
            description: "Ears grow to twice normal size",
            effect: "Perception +10 for hearing, obvious mutation",
            modifiers: { perception: 10 },
            obvious: true,
            fellowshipImpact: "Enlarged ears draw unwanted attention and mockery"
          },
          "16-20": {
            name: "Bulging Eyes",
            description: "Eyes bulge unnaturally from their sockets",
            effect: "Perception +5, obvious mutation affecting appearance",
            modifiers: { perception: 5 },
            obvious: true,
            fellowshipImpact: "Grotesque eyes unnerve those who look upon you"
          },
          "21-25": {
            name: "Chaos Organ",
            description: "Develop a new organ with unknown function",
            effect: "No immediate mechanical effect, obvious if exposed",
            modifiers: {},
            obvious: false,
            fellowshipImpact: "Hidden unless revealed, then causes horror",
            special: "GM determines organ's eventual effect"
          },
          "26-30": {
            name: "Claws",
            description: "Fingernails become razor-sharp claws",
            effect: "Unarmed attacks gain +1 damage, obvious mutation",
            modifiers: { unarmedDamage: 1 },
            obvious: true,
            fellowshipImpact: "Predatory claws mark you as dangerous"
          },
          "31-35": {
            name: "Disturbing Grace",
            description: "Move with unnaturally fluid, hypnotic motion",
            effect: "Agility +5, but unsettling to watch",
            modifiers: { agility: 5 },
            obvious: true,
            fellowshipImpact: "Uncanny movements make others deeply uncomfortable"
          },
          "36-40": {
            name: "Extra Mouth",
            description: "Additional mouth appears somewhere on body",
            effect: "Can speak/eat simultaneously, obvious mutation",
            modifiers: {},
            obvious: true,
            fellowshipImpact: "Extra mouth horrifies and disgusts witnesses"
          },
          "41-45": {
            name: "Inhuman Beauty",
            description: "Beauty becomes perfect but cold and alien",
            effect: "Fellowship +10, but something feels wrong",
            modifiers: { fellowship: 10 },
            obvious: false,
            fellowshipImpact: "Attracts attention but causes unease in long interactions",
            special: "Not immediately obvious as mutation"
          },
          "46-50": {
            name: "Iron Skin",
            description: "Skin becomes metallic and hard",
            effect: "Toughness +5, obvious metallic appearance",
            modifiers: { toughness: 5 },
            obvious: true,
            fellowshipImpact: "Metallic skin marks you as clearly inhuman"
          },
          "51-55": {
            name: "Long Limbs",
            description: "Arms and legs grow unnaturally long",
            effect: "Reach increases by one step, obvious mutation",
            modifiers: { reach: 1 },
            obvious: true,
            fellowshipImpact: "Distorted proportions cause fear and disgust"
          },
          "56-60": {
            name: "Moronic",
            description: "Intelligence diminishes significantly",
            effect: "Intelligence -10, speech becomes simple",
            modifiers: { intelligence: -10 },
            obvious: true,
            fellowshipImpact: "Reduced mental capacity obvious in speech and behavior"
          },
          "61-65": {
            name: "Pin Head",
            description: "Head shrinks to tiny proportions",
            effect: "Intelligence -5, obvious physical deformity",
            modifiers: { intelligence: -5 },
            obvious: true,
            fellowshipImpact: "Grotesquely small head causes revulsion and mockery"
          },
          "66-70": {
            name: "Pointed Head",
            description: "Skull elongates into cone shape",
            effect: "Must modify all headwear, obvious mutation",
            modifiers: {},
            obvious: true,
            fellowshipImpact: "Distinctive head shape impossible to hide"
          },
          "71-75": {
            name: "Rotting Flesh",
            description: "Flesh constantly decays and regenerates",
            effect: "Toughness +5 but Fellowship -10, nauseating odor",
            modifiers: { toughness: 5, fellowship: -10 },
            obvious: true,
            fellowshipImpact: "Rotting stench and appearance cause immediate revulsion",
            special: "Cannot scar from wounds"
          },
          "76-80": {
            name: "Short Limbs",
            description: "Arms and legs shrink to half normal length",
            effect: "Move -1, obvious physical limitation",
            modifiers: { movement: -1 },
            obvious: true,
            fellowshipImpact: "Stunted limbs mark you as cursed by Chaos"
          },
          "81-85": {
            name: "Silly Voice",
            description: "Voice becomes high-pitched and ridiculous",
            effect: "Intimidate -20, Charm +5 (disarming)",
            modifiers: { intimidate: -20, charm: 5 },
            obvious: true,
            fellowshipImpact: "Impossible to be taken seriously in formal situations"
          },
          "86-90": {
            name: "Thorny Scales",
            description: "Skin develops sharp, thorny scales",
            effect: "Armor +1 AP, Agility -5, opponents take damage when grappling",
            modifiers: { armor: 1, agility: -5 },
            obvious: true,
            fellowshipImpact: "Inhuman scaled appearance causes fear"
          },
          "91-95": {
            name: "Transparent Skin",
            description: "Skin becomes see-through, showing internal organs",
            effect: "Disguise impossible, nauseating to behold",
            modifiers: {},
            obvious: true,
            fellowshipImpact: "Horrifying transparency causes immediate revulsion"
          },
          "96-100": {
            name: "Withered Limb",
            description: "One limb becomes useless and withered",
            effect: "Lose use of random limb until healed",
            modifiers: {},
            obvious: true,
            fellowshipImpact: "Withered limb marks divine punishment or curse",
            special: "GM determines which limb is affected"
          }
        };

        const mentalCorruptions = {
          "01-10": {
            name: "Aggression",
            description: "Become increasingly violent and hostile",
            effect: "Difficulty controlling anger, prone to violence",
            modifiers: {},
            obvious: false,
            mentalEffect: "Must pass WP test to avoid violence when provoked"
          },
          "11-20": {
            name: "Animosity",
            description: "Develop irrational hatred for specific group",
            effect: "Cannot help but antagonize chosen group",
            modifiers: {},
            obvious: false,
            mentalEffect: "Compelled to act against hated group",
            special: "GM determines target of animosity"
          },
          "21-30": {
            name: "Blasphemous Rage",
            description: "Uncontrollable urge to desecrate holy sites",
            effect: "Cannot resist defiling religious symbols",
            modifiers: {},
            obvious: false,
            mentalEffect: "Must deface religious imagery when encountered"
          },
          "31-40": {
            name: "Cowardice",
            description: "Overwhelming fear in face of danger",
            effect: "Take Fear from situations others find normal",
            modifiers: {},
            obvious: false,
            mentalEffect: "Gain Fear condition in combat situations"
          },
          "41-50": {
            name: "Frenzy",
            description: "Enter uncontrollable violent rage",
            effect: "Risk entering Frenzy in stressful situations",
            modifiers: {},
            obvious: false,
            mentalEffect: "May gain Frenzy condition when stressed"
          },
          "51-60": {
            name: "Prejudice",
            description: "Develop extreme prejudice against group",
            effect: "Cannot interact normally with chosen group",
            modifiers: {},
            obvious: false,
            mentalEffect: "Fellowship -20 with prejudiced group",
            special: "GM determines target of prejudice"
          },
          "61-70": {
            name: "Compulsion",
            description: "Compelled to perform specific ritual behavior",
            effect: "Must perform compulsion regularly or suffer penalties",
            modifiers: {},
            obvious: false,
            mentalEffect: "Take -10 to all tests if compulsion not performed",
            special: "GM determines nature of compulsion"
          },
          "71-80": {
            name: "Paranoia",
            description: "Everyone is plotting against you",
            effect: "Cannot trust anyone completely",
            modifiers: {},
            obvious: false,
            mentalEffect: "Difficulty accepting help or working in groups"
          },
          "81-90": {
            name: "Phobia",
            description: "Develop crippling fear of common thing",
            effect: "Take Terror from specific stimulus",
            modifiers: {},
            obvious: false,
            mentalEffect: "Gain Terror condition when phobia triggered",
            special: "GM determines object of phobia"
          },
          "91-100": {
            name: "Corruption of Form",
            description: "Mind becomes alien and inhuman",
            effect: "Gradually lose human thought patterns",
            modifiers: {},
            obvious: false,
            mentalEffect: "Increasingly inhuman decision making"
          }
        };

        const speciesMutationTables = {
          "Human": { physical: "01-50", mental: "51-100" },
          "Dwarf": { physical: "01-05", mental: "06-100" },
          "Halfling": { physical: "01-10", mental: "11-100" },
          "High Elf": { physical: "01-00", mental: "01-100" },
          "Wood Elf": { physical: "01-00", mental: "01-100" }
        };

        // WFRP Talent Limitations - talents limited by characteristic bonuses
        const talentLimitations = {
          "Hardy": "toughnessBonus",
          "Savvy": "intelligenceBonus", 
          "Luck": "willpowerBonus",
          "Sharp": "intelligenceBonus",
          "Strong Back": "strengthBonus",
          "Flee!": "agilityBonus",
          "Very Strong": "strengthBonus", 
          "Lightning Reflexes": "agilityBonus",
          "Sturdy": "strengthBonus",
          "Iron Jaw": "toughnessBonus",
          "Iron Will": "willpowerBonus",
          "Coolheaded": "willpowerBonus",
          "Fast Hands": "dexterityBonus",
          "Very Fast": "agilityBonus",
          "Nimble Fingered": "dexterityBonus",
          "Night Vision": "intelligenceBonus",
          "Acute Sense": "intelligenceBonus",
          "Perfect Pitch": "intelligenceBonus",
          "Artistic": "dexterityBonus",
          "Strong-minded": "willpowerBonus",
          "Resistance": "toughnessBonus",
          "Magic Resistance": "willpowerBonus",
          "Specialist Weapon Group": "strengthBonus",
          "Weapon Master": "weaponSkillBonus",
          "Ambidextrous": "dexterityBonus",
          "Combat Reflexes": "agilityBonus"
        };

        let talents = [];
        let srdTalents = [];
        let activeConditions = [];
        let srdConditions = [];
        let criticalWounds = []; // Active character critical wounds
        let spells = [];
        let srdSpells = [];
        
        // Disease management
        let diseaseIdCounter = 1;

        // SRD Data (will be loaded from JSON files)
        let srdWeapons = [];
        let srdArmour = [];
        let srdAmmunition = [];
        let srdDiseases = [];
        let srdSymptoms = [];

        // Class trappings data for class trappings wizard
        const classTrappings = {
            "Academic": {
                fixed: ["Clothing", "Dagger", "Pouch", "Sling Bag", "Writing Kit"],
                rolls: [
                    {item: "Parchment", dice: "1d10", unit: "sheets"}
                ]
            },
            "Burgher": {
                fixed: ["Cloak", "Clothing", "Dagger", "Hat", "Pouch", "Sling Bag", "Lunch"]
            },
            "Courtier": {
                fixed: ["Dagger", "Fine Clothing", "Pouch", "Tweezers", "Ear Pick", "Comb"]
            },
            "Peasant": {
                fixed: ["Cloak", "Clothing", "Dagger", "Pouch", "Sling Bag", "Rations (1 day)"]
            },
            "Ranger": {
                fixed: ["Cloak", "Clothing", "Dagger", "Pouch", "Backpack", "Tinderbox", "Blanket", "Rations (1 day)"]
            },
            "Riverfolk": {
                fixed: ["Cloak", "Clothing", "Dagger", "Pouch", "Sling Bag", "Flask of Spirits"]
            },
            "Rogue": {
                fixed: ["Clothing", "Dagger", "Pouch", "Sling Bag", "2 Candles"],
                rolls: [
                    {item: "Matches", dice: "1d10", unit: ""}
                ],
                choices: [
                    {choose: 1, from: ["Hood", "Mask"]}
                ]
            },
            "Warrior": {
                fixed: ["Clothing", "Hand Weapon", "Dagger", "Pouch"]
            }
        };

        // Species data for character creation wizard
        const speciesData = {
            "Human": {
                characteristics: {
                    "WS": { base: 20, min: 22, max: 40 },
                    "BS": { base: 20, min: 22, max: 40 },
                    "S": { base: 20, min: 22, max: 40 },
                    "T": { base: 20, min: 22, max: 40 },
                    "I": { base: 20, min: 22, max: 40 },
                    "Ag": { base: 20, min: 22, max: 40 },
                    "Dex": { base: 20, min: 22, max: 40 },
                    "Int": { base: 20, min: 22, max: 40 },
                    "WP": { base: 20, min: 22, max: 40 },
                    "Fel": { base: 20, min: 22, max: 40 }
                },
                skills: [
                    "Animal Care", "Charm", "Cool", "Evaluate", "Gossip", "Haggle", 
                    "Language (Bretonnian)", "Language (Wastelander)", "Leadership", 
                    "Lore (Reikland)", "Melee (Basic)", "Ranged (Bow)"
                ],
                talents: [
                    "Savvy", "Suave", "Acute Sense (any one)", "Ambidextrous", "Animal Affinity", 
                    "Artistic", "Attractive", "Coolheaded", "Craftsman (any one)", "Flee!", 
                    "Hardy", "Lightning Reflexes", "Linguistics", "Luck", "Marksman", 
                    "Mimic", "Night Vision", "Nimble Fingered", "Noble Blood", 
                    "Orientation", "Perfect Pitch", "Pure Soul", "Read/Write", 
                    "Resistance (any one)", "Savvy", "Sharp", "Sixth Sense", "Super Numerate", 
                    "Strong Legs", "Sturdy", "Suave", "Very Resilient", "Very Strong", "Warrior Born"
                ],
                baseFate: 2,
                baseResilience: 1,
                extraPoints: 3,
                movement: 4,
                woundsFormula: "SB + (2 Ã— TB) + WPB",
                fixedTalents: ["Doomed"],
                talentChoices: [
                    {
                        description: "Choose one:",
                        options: ["Savvy", "Suave"]
                    },
                    {
                        description: "Choose three talents:",
                        options: [
                            "Acute Sense (any one)", "Ambidextrous", "Animal Affinity", "Artistic", 
                            "Attractive", "Coolheaded", "Craftsman (any one)", "Flee!", "Hardy", 
                            "Lightning Reflexes", "Linguistics", "Luck", "Marksman", "Mimic", 
                            "Night Vision", "Nimble Fingered", "Noble Blood", "Orientation", 
                            "Perfect Pitch", "Pure Soul", "Read/Write", "Resistance (any one)", 
                            "Savvy", "Sharp", "Sixth Sense", "Strong Legs", "Sturdy", "Suave", 
                            "Super Numerate", "Very Resilient", "Very Strong", "Warrior Born"
                        ],
                        multiple: true,
                        count: 3
                    }
                ]
            },
            "Dwarf": {
                characteristics: {
                    "WS": { base: 30, min: 32, max: 50 },
                    "BS": { base: 20, min: 22, max: 40 },
                    "S": { base: 20, min: 22, max: 40 },
                    "T": { base: 30, min: 32, max: 50 },
                    "I": { base: 20, min: 22, max: 40 },
                    "Ag": { base: 10, min: 12, max: 30 },
                    "Dex": { base: 30, min: 32, max: 50 },
                    "Int": { base: 20, min: 22, max: 40 },
                    "WP": { base: 40, min: 42, max: 60 },
                    "Fel": { base: 10, min: 12, max: 30 }
                },
                skills: [
                    "Consume Alcohol", "Cool", "Endurance", "Entertain (Storytelling)", 
                    "Intimidate", "Language (Khazalid)", "Lore (Dwarfs)", "Lore (Geology)", 
                    "Lore (Metallurgy)", "Melee (Basic)", "Ranged (Crossbow)", "Trade (any)"
                ],
                talents: [
                    "Read/Write", "Relentless", "Resolute", "Strong Minded"
                ],
                baseFate: 0,
                baseResilience: 2,
                extraPoints: 2,
                movement: 3,
                woundsFormula: "SB + (2 Ã— TB) + WPB",
                fixedTalents: ["Magic Resistance", "Night Vision", "Sturdy"],
                talentChoices: [
                    {
                        description: "Choose one:",
                        options: ["Read/Write", "Relentless"]
                    },
                    {
                        description: "Choose one:",
                        options: ["Resolute", "Strong Minded"]
                    }
                ]
            },
            "Halfling": {
                characteristics: {
                    "WS": { base: 10, min: 12, max: 30 },
                    "BS": { base: 30, min: 32, max: 50 },
                    "S": { base: 10, min: 12, max: 30 },
                    "T": { base: 20, min: 22, max: 40 },
                    "I": { base: 20, min: 22, max: 40 },
                    "Ag": { base: 20, min: 22, max: 40 },
                    "Dex": { base: 30, min: 32, max: 50 },
                    "Int": { base: 20, min: 22, max: 40 },
                    "WP": { base: 30, min: 32, max: 50 },
                    "Fel": { base: 30, min: 32, max: 50 }
                },
                skills: [
                    "Charm", "Consume Alcohol", "Cool", "Dodge", "Gamble", "Gossip", 
                    "Haggle", "Language (Halfling)", "Lore (Reikland)", "Perception", 
                    "Sleight of Hand", "Stealth (Rural)"
                ],
                baseFate: 0,
                baseResilience: 2,
                extraPoints: 3,
                movement: 3,
                woundsFormula: "(2 Ã— TB) + WPB",
                fixedTalents: ["Acute Sense (Taste)", "Night Vision", "Resistance (Chaos)", "Small"],
                talentChoices: [
                    {
                        description: "Choose two talents:",
                        options: [
                            "Acute Sense (any one)", "Ambidextrous", "Animal Affinity", "Artistic", 
                            "Attractive", "Coolheaded", "Craftsman (any one)", "Flee!", "Hardy", 
                            "Lightning Reflexes", "Linguistics", "Luck", "Marksman", "Mimic", 
                            "Night Vision", "Nimble Fingered", "Noble Blood", "Orientation", 
                            "Perfect Pitch", "Pure Soul", "Read/Write", "Resistance (any one)", 
                            "Savvy", "Sharp", "Sixth Sense", "Strong Legs", "Sturdy", "Suave", 
                            "Super Numerate", "Very Resilient", "Very Strong", "Warrior Born"
                        ],
                        multiple: true,
                        count: 2
                    }
                ]
            },
            "High Elf": {
                characteristics: {
                    "WS": { base: 30, min: 32, max: 50 },
                    "BS": { base: 30, min: 32, max: 50 },
                    "S": { base: 20, min: 22, max: 40 },
                    "T": { base: 20, min: 22, max: 40 },
                    "I": { base: 40, min: 42, max: 60 },
                    "Ag": { base: 30, min: 32, max: 50 },
                    "Dex": { base: 30, min: 32, max: 50 },
                    "Int": { base: 30, min: 32, max: 50 },
                    "WP": { base: 30, min: 32, max: 50 },
                    "Fel": { base: 20, min: 22, max: 40 }
                },
                skills: [
                    "Athletics", "Climb", "Cool", "Evaluate", "Language (Eltharin)", 
                    "Leadership", "Melee (Basic)", "Navigation", "Perception", 
                    "Play (any)", "Ranged (Bow)", "Sail"
                ],
                talents: [
                    "Coolheaded", "Savvy", "Second Sight", "Sixth Sense"
                ],
                baseFate: 0,
                baseResilience: 0,
                extraPoints: 2,
                movement: 5,
                woundsFormula: "SB + (2 Ã— TB) + WPB",
                fixedTalents: ["Acute Sense (Sight)", "Night Vision", "Read/Write"],
                talentChoices: [
                    {
                        description: "Choose one:",
                        options: ["Coolheaded", "Savvy"]
                    },
                    {
                        description: "Choose one:",
                        options: ["Second Sight", "Sixth Sense"]
                    }
                ]
            },
            "Wood Elf": {
                characteristics: {
                    "WS": { base: 30, min: 32, max: 50 },
                    "BS": { base: 30, min: 32, max: 50 },
                    "S": { base: 20, min: 22, max: 40 },
                    "T": { base: 20, min: 22, max: 40 },
                    "I": { base: 40, min: 42, max: 60 },
                    "Ag": { base: 30, min: 32, max: 50 },
                    "Dex": { base: 30, min: 32, max: 50 },
                    "Int": { base: 30, min: 32, max: 50 },
                    "WP": { base: 30, min: 32, max: 50 },
                    "Fel": { base: 20, min: 22, max: 40 }
                },
                skills: [
                    "Athletics", "Climb", "Endurance", "Entertain (Storytelling)", 
                    "Intimidate", "Language (Eltharin)", "Lore (Spirits)", "Melee (Basic)", 
                    "Outdoor Survival", "Perception", "Ranged (Bow)", "Stealth (Rural)"
                ],
                talents: [
                    "Hardy", "Second Sight", "Read/Write", "Very Resilient"
                ],
                baseFate: 0,
                baseResilience: 0,
                extraPoints: 2,
                movement: 5,
                woundsFormula: "SB + (2 Ã— TB) + WPB",
                fixedTalents: ["Acute Sense (Sight)", "Night Vision", "Rover"],
                talentChoices: [
                    {
                        description: "Choose one:",
                        options: ["Hardy", "Second Sight"]
                    },
                    {
                        description: "Choose one:",
                        options: ["Read/Write", "Very Resilient"]
                    }
                ]
            }
        };

        // Define all available skills
        const allSkills = [
            // Basic Skills
            { name: "Art", characteristic: "Dex", type: "Basic", grouped: true },
            { name: "Athletics", characteristic: "Ag", type: "Basic", grouped: false },
            { name: "Bribery", characteristic: "Fel", type: "Basic", grouped: false },
            { name: "Charm", characteristic: "Fel", type: "Basic", grouped: false },
            { name: "Charm Animal", characteristic: "WP", type: "Basic", grouped: false },
            { name: "Climb", characteristic: "S", type: "Basic", grouped: false },
            { name: "Cool", characteristic: "WP", type: "Basic", grouped: false },
            { name: "Consume Alcohol", characteristic: "T", type: "Basic", grouped: false },
            { name: "Dodge", characteristic: "Ag", type: "Basic", grouped: false },
            { name: "Drive", characteristic: "Ag", type: "Basic", grouped: false },
            { name: "Endurance", characteristic: "T", type: "Basic", grouped: false },
            { name: "Entertain", characteristic: "Fel", type: "Basic", grouped: true },
            { name: "Gamble", characteristic: "Int", type: "Basic", grouped: false },
            { name: "Gossip", characteristic: "Fel", type: "Basic", grouped: false },
            { name: "Haggle", characteristic: "Fel", type: "Basic", grouped: false },
            { name: "Intimidate", characteristic: "S", type: "Basic", grouped: false },
            { name: "Intuition", characteristic: "I", type: "Basic", grouped: false },
            { name: "Leadership", characteristic: "Fel", type: "Basic", grouped: false },
            { name: "Melee", characteristic: "WS", type: "Basic", grouped: true },
            { name: "Navigation", characteristic: "I", type: "Basic", grouped: false },
            { name: "Outdoor Survival", characteristic: "Int", type: "Basic", grouped: false },
            { name: "Perception", characteristic: "I", type: "Basic", grouped: false },
            { name: "Ride", characteristic: "Ag", type: "Basic", grouped: true },
            { name: "Row", characteristic: "S", type: "Basic", grouped: false },
            { name: "Stealth", characteristic: "Ag", type: "Basic", grouped: true },
            
            // Advanced Skills
            { name: "Animal Care", characteristic: "Int", type: "Advanced", grouped: false },
            { name: "Animal Training", characteristic: "Int", type: "Advanced", grouped: true },
            { name: "Channelling", characteristic: "WP", type: "Advanced", grouped: true },
            { name: "Evaluate", characteristic: "Int", type: "Advanced", grouped: false },
            { name: "Heal", characteristic: "Int", type: "Advanced", grouped: false },
            { name: "Language", characteristic: "Int", type: "Advanced", grouped: true },
            { name: "Lore", characteristic: "Int", type: "Advanced", grouped: true },
            { name: "Perform", characteristic: "Ag", type: "Advanced", grouped: true },
            { name: "Pick Lock", characteristic: "Dex", type: "Advanced", grouped: false },
            { name: "Play", characteristic: "Dex", type: "Advanced", grouped: true },
            { name: "Pray", characteristic: "Fel", type: "Advanced", grouped: false },
            { name: "Ranged", characteristic: "BS", type: "Advanced", grouped: true },
            { name: "Research", characteristic: "Int", type: "Advanced", grouped: false },
            { name: "Sail", characteristic: "Ag", type: "Advanced", grouped: false },
            { name: "Secret Signs", characteristic: "Int", type: "Advanced", grouped: true },
            { name: "Set Trap", characteristic: "Dex", type: "Advanced", grouped: false },
            { name: "Sleight of Hand", characteristic: "Dex", type: "Advanced", grouped: false },
            { name: "Swim", characteristic: "S", type: "Advanced", grouped: false },
            { name: "Track", characteristic: "I", type: "Advanced", grouped: false },
            { name: "Trade", characteristic: "Dex", type: "Advanced", grouped: true }
        ];

        // Get default basic skills (ungrouped only)
        function getDefaultSkills() {
            return allSkills.filter(skill => skill.type === "Basic" && !skill.grouped);
        }

        // Auto-calculate current characteristics
        const characteristics = ['ws', 'bs', 's', 't', 'i', 'agi', 'dex', 'int', 'wp', 'fel'];
        
        characteristics.forEach(char => {
            const initial = document.getElementById(`${char}-initial`);
            const advances = document.getElementById(`${char}-advances`);
            const current = document.getElementById(`${char}-current`);
            
            function updateCurrent() {
                const init = parseInt(initial.value) || 0;
                const adv = parseInt(advances.value) || 0;
                let currentValue = init + adv;
                let penalties = [];
                let totalPenalty = 0;
                
                // Apply encumbrance penalty to Agility
                if (char === 'agi') {
                    const encStatus = document.getElementById('enc-status');
                    const agilityPenalty = parseInt(encStatus?.getAttribute('data-agility-penalty') || 0);
                    
                    if (agilityPenalty > 0) {
                        // Apply penalty with minimum of 10 for triple encumbrance
                        if (agilityPenalty === 20) {
                            currentValue = Math.max(10, currentValue - agilityPenalty);
                        } else {
                            currentValue = currentValue - agilityPenalty;
                        }
                        penalties.push(`Encumbrance: -${agilityPenalty}`);
                        totalPenalty += agilityPenalty;
                    }
                }
                
                // Apply critical wound penalties
                if (typeof window.getCriticalWoundPenalties === 'function') {
                    const woundPenalties = window.getCriticalWoundPenalties();
                    const charMap = {
                        'ws': 'WS', 'bs': 'BS', 's': 'S', 't': 'T', 'i': 'I', 
                        'agi': 'Ag', 'dex': 'Dex', 'int': 'Int', 'wp': 'WP', 'fel': 'Fel'
                    };
                    
                    const mappedChar = charMap[char];
                    if (woundPenalties.characteristics[mappedChar]) {
                        const woundPenalty = Math.abs(woundPenalties.characteristics[mappedChar]);
                        currentValue = Math.max(0, currentValue - woundPenalty);
                        penalties.push(`Critical Wounds: -${woundPenalty}`);
                        totalPenalty += woundPenalty;
                    }
                }
                
                // Apply symptom penalties
                if (typeof window.getSymptomPenalties === 'function') {
                    const symptomPenalties = window.getSymptomPenalties();
                    const charMap = {
                        'ws': 'WS', 'bs': 'BS', 's': 'S', 't': 'T', 'i': 'I', 
                        'agi': 'Ag', 'dex': 'Dex', 'int': 'Int', 'wp': 'WP', 'fel': 'Fel'
                    };
                    
                    const mappedChar = charMap[char];
                    if (symptomPenalties.characteristics[mappedChar]) {
                        const symptomPenalty = Math.abs(symptomPenalties.characteristics[mappedChar]);
                        currentValue = Math.max(0, currentValue - symptomPenalty);
                        penalties.push(`Symptoms: -${symptomPenalty}`);
                        totalPenalty += symptomPenalty;
                    }
                }
                
                // Update display styling and tooltips
                if (totalPenalty > 0) {
                    current.style.color = 'red';
                    current.title = `Base: ${init + adv}, ${penalties.join(', ')}`;
                } else if (char !== 'agi') { // Don't clear agi styling if it was set by encumbrance
                    current.style.color = '';
                    current.title = '';
                }
                
                current.value = currentValue;
                
                // Update all skill totals when characteristics change
                updateAllSkillTotals();
                
                // Update XP cost displays
                if (window.updateAdvanceCosts) {
                    window.updateAdvanceCosts();
                }
                
                // Update talent limits display when characteristics change
                if (typeof window.updateTalentLimitsDisplay === 'function') {
                    window.updateTalentLimitsDisplay();
                }
                
                // Update max wounds when strength, toughness, or willpower change
                if (char === 's' || char === 't' || char === 'wp') {
                    if (typeof window.updateMaxWounds === 'function') {
                        window.updateMaxWounds();
                    }
                }
                
                // Update corruption threshold when willpower or toughness change
                if (char === 'wp' || char === 't') {
                    if (typeof window.updateCorruptionThreshold === 'function') {
                        window.updateCorruptionThreshold();
                    }
                }
                
                // Update encumbrance when Strength or Toughness changes
                if (char === 's' || char === 't') {
                    updateEncumbrance();
                }
            }
            
            initial.addEventListener('input', updateCurrent);
            advances.addEventListener('input', updateCurrent);
            
            // Store the update function for later use
            current.updateFunction = updateCurrent;
        });

        // Auto-update max displays when fate/resilience change via direct input
        let previousFate = 0;
        let previousResilience = 0;
        
        document.getElementById('fate').addEventListener('input', () => {
            const fate = parseInt(document.getElementById('fate').value) || 0;
            const change = fate - previousFate;
            previousFate = fate;
            
            window.updateFateFortuneResilienceResolveDisplay();
            
            // Apply the same logic as the +/- buttons
            const fortuneCurrentField = document.getElementById('fortune-current');
            const currentFortune = parseInt(fortuneCurrentField.value) || 0;
            
            if (change > 0) {
                // Fate increased - add the same amount to current fortune
                fortuneCurrentField.value = currentFortune + change;
            } else if (currentFortune > fate) {
                // Fate decreased - cap current fortune at new max
                fortuneCurrentField.value = fate;
            }
        });

        document.getElementById('resilience').addEventListener('input', () => {
            const resilience = parseInt(document.getElementById('resilience').value) || 0;
            const change = resilience - previousResilience;
            previousResilience = resilience;
            
            window.updateFateFortuneResilienceResolveDisplay();
            
            // Apply the same logic as the +/- buttons
            const resolveCurrentField = document.getElementById('resolve-current');
            const currentResolve = parseInt(resolveCurrentField.value) || 0;
            
            if (change > 0) {
                // Resilience increased - add the same amount to current resolve
                resolveCurrentField.value = currentResolve + change;
            } else if (currentResolve > resilience) {
                // Resilience decreased - cap current resolve at new max
                resolveCurrentField.value = resilience;
            }
        });

        // Auto-calculate movement values
        const movement = document.getElementById('movement');
        const walk = document.getElementById('walk');
        const run = document.getElementById('run');
        
        movement.addEventListener('input', () => {
            const moveVal = parseInt(movement.value) || 0;
            
            // Store this as the base movement value
            movement.setAttribute('data-base-movement', moveVal);
            
            // Recalculate walk and run
            walk.value = moveVal * 2;
            run.value = moveVal * 4;
            
            // Recalculate encumbrance to apply any penalties
            updateEncumbrance();
        });

        // XP System Management - will be initialized in DOMContentLoaded
        let xpTotal, xpSpent;
        
        window.updateXPDisplay = function() {
            if (!xpTotal || !xpSpent) return; // Guard against early calls
            
            const total = parseInt(xpTotal.value) || 0;
            const spent = parseInt(xpSpent.value) || 0;
            const current = total - spent;
            
            document.getElementById('xp-total-display').textContent = total;
            document.getElementById('xp-current-display').textContent = current;
            document.getElementById('xp-spent-display').textContent = spent;
            
            // Update all advance cost displays
            window.updateAdvanceCosts();
        }
        
        // XP Earning Dialog
        window.openXPEarnDialog = function() {
            const xpAmount = prompt('Enter XP earned this session:', '0');
            if (xpAmount !== null && !isNaN(xpAmount) && parseInt(xpAmount) >= 0) {
                const sessionNote = prompt('Session note (optional):', '');
                window.addSessionXP(parseInt(xpAmount), sessionNote);
            }
        }
        
        window.addSessionXP = function(amount, note) {
            if (!xpTotal) return; // Guard against early calls
            
            const currentTotal = parseInt(xpTotal.value) || 0;
            xpTotal.value = currentTotal + amount;
            
            // Log the XP gain
            logXPEntry('earned', amount, note || 'Session XP');
            
            window.updateXPDisplay();
            
            if (amount > 0) {
                alert(`Added ${amount} XP! Total XP: ${parseInt(xpTotal.value)}`);
            }
        }

        // =============== XP LOG SYSTEM ===============

        // XP Log Variables
        let xpLog = JSON.parse(localStorage.getItem('wfrpXPLog')) || [];

        // Log XP Entry
        function logXPEntry(type, amount, description, source = '') {
            const entry = {
                id: 'xp_' + Date.now(),
                type: type, // 'earned' or 'spent'
                amount: amount,
                description: description,
                source: source,
                timestamp: new Date().toISOString(),
                date: new Date().toLocaleDateString()
            };
            
            xpLog.push(entry);
            saveXPLog();
        }

        // Save XP Log
        function saveXPLog() {
            localStorage.setItem('wfrpXPLog', JSON.stringify(xpLog));
        }

        // Open XP History Dialog
        window.openXPHistoryDialog = function() {
            updateXPHistoryDisplay();
            document.getElementById('xp-history-modal').style.display = 'block';
        }

        // Close XP History Dialog
        function closeXPHistory() {
            document.getElementById('xp-history-modal').style.display = 'none';
        }

        // Update XP History Display
        function updateXPHistoryDisplay() {
            const totalEarned = calculateTotalEarned();
            const totalSpent = parseInt(xpSpent.value) || 0;
            const currentAvailable = totalEarned - totalSpent;

            // Update summary
            document.getElementById('xp-history-total').textContent = totalEarned;
            document.getElementById('xp-history-spent').textContent = totalSpent;
            document.getElementById('xp-history-current').textContent = currentAvailable;

            // Update log content
            const logContent = document.getElementById('xp-log-content');
            
            if (xpLog.length === 0) {
                logContent.innerHTML = '<p style="text-align: center; color: #666; font-style: italic; padding: 20px;">No XP history found. Start earning XP to see entries here!</p>';
                return;
            }

            // Sort by timestamp (newest first)
            const sortedLog = [...xpLog].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            let logHTML = '<div style="display: flex; flex-direction: column; gap: 8px;">';

            sortedLog.forEach(entry => {
                const isEarned = entry.type === 'earned';
                const bgColor = isEarned ? '#e8f5e8' : '#f5e8e8';
                const textColor = isEarned ? '#28a745' : '#dc3545';
                const sign = isEarned ? '+' : '-';

                logHTML += `
                    <div style="padding: 12px; border: 1px solid #e8dfd0; border-radius: 5px; background: ${bgColor};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; color: ${textColor}; margin-bottom: 2px;">
                                    ${sign}${entry.amount} XP - ${entry.description}
                                </div>
                                <div style="font-size: 11px; color: #666;">
                                    ${entry.date} ${entry.source ? `â€¢ ${entry.source}` : ''}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="deleteXPEntry('${entry.id}')" 
                                        class="control-btn" 
                                        style="padding: 4px 8px; font-size: 10px; background: #d44; color: white;" 
                                        title="Delete this entry">
                                    Ã—
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });

            logHTML += '</div>';
            logContent.innerHTML = logHTML;
        }

        // Calculate Total Earned from Log
        function calculateTotalEarned() {
            return xpLog
                .filter(entry => entry.type === 'earned')
                .reduce((total, entry) => total + entry.amount, 0);
        }

        // Delete XP Entry
        function deleteXPEntry(entryId) {
            const entry = xpLog.find(e => e.id === entryId);
            if (!entry) return;

            const confirmMessage = `Delete this XP entry?\n\n${entry.type === 'earned' ? '+' : '-'}${entry.amount} XP - ${entry.description}\n\nThis will recalculate your total XP.`;
            
            if (!confirm(confirmMessage)) return;

            // Remove from log
            const entryIndex = xpLog.findIndex(e => e.id === entryId);
            if (entryIndex === -1) return;

            xpLog.splice(entryIndex, 1);
            saveXPLog();

            // Recalculate totals
            recalculateXPTotals();

            // Refresh display
            updateXPHistoryDisplay();
            window.updateXPDisplay();

            alert('XP entry deleted and totals recalculated.');
        }

        // Recalculate XP Totals
        function recalculateXPTotals() {
            const totalEarned = calculateTotalEarned();
            xpTotal.value = totalEarned;
        }

        // Clear XP History
        function clearXPHistory() {
            if (!confirm('Are you sure you want to clear all XP history?\n\nThis will reset your total XP to 0 and cannot be undone.')) {
                return;
            }

            xpLog = [];
            saveXPLog();

            // Reset XP totals
            xpTotal.value = 0;
            xpSpent.value = 0;

            // Update displays
            updateXPHistoryDisplay();
            window.updateXPDisplay();

            alert('XP history cleared and totals reset.');
        }

        // spendXP function will be updated below to include logging
        
        // XP Cost Calculation Functions
        window.getCharacteristicCost = function(advances) {
            const costs = [
                {min: 0, max: 5, cost: 25},
                {min: 6, max: 10, cost: 30},
                {min: 11, max: 15, cost: 40},
                {min: 16, max: 20, cost: 50},
                {min: 21, max: 25, cost: 70},
                {min: 26, max: 30, cost: 90},
                {min: 31, max: 35, cost: 120},
                {min: 36, max: 40, cost: 150},
                {min: 41, max: 45, cost: 190},
                {min: 46, max: 50, cost: 230},
                {min: 51, max: 55, cost: 280},
                {min: 56, max: 60, cost: 330},
                {min: 61, max: 65, cost: 390},
                {min: 66, max: 70, cost: 450}
            ];
            
            for (const range of costs) {
                if (advances >= range.min && advances <= range.max) {
                    return range.cost;
                }
            }
            return 520; // 70+ cost
        }
        
        window.getSkillCost = function(advances) {
            const costs = [
                {min: 0, max: 5, cost: 10},
                {min: 6, max: 10, cost: 15},
                {min: 11, max: 15, cost: 20},
                {min: 16, max: 20, cost: 30},
                {min: 21, max: 25, cost: 40},
                {min: 26, max: 30, cost: 60},
                {min: 31, max: 35, cost: 80},
                {min: 36, max: 40, cost: 110},
                {min: 41, max: 45, cost: 140},
                {min: 46, max: 50, cost: 180},
                {min: 51, max: 55, cost: 220},
                {min: 56, max: 60, cost: 270},
                {min: 61, max: 65, cost: 320},
                {min: 66, max: 70, cost: 380}
            ];
            
            for (const range of costs) {
                if (advances >= range.min && advances <= range.max) {
                    return range.cost;
                }
            }
            return 440; // 70+ cost
        }
        
        window.getTalentCost = function(advances) {
            return 100 + (100 * advances);
        }
        
        window.canAffordAdvance = function(cost) {
            if (!xpTotal || !xpSpent) return false; // Guard against early calls
            
            const total = parseInt(xpTotal.value) || 0;
            const spent = parseInt(xpSpent.value) || 0;
            const current = total - spent;
            return current >= cost;
        }
        
        window.spendXP = function(amount, description) {
            if (!xpTotal || !xpSpent) return false; // Guard against early calls
            
            if (!window.canAffordAdvance(amount)) {
                const total = parseInt(xpTotal.value) || 0;
                const spent = parseInt(xpSpent.value) || 0;
                const current = total - spent;
                alert(`Insufficient XP! Need ${amount} XP, only have ${current} available.`);
                return false;
            }
            
            const currentSpent = parseInt(xpSpent.value) || 0;
            xpSpent.value = currentSpent + amount;
            
            // Log the XP spending
            logXPEntry('spent', amount, description || 'XP spent');
            
            window.updateXPDisplay();
            return true;
        }
        
        window.updateAdvanceCosts = function() {
            // Update characteristic advance cost displays
            characteristics.forEach(char => {
                const advancesField = document.getElementById(`${char}-advances`);
                if (advancesField) {
                    const advances = parseInt(advancesField.value) || 0;
                    const cost = window.getCharacteristicCost(advances);
                    const costDisplay = document.getElementById(`${char}-cost-display`);
                    if (costDisplay) {
                        costDisplay.textContent = `(${cost} XP)`;
                        const button = costDisplay.parentElement.querySelector('button');
                        if (button) {
                            if (window.canAffordAdvance(cost)) {
                                button.style.opacity = '1';
                                button.disabled = false;
                            } else {
                                button.style.opacity = '0.5';
                                button.disabled = true;
                            }
                        }
                    }
                }
            });
            
            // Update skill advance cost displays and button states
            Object.keys(characterSkills).forEach(skillKey => {
                const skillData = characterSkills[skillKey];
                const cleanKey = skillKey.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
                const cost = window.getSkillCost(skillData.advances || 0);
                const costDisplay = document.getElementById(`${cleanKey}-cost-display`);
                if (costDisplay) {
                    costDisplay.textContent = `(${cost} XP)`;
                    const button = costDisplay.parentElement.querySelector('button');
                    if (button) {
                        const canAfford = window.canAffordAdvance(cost);
                        const maxAdvances = (skillData.advances || 0) >= 5;
                        
                        if (canAfford && !maxAdvances) {
                            button.style.opacity = '1';
                            button.disabled = false;
                        } else {
                            button.style.opacity = '0.5';
                            button.disabled = true;
                        }
                    }
                }
            });
            
            // Update talent cost displays and button states
            talents.forEach((talent, index) => {
                const currentTimes = talent.timesTaken || 1;
                const cleanTalentKey = talent.displayName.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
                const cost = window.getTalentCost(currentTimes); // Cost for next advance
                const costDisplay = document.getElementById(`${cleanTalentKey}-cost-display`);
                
                if (costDisplay) {
                    costDisplay.textContent = `(${cost} XP)`;
                    const button = costDisplay.parentElement.querySelector('button');
                    if (button) {
                        const canAfford = window.canAffordAdvance(cost);
                        const maxAllowed = talent.max === "No Limit" ? 999 : parseInt(talent.max);
                        const canTakeMore = currentTimes < maxAllowed;
                        
                        if (canAfford && canTakeMore) {
                            button.style.opacity = '1';
                            button.disabled = false;
                        } else {
                            button.style.opacity = '0.5';
                            button.disabled = true;
                        }
                    }
                }
            });
        }
        
        // Characteristic Advancement with XP Integration
        window.advanceCharacteristic = function(charCode) {
            if (!xpTotal || !xpSpent) return; // Guard against early calls
            
            const advancesField = document.getElementById(`${charCode}-advances`);
            const currentAdvances = parseInt(advancesField.value) || 0;
            const cost = window.getCharacteristicCost(currentAdvances);
            const total = parseInt(xpTotal.value) || 0;
            const spent = parseInt(xpSpent.value) || 0;
            const current = total - spent;
            
            const charNames = {
                'ws': 'Weapon Skill',
                'bs': 'Ballistic Skill', 
                's': 'Strength',
                't': 'Toughness',
                'i': 'Initiative',
                'agi': 'Agility',
                'dex': 'Dexterity',
                'int': 'Intelligence',
                'wp': 'Willpower',
                'fel': 'Fellowship'
            };
            
            if (!window.canAffordAdvance(cost)) {
                alert(`Insufficient XP! Need ${cost} XP to advance ${charNames[charCode]}, only have ${current} available.`);
                return;
            }
            
            // Check career tier restrictions
            if (currentCareer && currentCareer.characteristicAdvances) {
                const careerAdvances = currentCareer.characteristicAdvances[charCode] || [];
                const availableAtCurrentTier = careerAdvances.includes(currentTier);
                
                if (careerAdvances.length > 0 && !availableAtCurrentTier) {
                    const nextAvailableTier = Math.min(...careerAdvances.filter(tier => tier > currentTier));
                    if (isFinite(nextAvailableTier)) {
                        alert(`${charNames[charCode]} cannot be advanced at tier ${currentTier}. Available at tier ${nextAvailableTier}+.`);
                    } else {
                        alert(`${charNames[charCode]} cannot be advanced with your current career (${currentCareer.name}).`);
                    }
                    return;
                }
            }
            
            if (confirm(`Advance ${charNames[charCode]} for ${cost} XP? (Current XP: ${current})`)) {
                if (window.spendXP(cost, `${charNames[charCode]} advance`)) {
                    advancesField.value = currentAdvances + 1;
                    advancesField.dispatchEvent(new Event('input'));
                    
                    // Update characteristic limits to reflect the new advancement
                    if (currentCareer) {
                        updateCharacteristicLimits();
                    }
                    
                    alert(`${charNames[charCode]} advanced! Spent ${cost} XP.`);
                }
            }
        }
        
        // Skill Advancement with XP Integration
        window.advanceSkill = function(skillKey) {
            if (!xpTotal || !xpSpent) return; // Guard against early calls
            
            const skillData = characterSkills[skillKey] || { career: false, advances: 0, notes: '' };
            const currentAdvances = skillData.advances || 0;
            
            if (currentAdvances >= 5) {
                alert('Skills cannot exceed 5 advances!');
                return;
            }
            
            const cost = window.getSkillCost(currentAdvances);
            const total = parseInt(xpTotal.value) || 0;
            const spent = parseInt(xpSpent.value) || 0;
            const current = total - spent;
            
            // Find skill display name
            let skillDisplayName = skillKey;
            const allSkills = [...getDefaultSkills(), ...addedSkills];
            const skillInfo = allSkills.find(s => s.key === skillKey || s.name === skillKey);
            if (skillInfo) {
                skillDisplayName = skillInfo.displayName || skillInfo.name;
            }
            
            if (!window.canAffordAdvance(cost)) {
                alert(`Insufficient XP! Need ${cost} XP to advance ${skillDisplayName}, only have ${current} available.`);
                return;
            }
            
            if (confirm(`Advance ${skillDisplayName} for ${cost} XP? (Current XP: ${current})`)) {
                if (window.spendXP(cost, `${skillDisplayName} skill advance`)) {
                    window.updateSkillData(skillKey, 'advances', currentAdvances + 1);
                    window.displaySkills(); // Refresh the display
                    alert(`${skillDisplayName} advanced! Spent ${cost} XP.`);
                }
            }
        }
        
        // Talent Advancement with XP Integration
        window.advanceTalent = function(talentIndex) {
            if (!xpTotal || !xpSpent) return; // Guard against early calls
            
            const talent = talents[talentIndex];
            if (!talent) return;
            
            const currentTimes = talent.timesTaken || 1;
            const maxAllowed = talent.max === "No Limit" ? 999 : parseInt(talent.max);
            
            if (currentTimes >= maxAllowed) {
                alert(`${talent.displayName} is already at maximum!`);
                return;
            }
            
            // Cost for next advance: current times taken represents advances already made
            const cost = window.getTalentCost(currentTimes);
            const total = parseInt(xpTotal.value) || 0;
            const spent = parseInt(xpSpent.value) || 0;
            const current = total - spent;
            
            // Create a custom confirmation dialog with free option
            const canAfford = window.canAffordAdvance(cost);
            let confirmationMessage;
            
            if (canAfford) {
                confirmationMessage = `Take ${talent.displayName} again for ${cost} XP? (Current XP: ${current})\n\nClick OK to spend XP, or Cancel to add for free (mutation/story reward).`;
            } else {
                confirmationMessage = `Insufficient XP! Need ${cost} XP to take ${talent.displayName} again, only have ${current} available.\n\nClick OK to add for free (mutation/story reward), or Cancel to abort.`;
            }
            
            const userChoice = confirm(confirmationMessage);
            
            if (userChoice) {
                if (canAfford) {
                    // Normal XP purchase
                    if (window.spendXP(cost, `${talent.displayName} talent advance`)) {
                        talent.timesTaken = currentTimes + 1;
                        window.displayTalents(); // Refresh the display
                        // Update max wounds if Hardy talent was advanced
                        if (talent.name === "Hardy" && typeof window.updateMaxWounds === 'function') {
                            window.updateMaxWounds();
                        }
                        alert(`${talent.displayName} taken again! Spent ${cost} XP.`);
                    }
                } else {
                    // Free addition (insufficient XP scenario)
                    talent.timesTaken = currentTimes + 1;
                    window.displayTalents(); // Refresh the display
                    // Update max wounds if Hardy talent was advanced
                    if (talent.name === "Hardy" && typeof window.updateMaxWounds === 'function') {
                        window.updateMaxWounds();
                    }
                    alert(`${talent.displayName} taken again for FREE!`);
                }
            } else {
                if (canAfford) {
                    // User chose free option when they could afford it
                    if (confirm(`Add ${talent.displayName} again for FREE? (mutation/story reward)`)) {
                        talent.timesTaken = currentTimes + 1;
                        window.displayTalents(); // Refresh the display
                        // Update max wounds if Hardy talent was advanced
                        if (talent.name === "Hardy" && typeof window.updateMaxWounds === 'function') {
                            window.updateMaxWounds();
                        }
                        alert(`${talent.displayName} taken again for FREE!`);
                    }
                }
                // If they can't afford and clicked cancel, just return
            }
        }
        
        // Fate/Fortune/Resilience/Resolve System
        window.updateFateFortuneResilienceResolveDisplay = function() {
            // Update Fortune max display
            const fate = parseInt(document.getElementById('fate').value) || 0;
            const fortuneMax = document.getElementById('fortune-max');
            fortuneMax.textContent = fate;
            
            // Update Resolve max display  
            const resilience = parseInt(document.getElementById('resilience').value) || 0;
            const resolveMax = document.getElementById('resolve-max');
            resolveMax.textContent = resilience;
        }
        
        window.updateFate = function(change) {
            const fateField = document.getElementById('fate');
            const currentFate = parseInt(fateField.value) || 0;
            const newFate = Math.max(0, currentFate + change); // No max limit for fate
            
            fateField.value = newFate;
            
            // Update max fortune display
            const fortuneMax = document.getElementById('fortune-max');
            fortuneMax.textContent = newFate;
            
            // When fate increases, increase current fortune by the same amount
            // When fate decreases, cap current fortune at new max
            const fortuneCurrentField = document.getElementById('fortune-current');
            const currentFortune = parseInt(fortuneCurrentField.value) || 0;
            
            if (change > 0) {
                // Fate increased - add the same amount to current fortune
                fortuneCurrentField.value = currentFortune + change;
            } else if (currentFortune > newFate) {
                // Fate decreased - cap current fortune at new max
                fortuneCurrentField.value = newFate;
            }
            
            window.updateFateFortuneResilienceResolveDisplay();
        }
        
        window.updateFortune = function(change) {
            const fortuneCurrentField = document.getElementById('fortune-current');
            const currentFortune = parseInt(fortuneCurrentField.value) || 0;
            const maxFortune = parseInt(document.getElementById('fate').value) || 0;
            
            const newFortune = Math.max(0, Math.min(maxFortune, currentFortune + change));
            fortuneCurrentField.value = newFortune;
        }
        
        window.restoreFortune = function() {
            const maxFortune = parseInt(document.getElementById('fate').value) || 0;
            
            if (confirm(`Restore Fortune to ${maxFortune}? (usually done at session start)`)) {
                document.getElementById('fortune-current').value = maxFortune;
            }
        }
        
        window.updateResilience = function(change) {
            const resilienceField = document.getElementById('resilience');
            const currentResilience = parseInt(resilienceField.value) || 0;
            const newResilience = Math.max(0, currentResilience + change); // No max limit for resilience
            
            resilienceField.value = newResilience;
            
            // Update max resolve display
            const resolveMax = document.getElementById('resolve-max');
            resolveMax.textContent = newResilience;
            
            // When resilience increases, increase current resolve by the same amount
            // When resilience decreases, cap current resolve at new max
            const resolveCurrentField = document.getElementById('resolve-current');
            const currentResolve = parseInt(resolveCurrentField.value) || 0;
            
            if (change > 0) {
                // Resilience increased - add the same amount to current resolve
                resolveCurrentField.value = currentResolve + change;
            } else if (currentResolve > newResilience) {
                // Resilience decreased - cap current resolve at new max
                resolveCurrentField.value = newResilience;
            }
            
            window.updateFateFortuneResilienceResolveDisplay();
        }
        
        window.updateResolve = function(change) {
            const resolveCurrentField = document.getElementById('resolve-current');
            const currentResolve = parseInt(resolveCurrentField.value) || 0;
            const maxResolve = parseInt(document.getElementById('resilience').value) || 0;
            
            const newResolve = Math.max(0, Math.min(maxResolve, currentResolve + change));
            resolveCurrentField.value = newResolve;
        }
        
        // XP display will be initialized in DOMContentLoaded

        // Skills functionality
        window.displaySkills = function() {
            const tbody = document.getElementById('skills-tbody');
            const filter = document.getElementById('skills-filter').value;
            tbody.innerHTML = '';
            
            // Combine default skills and added skills
            let allDisplaySkills = [];
            
            // Add default basic skills (ungrouped)
            getDefaultSkills().forEach(skill => {
                allDisplaySkills.push({
                    key: skill.name,
                    name: skill.name,
                    displayName: skill.name,
                    characteristic: skill.characteristic,
                    type: skill.type,
                    canDelete: false
                });
            });
            
            // Add manually added skills
            addedSkills.forEach(skill => {
                allDisplaySkills.push({
                    key: skill.key,
                    name: skill.name,
                    displayName: skill.displayName,
                    characteristic: skill.characteristic,
                    type: skill.type,
                    canDelete: true
                });
            });
            
            // Filter skills
            if (filter !== 'all') {
                allDisplaySkills = allDisplaySkills.filter(skill => {
                    if (filter === 'career') return characterSkills[skill.key]?.career || false;
                    if (filter === 'basic') return skill.type === 'Basic';
                    if (filter === 'advanced') return skill.type === 'Advanced';
                    return true;
                });
            }
            
            // Sort alphabetically
            allDisplaySkills.sort((a, b) => a.displayName.localeCompare(b.displayName));
            
            // Display skills
            allDisplaySkills.forEach(skill => {
                const skillData = characterSkills[skill.key] || { career: false, advances: 0, notes: '' };
                
                const row = document.createElement('tr');
                const cleanKey = skill.key.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
                const cost = window.getSkillCost(skillData.advances);
                
                row.innerHTML = `
                    <td class="skill-name-cell">${skill.displayName}</td>
                    <td>${skill.characteristic}</td>
                    <td>${skill.type}</td>
                    <td><input type="checkbox" ${skillData.career ? 'checked' : ''} onchange="updateSkillData('${skill.key}', 'career', this.checked)"></td>
                    <td><input type="number" value="${skillData.advances}" min="0" readonly style="width: 50px; background: #f5f5f5;"></td>
                    <td class="skill-total" id="skill-total-${cleanKey}">${calculateSkillTotal(skill, skill.key)}</td>
                    <td style="text-align: center;">
                        <button onclick="window.advanceSkill('${skill.key}')" style="padding: 5px 8px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                        <span id="${cleanKey}-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(${cost} XP)</span>
                    </td>
                    <td><input type="text" value="${skillData.notes}" placeholder="Notes..." onchange="updateSkillData('${skill.key}', 'notes', this.value)" style="width: 100%; border: none; font-size: 11px;"></td>
                    <td>${skill.canDelete ? `<button class="advance-btn" onclick="removeSkill('${skill.key}')" style="background: #d44; color: white; width: 20px;">Ã—</button>` : ''}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Highlight career skills after displaying
            if (typeof highlightCareerSkills === 'function') {
                highlightCareerSkills();
            }
        }

        window.calculateSkillTotal = function(skill, skillKey) {
            const skillData = characterSkills[skillKey] || { advances: 0 };
            const charElement = document.getElementById(`${skill.characteristic.toLowerCase()}-current`);
            const charValue = charElement ? parseInt(charElement.value) || 0 : 0;
            const advances = skillData.advances || 0;
            let baseTotal = charValue + advances;
            
            // Apply critical wound penalties to skills
            if (typeof window.getSkillPenaltiesFromWounds === 'function') {
                const woundPenalties = window.getSkillPenaltiesFromWounds(skillKey);
                baseTotal = Math.max(0, baseTotal - woundPenalties.totalPenalty);
                
                // Update visual indicators for penalized skills
                setTimeout(() => {
                    const cleanKey = skillKey.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
                    const totalElement = document.getElementById(`skill-total-${cleanKey}`);
                    if (totalElement && woundPenalties.totalPenalty > 0) {
                        totalElement.style.color = 'red';
                        totalElement.title = `Base: ${charValue + advances}, Critical Wounds: -${woundPenalties.totalPenalty}\n${woundPenalties.penalties.join('\n')}`;
                    } else if (totalElement) {
                        totalElement.style.color = '';
                        totalElement.title = '';
                    }
                }, 10);
            }
            
            return baseTotal;
        }

        window.updateSkillData = function(skillKey, property, value) {
            if (!characterSkills[skillKey]) {
                characterSkills[skillKey] = { career: false, advances: 0, notes: '' };
            }
            characterSkills[skillKey][property] = value;
            
            updateSkillTotal(skillKey);
        }

        window.updateSkillTotal = function(skillKey) {
            // Find the skill
            let skill = getDefaultSkills().find(s => s.name === skillKey);
            if (!skill) {
                skill = addedSkills.find(s => s.key === skillKey);
            }
            
            if (skill) {
                // Match the ID generation from displaySkills function
                const cleanKey = skillKey.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
                const totalElement = document.getElementById(`skill-total-${cleanKey}`);
                if (totalElement) {
                    totalElement.textContent = calculateSkillTotal(skill, skillKey);
                }
            }
        }

        window.updateAllSkillTotals = function() {
            // Update default skills
            getDefaultSkills().forEach(skill => {
                updateSkillTotal(skill.name);
            });
            
            // Update added skills
            addedSkills.forEach(skill => {
                updateSkillTotal(skill.key);
            });
        }

        // Add skill modal functions
        window.addSkill = function() {
            populateSkillSelect();
            document.getElementById('add-skill-modal').style.display = 'block';
        }

        window.populateSkillSelect = function() {
            const select = document.getElementById('skill-select');
            select.innerHTML = '<option value="">Select a skill...</option>';
            
            // Only show skills that are either:
            // 1. Grouped skills (requiring specialisation)
            // 2. Advanced skills (not automatically available)
            // Exclude basic ungrouped skills as they're already shown by default
            allSkills.forEach(skill => {
                // Skip basic ungrouped skills - they're already in the default list
                if (skill.type === 'Basic' && !skill.grouped) {
                    return;
                }
                
                const option = document.createElement('option');
                option.value = skill.name;
                option.textContent = skill.name + (skill.grouped ? ' (requires specialisation)' : '');
                option.dataset.grouped = skill.grouped;
                select.appendChild(option);
            });
        }

        window.toggleSpecialisationField = function() {
            const select = document.getElementById('skill-select');
            const selectedOption = select.options[select.selectedIndex];
            const specialisationField = document.getElementById('specialisation-field');
            
            if (selectedOption && selectedOption.dataset.grouped === 'true') {
                specialisationField.style.display = 'block';
            } else {
                specialisationField.style.display = 'none';
                document.getElementById('specialisation-input').value = '';
            }
        }

        window.confirmAddSkill = function() {
            const skillName = document.getElementById('skill-select').value;
            const specialisation = document.getElementById('specialisation-input').value.trim();
            
            if (!skillName) {
                alert('Please select a skill');
                return;
            }
            
            const baseSkill = allSkills.find(s => s.name === skillName);
            if (!baseSkill) {
                alert('Invalid skill selected');
                return;
            }
            
            // Check if specialisation is required
            if (baseSkill.grouped && !specialisation) {
                alert(`This skill requires a specialisation (e.g., ${skillName} (Battle), ${skillName} (Bow))`);
                return;
            }
            
            // Create the skill key and display name
            let skillKey, displayName;
            if (specialisation) {
                skillKey = `${skillName} (${specialisation})`;
                displayName = `${skillName} (${specialisation})`;
            } else {
                skillKey = skillName;
                displayName = skillName;
            }
            
            // Check if this exact skill already exists
            if (addedSkills.find(s => s.key === skillKey)) {
                alert('This skill is already added');
                return;
            }
            
            // Add the skill
            addedSkills.push({
                key: skillKey,
                name: skillName,
                displayName: displayName,
                characteristic: baseSkill.characteristic,
                type: baseSkill.type,
                specialisation: specialisation
            });
            
            // Initialize skill data
            characterSkills[skillKey] = { career: false, advances: 0, notes: '' };
            
            displaySkills();
            closeAddSkillModal();
        }

        // Talent Management Functions
        window.addTalent = function() {
            populateTalentSelect();
            document.getElementById('add-talent-modal').style.display = 'block';
            document.getElementById('talent-search-modal').value = '';
            document.getElementById('talent-search-modal').focus();
        }

        window.populateTalentSelect = function() {
            const select = document.getElementById('talent-select');
            select.innerHTML = '';
            
            const sortedTalents = [...srdTalents].sort((a, b) => a.name.localeCompare(b.name));
            
            sortedTalents.forEach(talent => {
                const option = document.createElement('option');
                option.value = talent.name;
                option.textContent = `${talent.name} (Max: ${talent.max})`;
                option.dataset.talent = JSON.stringify(talent);
                select.appendChild(option);
            });
        }

        window.filterTalentOptions = function() {
            console.log('filterTalentOptions called!');
            
            const searchInput = document.getElementById('talent-search-modal');
            const select = document.getElementById('talent-select');
            
            if (!searchInput || !select) {
                console.error('Elements not found:', { searchInput, select });
                return;
            }
            
            const searchText = searchInput.value.toLowerCase();
            const options = select.options;
            
            console.log('Searching for:', searchText);
            console.log('Total options:', options.length);
            
            if (options.length === 0) {
                console.log('No options available - talent data may not be loaded');
                return;
            }
            
            let matchCount = 0;
            let firstMatch = null;
            
            for (let i = 0; i < options.length; i++) {
                try {
                    const talent = JSON.parse(options[i].dataset.talent);
                    const matches = searchText === '' || 
                                   (talent.name && talent.name.toLowerCase().includes(searchText)) ||
                                   (talent.description && talent.description.toLowerCase().includes(searchText)) ||
                                   (talent.tests && talent.tests.toLowerCase().includes(searchText));
                    
                    options[i].style.display = matches ? '' : 'none';
                    
                    if (matches) {
                        matchCount++;
                        if (!firstMatch) {
                            firstMatch = options[i];
                        }
                    }
                } catch (e) {
                    console.error('Error parsing talent data for option', i, ':', e);
                    options[i].style.display = 'none';
                }
            }
            
            // Select first match if any
            if (firstMatch && matchCount > 0) {
                firstMatch.selected = true;
                window.showTalentDetails();
            }
            
            console.log('Matches found:', matchCount);
        }

window.showTalentDetails = function() {
    const select = document.getElementById('talent-select');
    const selectedOption = select.options[select.selectedIndex];
    
    if (!selectedOption) return;
    
    const talent = JSON.parse(selectedOption.dataset.talent);
    const detailsDiv = document.getElementById('talent-details');
    const customisationDiv = document.getElementById('talent-customisation');
    const timesDiv = document.getElementById('talent-times-taken');
    
    document.getElementById('detail-talent-name').textContent = talent.name;
    document.getElementById('detail-talent-max').textContent = talent.max;
    document.getElementById('detail-talent-tests').textContent = talent.tests || 'N/A';
    document.getElementById('detail-talent-description').textContent = talent.description;
    
    detailsDiv.style.display = 'block';
    
    if (talent.customisable) {
        customisationDiv.style.display = 'block';
    } else {
        customisationDiv.style.display = 'none';
        document.getElementById('talent-customisation-input').value = '';
    }
    
    // Calculate max allowed to add based on limitations
    let maxAllowedToAdd = 10; // Default for unlimited talents
    
    if (talent.max === "1") {
        maxAllowedToAdd = 1;
        timesDiv.style.display = 'none';
    } else {
        timesDiv.style.display = 'block';
        
        // Check for characteristic bonus limitations
        if (window.isTalentLimited(talent.name)) {
            const currentCount = window.getTalentCurrentCount(talent.name);
            const currentLimit = window.getTalentCurrentLimit(talent.name);
            maxAllowedToAdd = Math.max(0, currentLimit - currentCount);
            
            // Update the label to show max allowed
            const label = document.querySelector('label[for="talent-times-input"]') || 
                         document.querySelector('#talent-times-taken label');
            if (label) {
                if (maxAllowedToAdd === 0) {
                    label.innerHTML = `Number to Add: <span style="color: #c41e3a;">(Already at limit ${currentCount}/${currentLimit})</span>`;
                } else {
                    label.innerHTML = `Number to Add: <span style="color: #666; font-size: 12px;">(Max: ${maxAllowedToAdd} more)</span>`;
                }
            }
        } else {
            // For unlimited talents, show standard label
            const label = document.querySelector('label[for="talent-times-input"]') || 
                         document.querySelector('#talent-times-taken label');
            if (label) {
                label.textContent = 'Number to Add:';
            }
        }
    }
    
    // Set the input max and reset value to valid range
    const timesInput = document.getElementById('talent-times-input');
    timesInput.max = maxAllowedToAdd;
    timesInput.value = Math.min(parseInt(timesInput.value) || 1, maxAllowedToAdd);
}

window.confirmAddTalent = function() {
    const select = document.getElementById('talent-select');
    const selectedOption = select.options[select.selectedIndex];
    
    if (!selectedOption) {
        alert('Please select a talent');
        return;
    }
    
    const talentData = JSON.parse(selectedOption.dataset.talent);
    const customisation = document.getElementById('talent-customisation-input').value.trim();
    const timesTaken = parseInt(document.getElementById('talent-times-input').value) || 1;
    
    if (talentData.customisable && !customisation) {
        alert(`Please specify the type for ${talentData.name}`);
        return;
    }
    
    // Check talent limitations first
    if (window.isTalentLimited(talentData.name)) {
        const currentCount = window.getTalentCurrentCount(talentData.name);
        const currentLimit = window.getTalentCurrentLimit(talentData.name);
        const maxAllowedToAdd = Math.max(0, currentLimit - currentCount);
        
        // Check if trying to add more than allowed
        if (timesTaken > maxAllowedToAdd) {
            // Determine limit type for error message
            let limitType = "UNKNOWN";
            if (talentLimitations[talentData.name]) {
                limitType = talentLimitations[talentData.name].replace('Bonus', '').toUpperCase();
            } else if (srdTalents) {
                const talentInfo = srdTalents.find(t => t.name === talentData.name);
                if (talentInfo && talentInfo.max) {
                    limitType = talentInfo.max.replace(' Bonus', '').toUpperCase();
                }
            }
            
            if (maxAllowedToAdd === 0) {
                alert(`Cannot add ${talentData.name}: already at limit (${currentCount}/${currentLimit} based on ${limitType} Bonus)`);
            } else {
                alert(`Cannot add ${timesTaken} instances of ${talentData.name}. You can only add ${maxAllowedToAdd} more (currently ${currentCount}/${currentLimit} based on ${limitType} Bonus)`);
            }
            return;
        }
    }
    
    // Check if XP cost should be overridden (free talent)
    const isFreeTalent = document.getElementById('talent-xp-override').checked;
    const displayName = customisation ? `${talentData.name} (${customisation})` : talentData.name;
    
    // Calculate XP cost for the talent(s) being added (unless it's free)
    let totalCost = 0;
    
    if (!isFreeTalent) {
        // Check if this exact talent already exists
        const existingIndex = talents.findIndex(t => 
            t.name === talentData.name && t.customisation === customisation
        );
        
        if (existingIndex !== -1) {
            // Adding to existing talent
            const currentTimes = talents[existingIndex].timesTaken;
            const maxAllowed = parseInt(talentData.max) || 10;
            const actualTimesToAdd = Math.min(timesTaken, maxAllowed - currentTimes);
            
            if (actualTimesToAdd <= 0) {
                alert(`You already have the maximum number of ${displayName}`);
                return;
            }
            
            // Calculate cost for each additional time
            for (let i = 0; i < actualTimesToAdd; i++) {
                totalCost += window.getTalentCost(currentTimes + i);
            }
        } else {
            // New talent - calculate cost for all times
            for (let i = 0; i < timesTaken; i++) {
                totalCost += window.getTalentCost(i);
            }
        }
        
        // Check if player can afford it
        const total = parseInt(document.getElementById('xp-total').value) || 0;
        const spent = parseInt(document.getElementById('xp-spent').value) || 0;
        const current = total - spent;
        
        if (!window.canAffordAdvance(totalCost)) {
            alert(`Insufficient XP! Need ${totalCost} XP to add ${displayName}${timesTaken > 1 ? ` (${timesTaken} times)` : ''}, only have ${current} available.`);
            return;
        }
        
        // Confirm the purchase
        const confirmMessage = timesTaken > 1 ? 
            `Add ${displayName} ${timesTaken} times for ${totalCost} XP? (Current XP: ${current})` :
            `Add ${displayName} for ${totalCost} XP? (Current XP: ${current})`;
            
        if (!confirm(confirmMessage)) {
            return;
        }
        
        // Spend the XP
        if (!window.spendXP(totalCost, `${displayName} talent${timesTaken > 1 ? ` (${timesTaken} times)` : ''}`)) {
            return;
        }
    } else {
        // Free talent - just confirm the addition
        const confirmMessage = timesTaken > 1 ? 
            `Add ${displayName} ${timesTaken} times for FREE?` :
            `Add ${displayName} for FREE?`;
            
        if (!confirm(confirmMessage)) {
            return;
        }
        
        // Check limits even for free talents
        const existingIndex = talents.findIndex(t => 
            t.name === talentData.name && t.customisation === customisation
        );
        
        if (existingIndex !== -1) {
            const currentTimes = talents[existingIndex].timesTaken;
            const maxAllowed = parseInt(talentData.max) || 10;
            const actualTimesToAdd = Math.min(timesTaken, maxAllowed - currentTimes);
            
            if (actualTimesToAdd <= 0) {
                alert(`You already have the maximum number of ${displayName}`);
                return;
            }
        }
    }
    
    // Create talent object
    const talent = {
        name: talentData.name,
        displayName: customisation ? `${talentData.name} (${customisation})` : talentData.name,
        max: talentData.max,
        tests: talentData.tests || '',
        description: talentData.description || '',
        timesTaken: 1,  // Always start at 1, not the input value
        customisation: customisation,
        notes: ''
    };
    
    // Check if this exact talent already exists
    const existingTalentIndex = talents.findIndex(t => 
        t.name === talent.name && t.customisation === talent.customisation
    );
    
    if (existingTalentIndex !== -1) {
        // If it can be taken multiple times and we're adding more
        if (talentData.max !== "1") {
            const maxAllowed = parseInt(talentData.max) || 10;
            const currentTimes = talents[existingTalentIndex].timesTaken;
            const newTotal = Math.min(currentTimes + timesTaken, maxAllowed);
            
            if (currentTimes >= maxAllowed) {
                alert(`You already have the maximum number of ${talentData.name}`);
                return;
            }
            
            talents[existingTalentIndex].timesTaken = newTotal;
        } else {
            alert('You already have this talent');
            return;
        }
    } else {
        // For new talents that can be taken multiple times
        if (talentData.max !== "1" && timesTaken > 1) {
            talent.timesTaken = timesTaken;
        }
        talents.push(talent);
    }
    
    displayTalents();
    closeAddTalentModal();
    
    // Update max wounds if Hardy talent was added
    if (talentData.name === "Hardy" && typeof window.updateMaxWounds === 'function') {
        window.updateMaxWounds();
    }
}

window.closeAddTalentModal = function() {
    document.getElementById('add-talent-modal').style.display = 'none';
    document.getElementById('talent-select').value = '';
    document.getElementById('talent-customisation-input').value = '';
    document.getElementById('talent-times-input').value = '1';
    document.getElementById('talent-xp-override').checked = false; // Reset XP override checkbox
    document.getElementById('talent-details').style.display = 'none';
    document.getElementById('talent-customisation').style.display = 'none';
}

// Talent Limitations System
window.isTalentLimited = function(talentName) {
    // Check hard-coded limitations first
    if (talentLimitations[talentName]) {
        return true;
    }
    
    // Check JSON talent data for characteristic bonus limits
    if (srdTalents && srdTalents.length > 0) {
        const talentData = srdTalents.find(t => t.name === talentName);
        if (talentData && talentData.max) {
            const bonusTypes = ["Strength Bonus", "Toughness Bonus", "Intelligence Bonus", 
                              "Willpower Bonus", "Agility Bonus", "Dexterity Bonus", 
                              "Weapon Skill Bonus", "Ballistic Skill Bonus", "Initiative Bonus", 
                              "Fellowship Bonus"];
            return bonusTypes.includes(talentData.max);
        }
    }
    
    return false;
}

window.getTalentCurrentLimit = function(talentName, characteristics) {
    let limitType = talentLimitations[talentName];
    
    // If not in hard-coded list, check JSON talent data for characteristic bonus limits
    if (!limitType && srdTalents && srdTalents.length > 0) {
        const talentData = srdTalents.find(t => t.name === talentName);
        if (talentData && talentData.max) {
            switch(talentData.max) {
                case "Strength Bonus":
                    limitType = "strengthBonus";
                    break;
                case "Toughness Bonus":
                    limitType = "toughnessBonus";
                    break;
                case "Intelligence Bonus":
                    limitType = "intelligenceBonus";
                    break;
                case "Willpower Bonus":
                    limitType = "willpowerBonus";
                    break;
                case "Agility Bonus":
                    limitType = "agilityBonus";
                    break;
                case "Dexterity Bonus":
                    limitType = "dexterityBonus";
                    break;
                case "Weapon Skill Bonus":
                    limitType = "weaponSkillBonus";
                    break;
                case "Ballistic Skill Bonus":
                    limitType = "ballisticSkillBonus";
                    break;
                case "Initiative Bonus":
                    limitType = "initiativeBonus";
                    break;
                case "Fellowship Bonus":
                    limitType = "fellowshipBonus";
                    break;
            }
        }
    }
    
    if (!limitType) return 999; // Unlimited talent
    
    // Handle different characteristic bonus types
    let characteristicValue = 0;
    switch(limitType) {
        case "strengthBonus":
            characteristicValue = parseInt(document.getElementById('s-current')?.value) || 0;
            break;
        case "toughnessBonus":
            characteristicValue = parseInt(document.getElementById('t-current')?.value) || 0;
            break;
        case "intelligenceBonus":
            characteristicValue = parseInt(document.getElementById('int-current')?.value) || 0;
            break;
        case "willpowerBonus":
            characteristicValue = parseInt(document.getElementById('wp-current')?.value) || 0;
            break;
        case "agilityBonus":
            characteristicValue = parseInt(document.getElementById('agi-current')?.value) || 0;
            break;
        case "dexterityBonus":
            characteristicValue = parseInt(document.getElementById('dex-current')?.value) || 0;
            break;
        case "weaponSkillBonus":
            characteristicValue = parseInt(document.getElementById('ws-current')?.value) || 0;
            break;
        case "ballisticSkillBonus":
            characteristicValue = parseInt(document.getElementById('bs-current')?.value) || 0;
            break;
        case "initiativeBonus":
            characteristicValue = parseInt(document.getElementById('i-current')?.value) || 0;
            break;
        case "fellowshipBonus":
            characteristicValue = parseInt(document.getElementById('fel-current')?.value) || 0;
            break;
        default:
            return 999; // Unknown limitation type
    }
    
    return Math.floor(characteristicValue / 10);
}

window.getTalentCurrentCount = function(talentName) {
    // Count both separate entries AND timesTaken for each entry
    return talents.filter(t => t.name === talentName)
                 .reduce((total, talent) => total + (talent.timesTaken || 1), 0);
}

window.canAddTalent = function(talentName) {
    const currentCount = window.getTalentCurrentCount(talentName);
    const currentLimit = window.getTalentCurrentLimit(talentName);
    
    return currentCount < currentLimit;
}

window.getTalentLimitWarnings = function() {
    const warnings = [];
    const talentCounts = {};
    
    // Count occurrences of each talent
    talents.forEach(talent => {
        talentCounts[talent.name] = (talentCounts[talent.name] || 0) + 1;
    });
    
    // Check each limited talent
    Object.keys(talentCounts).forEach(talentName => {
        if (talentLimitations[talentName]) {
            const count = talentCounts[talentName];
            const limit = window.getTalentCurrentLimit(talentName);
            
            if (count > limit) {
                warnings.push({
                    talent: talentName,
                    count: count,
                    limit: limit,
                    excess: count - limit
                });
            }
        }
    });
    
    return warnings;
}

window.updateTalentLimitsDisplay = function() {
    // Force refresh of talent display to show updated limits
    window.displayTalents();
}

window.checkTalentLimits = function() {
    const warnings = window.getTalentLimitWarnings();
    
    if (warnings.length > 0) {
        const warningMessages = warnings.map(w => 
            `${w.talent}: ${w.count}/${w.limit} (${w.excess} over limit)`
        );
        
        console.warn('Talent Limit Warnings:', warningMessages);
        return warnings;
    }
    
    return [];
}

// Max Wounds Auto-Calculation System
window.calculateMaxWounds = function() {
    const species = document.getElementById('species')?.value || 'Human';
    const strength = parseInt(document.getElementById('s-current')?.value) || 0;
    const toughness = parseInt(document.getElementById('t-current')?.value) || 0;
    const willpower = parseInt(document.getElementById('wp-current')?.value) || 0;
    
    const sb = Math.floor(strength / 10);
    const tb = Math.floor(toughness / 10);
    const wpb = Math.floor(willpower / 10);
    
    let baseWounds;
    switch(species) {
        case "Human":
        case "Dwarf": 
        case "High Elf":
        case "Wood Elf":
            baseWounds = sb + (2 * tb) + wpb;
            break;
        case "Halfling":
            baseWounds = (2 * tb) + wpb; // No Strength Bonus for Halflings
            break;
        default:
            baseWounds = sb + (2 * tb) + wpb; // Default to human
    }
    
    // Add Hardy talent bonus
    const hardyCount = window.getTalentCurrentCount("Hardy");
    const hardyBonus = hardyCount * tb;
    
    const totalWounds = baseWounds + hardyBonus;
    
    // Update tooltip with calculation breakdown
    const woundsMaxField = document.getElementById('wounds-max');
    if (woundsMaxField) {
        let tooltip = `SB(${sb}) + 2Ã—TB(${2*tb}) + WPB(${wpb})`;
        if (species === "Halfling") {
            tooltip = `2Ã—TB(${2*tb}) + WPB(${wpb}) (Halfling)`;
        }
        if (hardyCount > 0) {
            tooltip += ` + Hardy(${hardyCount}Ã—TB=${hardyBonus})`;
        }
        tooltip += ` = ${totalWounds}`;
        woundsMaxField.title = tooltip;
    }
    
    return totalWounds;
}

window.updateMaxWounds = function() {
    const maxWounds = window.calculateMaxWounds();
    const woundsMaxField = document.getElementById('wounds-max');
    const woundsCurrentField = document.getElementById('wounds-current');
    
    if (woundsMaxField) {
        woundsMaxField.value = maxWounds;
        
        // Update wounds current if it exceeds new max
        if (woundsCurrentField) {
            const currentWounds = parseInt(woundsCurrentField.value) || 0;
            if (currentWounds > maxWounds) {
                woundsCurrentField.value = maxWounds;
            }
        }
    }
}

window.displayTalents = function() {
    const tbody = document.getElementById('talents-tbody');
    if (!tbody) return;
    
    const searchText = (document.getElementById('talents-search')?.value || '').toLowerCase();
    
    tbody.innerHTML = '';
    
    let displayedTalents = talents;
    if (searchText) {
        displayedTalents = talents.filter(t => 
            t.displayName.toLowerCase().includes(searchText) ||
            t.description.toLowerCase().includes(searchText)
        );
    }
    
    displayedTalents.sort((a, b) => a.displayName.localeCompare(b.displayName));
    
    displayedTalents.forEach((talent) => {
        const row = document.createElement('tr');
        const currentTimes = talent.timesTaken || 1;
        const cleanTalentKey = talent.displayName.replace(/\s+/g, '-').replace(/[()]/g, '').toLowerCase();
        const cost = window.getTalentCost(currentTimes - 1); // Cost for next advance
        
        // Check talent limitations
        const isLimited = window.isTalentLimited(talent.name);
        let timesDisplay = "";
        let canTakeMore = talent.max === "No Limit" || parseInt(talent.max) > currentTimes;
        let limitColor = "";
        
        if (isLimited) {
            const currentCount = window.getTalentCurrentCount(talent.name);
            const currentLimit = window.getTalentCurrentLimit(talent.name);
            
            // Determine color based on limit status
            if (currentCount > currentLimit) {
                limitColor = "color: #c41e3a; font-weight: bold;"; // Red - over limit
            } else if (currentCount >= currentLimit) {
                limitColor = "color: #ff8c00; font-weight: bold;"; // Orange - at limit
                canTakeMore = false; // Can't take more when at limit
            } else {
                limitColor = "color: #0a7c0a;"; // Green - can take more
            }
            
            // For limited talents, show Times Taken as currentCount/currentLimit
            timesDisplay = `<span style="${limitColor}">${currentCount}/${currentLimit}</span>`;
            
            // Override talent max display for limited talents
            canTakeMore = canTakeMore && (currentCount < currentLimit);
        } else {
            // For non-limited talents, show the regular times taken display
            timesDisplay = talent.max === "1" ? "1" : `${currentTimes}/${talent.max}`;
        }
        
        row.innerHTML = `
            <td class="skill-name-cell">${talent.displayName}</td>
            <td style="text-align: center;">${timesDisplay}</td>
            <td style="text-align: center;">
                ${canTakeMore ? 
                    `<button onclick="window.advanceTalent(${talents.indexOf(talent)})" style="padding: 5px 8px; font-size: 11px; background: #3e2f1f; color: #faf8f3; border: 1px solid #2a1f14; cursor: pointer;">+</button>
                     <span id="${cleanTalentKey}-cost-display" style="font-size: 10px; color: #666; margin-left: 5px;">(${cost} XP)</span>` 
                    : '<span style="color: #999;">Max</span>'
                }
            </td>
            <td style="font-size: 11px; padding: 5px;">${talent.description}</td>
            <td style="padding: 3px;">
                <textarea 
                    style="width: 100%; min-height: 30px; font-size: 11px; font-family: Georgia, serif; border: 1px solid #8b7355; padding: 3px; resize: vertical;"
                    placeholder="Add notes..."
                    onchange="window.updateTalentNotes(${talents.indexOf(talent)}, this.value)"
                >${talent.notes || ''}</textarea>
            </td>
            <td><button class="advance-btn" onclick="window.removeTalent(${talents.indexOf(talent)})" style="background: #d44; color: white;">Ã—</button></td>
        `;
        tbody.appendChild(row);
    });
    
    // Highlight career talents after displaying
    if (typeof highlightCareerTalents === 'function') {
        highlightCareerTalents();
    }
}

window.updateTalentNotes = function(index, notes) {
    if (talents[index]) {
        talents[index].notes = notes;
    }
}

window.removeTalent = function(index) {
    if (confirm('Remove this talent?')) {
        const removedTalent = talents[index];
        talents.splice(index, 1);
        displayTalents();
        
        // Update max wounds if Hardy talent was removed
        if (removedTalent.name === "Hardy" && typeof window.updateMaxWounds === 'function') {
            window.updateMaxWounds();
        }
    }
}

// Add search listener for talents
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('talents-search')?.addEventListener('input', function() {
        displayTalents();
    });
});

// WFRP Conditions Management System
window.getSeverityColor = function(severity) {
    const colors = {
        'severe': '#c41e3a',     // Red
        'moderate': '#ff8c00',   // Orange  
        'minor': '#ffd700',      // Yellow
        'positional': '#4682b4'  // Blue
    };
    return colors[severity] || '#666666';
}

window.getConditionDisplayName = function(conditionName, stacks) {
    const conditionData = wfrpConditions[conditionName];
    if (!conditionData) return conditionName;
    
    if (conditionData.stackable && stacks > 1) {
        return `${conditionName} (x${stacks})`;
    }
    return conditionName;
}

window.addCondition = function(conditionName, stacksToAdd = 1) {
    const conditionData = wfrpConditions[conditionName];
    if (!conditionData) {
        console.error('Unknown condition:', conditionName);
        return false;
    }
    
    // Find existing condition
    const existingIndex = activeConditions.findIndex(c => c.name === conditionName);
    
    if (existingIndex !== -1) {
        // Condition already exists
        if (conditionData.stackable) {
            // Add stacks to existing condition
            activeConditions[existingIndex].stacks += stacksToAdd;
        } else {
            // Non-stackable - don't add duplicate
            alert(`${conditionName} is already active and cannot stack!`);
            return false;
        }
    } else {
        // Create new condition entry
        activeConditions.push({
            name: conditionName,
            stacks: conditionData.stackable ? stacksToAdd : 1
        });
    }
    
    window.updateConditionDisplay();
    return true;
}

window.removeCondition = function(conditionName, stacksToRemove = 1) {
    const existingIndex = activeConditions.findIndex(c => c.name === conditionName);
    
    if (existingIndex === -1) {
        console.warn('Condition not found:', conditionName);
        return false;
    }
    
    const condition = activeConditions[existingIndex];
    const conditionData = wfrpConditions[conditionName];
    
    if (conditionData.stackable) {
        condition.stacks = Math.max(0, condition.stacks - stacksToRemove);
        if (condition.stacks <= 0) {
            activeConditions.splice(existingIndex, 1);
        }
    } else {
        activeConditions.splice(existingIndex, 1);
    }
    
    window.updateConditionDisplay();
    return true;
}

window.removeAllConditions = function() {
    if (activeConditions.length === 0) {
        alert('No conditions to remove!');
        return;
    }
    
    if (confirm(`Remove all ${activeConditions.length} active conditions?`)) {
        activeConditions.length = 0;
        window.updateConditionDisplay();
    }
}

window.updateConditionDisplay = function() {
    const display = document.getElementById('active-conditions-display');
    const noConditionsMsg = document.getElementById('no-conditions-message');
    const searchText = (document.getElementById('conditions-search')?.value || '').toLowerCase();
    
    // Clear current display
    display.innerHTML = '';
    
    // Filter conditions based on search
    let filteredConditions = activeConditions;
    if (searchText) {
        filteredConditions = activeConditions.filter(c => 
            c.name.toLowerCase().includes(searchText) ||
            wfrpConditions[c.name]?.description.toLowerCase().includes(searchText)
        );
    }
    
    if (filteredConditions.length === 0) {
        noConditionsMsg.style.display = 'block';
        display.style.display = 'none';
    } else {
        noConditionsMsg.style.display = 'none';
        display.style.display = 'grid';
        
        filteredConditions.forEach(condition => {
            const conditionData = wfrpConditions[condition.name];
            if (!conditionData) return;
            
            const conditionCard = document.createElement('div');
            const severityColor = window.getSeverityColor(conditionData.severity);
            const displayName = window.getConditionDisplayName(condition.name, condition.stacks);
            
            conditionCard.style.cssText = `
                background: #faf8f3;
                border: 2px solid ${severityColor};
                border-radius: 5px;
                padding: 12px;
                position: relative;
            `;
            
            conditionCard.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h4 style="margin: 0; color: ${severityColor}; font-size: 16px;">${displayName}</h4>
                    <button onclick="window.removeCondition('${condition.name}', ${condition.stacks})" 
                            style="background: #c41e3a; color: white; border: none; width: 20px; height: 20px; border-radius: 3px; cursor: pointer; font-size: 12px; font-weight: bold;">Ã—</button>
                </div>
                <p style="font-size: 12px; color: #333; line-height: 1.3; margin: 0 0 10px 0;">${conditionData.description}</p>
                <div style="display: flex; gap: 5px; align-items: center;">
                    ${conditionData.stackable ? 
                        `<button onclick="window.removeCondition('${condition.name}', 1)" style="width: 20px; height: 20px; background: #e8dfd0; border: 1px solid #8b7355; cursor: pointer;">âˆ’</button>
                         <span style="font-size: 12px; color: #666; min-width: 40px; text-align: center;">Stacks: ${condition.stacks}</span>
                         <button onclick="window.addCondition('${condition.name}', 1)" style="width: 20px; height: 20px; background: #e8dfd0; border: 1px solid #8b7355; cursor: pointer;">+</button>`
                        : '<span style="font-size: 12px; color: #666;">Cannot stack</span>'
                    }
                </div>
            `;
            
            display.appendChild(conditionCard);
        });
    }
    
    // Update penalty display
    window.displayConditionPenalties();
}

window.getActiveConditionPenalties = function() {
    const penalties = {
        allTests: 0,
        movementTests: 0,
        sightTests: 0,
        hearingTests: 0,
        specialEffects: []
    };
    
    activeConditions.forEach(condition => {
        const conditionData = wfrpConditions[condition.name];
        if (!conditionData) return;
        
        const stacks = condition.stacks || 1;
        const effects = conditionData.effects;
        
        // Calculate cumulative penalties
        if (effects.allTests) {
            penalties.allTests += effects.allTests * stacks;
        }
        if (effects.movementTests) {
            penalties.movementTests += effects.movementTests * stacks;
        }
        if (effects.sightTests) {
            penalties.sightTests += effects.sightTests * stacks;
        }
        if (effects.hearingTests) {
            penalties.hearingTests += effects.hearingTests * stacks;
        }
        
        // Special effects (non-stacking)
        if (effects.noActions) {
            penalties.specialEffects.push('Cannot take Actions');
        }
        if (effects.noMovement) {
            penalties.specialEffects.push('Cannot move');
        }
        if (effects.mustFlee) {
            penalties.specialEffects.push('Must flee/hide');
        }
        if (effects.incapacitated) {
            penalties.specialEffects.push('Incapacitated');
        }
        if (effects.damage) {
            const damageText = stacks > 1 && effects.damagePerStack ? 
                `${effects.damage} ${effects.damagePerStack.replace('+1', `+${stacks-1}`)}` : 
                effects.damage;
            penalties.specialEffects.push(`Damage: ${damageText}/round`);
        }
    });
    
    return penalties;
}

window.displayConditionPenalties = function() {
    const penalties = window.getActiveConditionPenalties();
    const summaryDiv = document.getElementById('condition-penalties-summary');
    const penaltyText = document.getElementById('penalty-text');
    
    const penaltyStrings = [];
    
    // Test penalties
    if (penalties.allTests !== 0) {
        penaltyStrings.push(`All Tests ${penalties.allTests >= 0 ? '+' : ''}${penalties.allTests}`);
    }
    if (penalties.movementTests !== 0) {
        penaltyStrings.push(`Movement Tests ${penalties.movementTests >= 0 ? '+' : ''}${penalties.movementTests}`);
    }
    if (penalties.sightTests !== 0) {
        penaltyStrings.push(`Sight Tests ${penalties.sightTests >= 0 ? '+' : ''}${penalties.sightTests}`);
    }
    if (penalties.hearingTests !== 0) {
        penaltyStrings.push(`Hearing Tests ${penalties.hearingTests >= 0 ? '+' : ''}${penalties.hearingTests}`);
    }
    
    // Special effects
    penalties.specialEffects.forEach(effect => penaltyStrings.push(effect));
    
    if (penaltyStrings.length > 0) {
        penaltyText.textContent = penaltyStrings.join(' â€¢ ');
        summaryDiv.style.display = 'block';
    } else {
        summaryDiv.style.display = 'none';
    }
}

window.openAddConditionModal = function() {
    window.populateConditionSelect();
    document.getElementById('add-condition-modal').style.display = 'block';
}

window.populateConditionSelect = function() {
    const select = document.getElementById('condition-select');
    select.innerHTML = '<option value="">-- Choose a condition --</option>';
    
    Object.keys(wfrpConditions).sort().forEach(conditionName => {
        const option = document.createElement('option');
        option.value = conditionName;
        option.textContent = conditionName;
        select.appendChild(option);
    });
}

window.showConditionDetails = function() {
    const select = document.getElementById('condition-select');
    const selectedCondition = select.value;
    
    if (!selectedCondition || !wfrpConditions[selectedCondition]) {
        document.getElementById('condition-details').style.display = 'none';
        document.getElementById('stacks-input-section').style.display = 'none';
        return;
    }
    
    const conditionData = wfrpConditions[selectedCondition];
    const severityColor = window.getSeverityColor(conditionData.severity);
    
    // Update details display
    document.getElementById('detail-condition-name').textContent = selectedCondition;
    document.getElementById('detail-condition-stackable').textContent = conditionData.stackable ? 'Yes' : 'No';
    document.getElementById('detail-condition-effects').textContent = conditionData.description;
    
    // Update severity badge
    const badge = document.getElementById('condition-severity-badge');
    badge.textContent = conditionData.severity.toUpperCase();
    badge.style.backgroundColor = severityColor;
    
    document.getElementById('condition-details').style.display = 'block';
    
    // Show stacks input for stackable conditions
    if (conditionData.stackable) {
        document.getElementById('stacks-input-section').style.display = 'block';
    } else {
        document.getElementById('stacks-input-section').style.display = 'none';
    }
}

window.confirmAddCondition = function() {
    const select = document.getElementById('condition-select');
    const selectedCondition = select.value;
    
    if (!selectedCondition) {
        alert('Please select a condition');
        return;
    }
    
    const conditionData = wfrpConditions[selectedCondition];
    const stacksToAdd = conditionData.stackable ? 
        parseInt(document.getElementById('condition-stacks-input').value) || 1 : 1;
    
    if (window.addCondition(selectedCondition, stacksToAdd)) {
        window.closeAddConditionModal();
    }
}

window.closeAddConditionModal = function() {
    document.getElementById('add-condition-modal').style.display = 'none';
    document.getElementById('condition-select').value = '';
    document.getElementById('condition-stacks-input').value = '1';
    document.getElementById('condition-details').style.display = 'none';
    document.getElementById('stacks-input-section').style.display = 'none';
}

// Add search listener for conditions
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('conditions-search')?.addEventListener('input', function() {
        window.updateConditionDisplay();
    });
});

// Critical Wounds Management System
let woundIdCounter = 1;

// Function to update all characteristics based on critical wound penalties
window.updateAllCharacteristicsFromWounds = function() {
    const characteristics = ['ws', 'bs', 's', 't', 'i', 'ag', 'dex', 'int', 'wp', 'fel'];
    characteristics.forEach(char => {
        const initialInput = document.getElementById(`${char}-initial`);
        if (initialInput) {
            // Trigger the input event to recalculate current value
            initialInput.dispatchEvent(new Event('input'));
        }
    });
}

// Function to get skill penalties from critical wounds
window.getSkillPenaltiesFromWounds = function(skillName) {
    let totalPenalty = 0;
    const penalties = [];
    
    criticalWounds.forEach(wound => {
        // Check permanent effects for skill penalties
        if (wound.permanentEffects) {
            wound.permanentEffects.forEach(effect => {
                // Language Tests penalties
                if (effect.includes('Language Tests') && isLanguageSkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
                // Ranged Tests penalties
                else if (effect.includes('Ranged Tests') && isRangedSkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
                // Movement Tests penalties  
                else if (effect.includes('Movement Tests') && isMovementSkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
                // Hearing Tests penalties
                else if (effect.includes('Hearing Tests') && isHearingSkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
                // Sight Tests penalties
                else if (effect.includes('Sight Tests') && isSightSkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
                // Dexterity Tests penalties
                else if (effect.includes('Dexterity Tests') && isDexteritySkill(skillName)) {
                    const penaltyMatch = effect.match(/-(\d+)/);
                    if (penaltyMatch) {
                        const penalty = parseInt(penaltyMatch[1]);
                        totalPenalty += penalty;
                        penalties.push(`${wound.name}: -${penalty}`);
                    }
                }
            });
        }
        
        // Check injury effects
        if (wound.injuries) {
            wound.injuries.forEach(injuryName => {
                const injury = injuryTypes[injuryName];
                if (injury && injury.effects[wound.location.replace(/^(Left |Right )/, '')]) {
                    const effect = injury.effects[wound.location.replace(/^(Left |Right )/, '')];
                    
                    // Check for specific skill penalties in injury effects
                    if (effect.includes('-10 to Tests using arm') && isArmBasedSkill(skillName)) {
                        totalPenalty += 10;
                        penalties.push(`${wound.name} (${injuryName}): -10`);
                    } else if (effect.includes('-20 to Tests using arm') && isArmBasedSkill(skillName)) {
                        totalPenalty += 20;
                        penalties.push(`${wound.name} (${injuryName}): -20`);
                    } else if (effect.includes('-10 to Tests using leg') && isLegBasedSkill(skillName)) {
                        totalPenalty += 10;
                        penalties.push(`${wound.name} (${injuryName}): -10`);
                    } else if (effect.includes('-20 to Tests using leg') && isLegBasedSkill(skillName)) {
                        totalPenalty += 20;
                        penalties.push(`${wound.name} (${injuryName}): -20`);
                    } else if (effect.includes('-10 to head-based Tests') && isHeadBasedSkill(skillName)) {
                        totalPenalty += 10;
                        penalties.push(`${wound.name} (${injuryName}): -10`);
                    } else if (effect.includes('-20 to head-based Tests') && isHeadBasedSkill(skillName)) {
                        totalPenalty += 20;
                        penalties.push(`${wound.name} (${injuryName}): -20`);
                    } else if (effect.includes('-10 to body-based Tests') && isBodyBasedSkill(skillName)) {
                        totalPenalty += 10;
                        penalties.push(`${wound.name} (${injuryName}): -10`);
                    } else if (effect.includes('-20 to body-based Tests') && isBodyBasedSkill(skillName)) {
                        totalPenalty += 20;
                        penalties.push(`${wound.name} (${injuryName}): -20`);
                    }
                }
            });
        }
    });
    
    return { totalPenalty, penalties };
}

// Helper functions to determine skill categories
function isLanguageSkill(skillName) {
    return skillName.includes('Language') || skillName === 'Language (Classical)' || skillName === 'Language (Guilder)';
}

function isRangedSkill(skillName) {
    return skillName === 'Ranged (Bow)' || skillName === 'Ranged (Crossbow)' || skillName === 'Ranged (Engineering)' || 
           skillName === 'Ranged (Entangling)' || skillName === 'Ranged (Explosives)' || skillName === 'Ranged (Sling)' || 
           skillName === 'Ranged (Throwing)';
}

function isMovementSkill(skillName) {
    return skillName === 'Athletics' || skillName === 'Climb' || skillName === 'Dodge' || skillName === 'Stealth';
}

function isHearingSkill(skillName) {
    return skillName === 'Perception' || skillName === 'Track';
}

function isSightSkill(skillName) {
    return skillName === 'Perception' || skillName === 'Track' || skillName === 'Art' || 
           skillName.includes('Ranged') || skillName === 'Navigation';
}

function isDexteritySkill(skillName) {
    return skillName === 'Art' || skillName === 'Sleight of Hand' || skillName === 'Pick Lock' || 
           skillName === 'Trade (any)' || skillName.includes('Trade');
}

function isArmBasedSkill(skillName) {
    return skillName.includes('Melee') || skillName.includes('Ranged') || skillName === 'Athletics' || 
           skillName === 'Art' || skillName === 'Sleight of Hand' || skillName === 'Pick Lock' || 
           skillName.includes('Trade');
}

function isLegBasedSkill(skillName) {
    return skillName === 'Athletics' || skillName === 'Climb' || skillName === 'Dodge' || 
           skillName === 'Stealth' || skillName === 'Row';
}

function isHeadBasedSkill(skillName) {
    return skillName.includes('Language') || skillName === 'Entertain (Storytelling)' || 
           skillName === 'Charm' || skillName === 'Gossip' || skillName === 'Leadership';
}

function isBodyBasedSkill(skillName) {
    return skillName === 'Endurance' || skillName === 'Swim' || skillName === 'Athletics';
}

window.getSeverityColorForWound = function(wounds) {
    if (wounds === "Death" || wounds >= 5) return '#000000'; // Fatal
    if (wounds >= 4) return '#c41e3a'; // Severe (red)
    if (wounds >= 2) return '#ff8c00'; // Moderate (orange)
    return '#ffd700'; // Minor (yellow)
}

window.addCriticalWound = function(woundData) {
    const wound = {
        id: woundIdCounter++,
        name: woundData.name || "Unknown Wound",
        location: woundData.location || "Unknown",
        wounds: woundData.wounds || 0,
        effects: woundData.effects || "",
        healingTime: woundData.healingTime || 0,
        daysHealed: woundData.daysHealed || 0,
        permanent: woundData.permanent || false,
        surgeryRequired: woundData.surgeryRequired || false,
        notes: woundData.notes || "",
        conditions: woundData.conditions || [],
        injuries: woundData.injuries || [],
        permanentEffects: woundData.permanentEffects || [],
        amputation: woundData.amputation || null,
        dateAdded: new Date().toLocaleDateString()
    };
    
    criticalWounds.push(wound);
    
    // Auto-add conditions if specified
    if (wound.conditions && wound.conditions.length > 0) {
        wound.conditions.forEach(condition => {
            window.addCondition(condition, 1);
        });
    }
    
    window.displayCriticalWounds();
    window.updateWoundPenalties();
    window.updateAllCharacteristicsFromWounds();
    // Update all skills to reflect wound penalties
    if (typeof window.updateAllSkillTotals === 'function') {
        window.updateAllSkillTotals();
    }
    return wound.id;
}

window.removeCriticalWound = function(woundId) {
    const woundIndex = criticalWounds.findIndex(w => w.id === parseInt(woundId));
    if (woundIndex === -1) {
        console.warn('Wound not found:', woundId);
        return false;
    }
    
    const wound = criticalWounds[woundIndex];
    if (confirm(`Remove critical wound "${wound.name}" from ${wound.location}?`)) {
        criticalWounds.splice(woundIndex, 1);
        window.displayCriticalWounds();
        window.updateWoundPenalties();
        window.updateAllCharacteristicsFromWounds();
        // Update all skills to reflect wound penalties
        if (typeof window.updateAllSkillTotals === 'function') {
            window.updateAllSkillTotals();
        }
        return true;
    }
    return false;
}

window.updateWoundHealing = function(woundId, daysChange) {
    const wound = criticalWounds.find(w => w.id === parseInt(woundId));
    if (!wound) {
        console.warn('Wound not found:', woundId);
        return;
    }
    
    if (wound.permanent) {
        alert('This is a permanent injury and cannot be healed through time.');
        return;
    }
    
    wound.daysHealed = Math.max(0, wound.daysHealed + daysChange);
    
    // Check if fully healed
    if (wound.daysHealed >= wound.healingTime && wound.healingTime > 0) {
        if (confirm(`"${wound.name}" appears to be fully healed (${wound.daysHealed}/${wound.healingTime} days). Remove this wound?`)) {
            window.removeCriticalWound(woundId);
            return;
        }
    }
    
    window.displayCriticalWounds();
}

window.displayCriticalWounds = function() {
    const tbody = document.getElementById('wounds-tbody');
    const noWoundsMsg = document.getElementById('no-wounds-message');
    const searchText = (document.getElementById('wounds-search')?.value || '').toLowerCase();
    
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    let displayedWounds = criticalWounds;
    
    // Apply search filter
    if (searchText) {
        displayedWounds = displayedWounds.filter(w => 
            w.name.toLowerCase().includes(searchText) ||
            w.location.toLowerCase().includes(searchText) ||
            w.effects.toLowerCase().includes(searchText) ||
            w.notes.toLowerCase().includes(searchText)
        );
    }
    
    if (displayedWounds.length === 0) {
        noWoundsMsg.style.display = 'block';
        document.getElementById('active-wounds-display').style.display = 'none';
    } else {
        noWoundsMsg.style.display = 'none';
        document.getElementById('active-wounds-display').style.display = 'block';
        
        displayedWounds.forEach(wound => {
            const row = document.createElement('tr');
            const severityColor = window.getSeverityColorForWound(wound.wounds);
            
            // Determine healing display
            let healingDisplay = '';
            if (wound.permanent) {
                healingDisplay = '<span style="color: #8b0000; font-weight: bold;">Permanent</span>';
            } else if (wound.healingTime > 0) {
                const percentage = Math.min(100, (wound.daysHealed / wound.healingTime) * 100);
                healingDisplay = `
                    <div style="text-align: center;">
                        <div style="font-size: 12px; margin-bottom: 3px;">Day ${wound.daysHealed} of ${wound.healingTime}</div>
                        <div style="width: 100%; background: #e0e0e0; height: 8px; border-radius: 4px; margin-bottom: 5px;">
                            <div style="width: ${percentage}%; background: #4CAF50; height: 100%; border-radius: 4px;"></div>
                        </div>
                        <div style="display: flex; gap: 2px; justify-content: center;">
                            <button onclick="window.updateWoundHealing(${wound.id}, -1)" style="width: 20px; height: 20px; background: #e8dfd0; border: 1px solid #8b7355; cursor: pointer; font-size: 12px;">âˆ’</button>
                            <button onclick="window.updateWoundHealing(${wound.id}, 1)" style="width: 20px; height: 20px; background: #e8dfd0; border: 1px solid #8b7355; cursor: pointer; font-size: 12px;">+</button>
                        </div>
                    </div>
                `;
            } else {
                healingDisplay = '<span style="color: #666; font-style: italic;">No healing time set</span>';
            }
            
            // Effects display with truncation
            let effectsDisplay = wound.effects;
            if (effectsDisplay.length > 100) {
                effectsDisplay = effectsDisplay.substring(0, 97) + '...';
            }
            
            row.style.borderLeft = `4px solid ${severityColor}`;
            row.innerHTML = `
                <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top;">
                    <div style="font-weight: bold; color: ${severityColor}; margin-bottom: 3px;">${wound.name}</div>
                    ${wound.surgeryRequired ? '<div style="font-size: 10px; color: #c41e3a; font-weight: bold;">âš•ï¸ Surgery Required</div>' : ''}
                    ${wound.wounds === "Death" ? '<div style="font-size: 10px; color: #000; font-weight: bold;">ðŸ’€ Fatal</div>' : `<div style="font-size: 10px; color: #666;">Wounds: ${wound.wounds}</div>`}
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle;">
                    <span style="font-weight: bold;">${wound.location}</span>
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle; min-width: 120px;">
                    ${healingDisplay}
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top; max-width: 200px;">
                    <div style="font-size: 12px; line-height: 1.3;">${effectsDisplay}</div>
                    ${wound.notes ? `<div style="font-size: 11px; color: #666; margin-top: 5px; font-style: italic;">${wound.notes}</div>` : ''}
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle;">
                    <div style="display: flex; flex-direction: column; gap: 3px;">
                        <button onclick="window.editCriticalWound(${wound.id})" style="padding: 3px 6px; font-size: 10px; background: #4682b4; color: white; border: none; cursor: pointer; border-radius: 2px;">Edit</button>
                        ${!wound.permanent && wound.healingTime > 0 ? `<button onclick="window.markWoundHealed(${wound.id})" style="padding: 3px 6px; font-size: 10px; background: #4CAF50; color: white; border: none; cursor: pointer; border-radius: 2px;">Healed</button>` : ''}
                        <button onclick="window.removeCriticalWound(${wound.id})" style="padding: 3px 6px; font-size: 10px; background: #c41e3a; color: white; border: none; cursor: pointer; border-radius: 2px;">Remove</button>
                    </div>
                </td>
            `;
            
            tbody.appendChild(row);
        });
    }
}

window.markWoundHealed = function(woundId) {
    const wound = criticalWounds.find(w => w.id === parseInt(woundId));
    if (!wound) return;
    
    if (confirm(`Mark "${wound.name}" as fully healed and remove from wounds list?`)) {
        window.removeCriticalWound(woundId);
    }
}

window.editCriticalWound = function(woundId) {
    const wound = criticalWounds.find(w => w.id === parseInt(woundId));
    if (!wound) return;
    
    // Populate edit modal with current wound data
    document.getElementById('wound-name-input').value = wound.name;
    document.getElementById('wound-location-select').value = wound.location;
    document.getElementById('wound-wounds-input').value = wound.wounds === "Death" ? "" : wound.wounds;
    document.getElementById('wound-healing-time-input').value = wound.healingTime;
    document.getElementById('wound-effects-input').value = wound.effects;
    document.getElementById('wound-notes-input').value = wound.notes;
    document.getElementById('wound-permanent-checkbox').checked = wound.permanent;
    document.getElementById('wound-surgery-checkbox').checked = wound.surgeryRequired;
    
    // Store the wound ID for editing
    window.editingWoundId = woundId;
    
    // Change modal title and button text
    document.querySelector('#add-wound-modal h3').textContent = 'Edit Critical Wound';
    document.querySelector('#add-wound-modal .control-btn').textContent = 'Save Changes';
    
    window.openAddWoundModal();
}

window.getCriticalWoundPenalties = function() {
    const penalties = {
        characteristics: {},
        tests: {},
        movement: 0,
        specialEffects: []
    };
    
    criticalWounds.forEach(wound => {
        // Parse permanent effects
        if (wound.permanentEffects) {
            wound.permanentEffects.forEach(effect => {
                if (effect.includes('Intelligence')) {
                    penalties.characteristics.Int = (penalties.characteristics.Int || 0) - 10;
                } else if (effect.includes('Willpower')) {
                    penalties.characteristics.WP = (penalties.characteristics.WP || 0) - 10;
                } else if (effect.includes('Fellowship')) {
                    penalties.characteristics.Fel = (penalties.characteristics.Fel || 0) - 10;
                } else if (effect.includes('Strength')) {
                    penalties.characteristics.S = (penalties.characteristics.S || 0) - 30;
                } else if (effect.includes('Agility')) {
                    penalties.characteristics.Ag = (penalties.characteristics.Ag || 0) - 30;
                } else if (effect.includes('Dexterity Tests')) {
                    penalties.tests.Dex = (penalties.tests.Dex || 0) - 20;
                } else if (effect.includes('Ranged Tests')) {
                    penalties.tests.Ranged = (penalties.tests.Ranged || 0) - 20;
                } else if (effect.includes('Language Tests')) {
                    penalties.tests.Language = (penalties.tests.Language || 0) - 10;
                } else if (effect.includes('Movement Tests')) {
                    penalties.tests.Movement = (penalties.tests.Movement || 0) - 20;
                } else if (effect.includes('half Movement') || effect.includes('half Move')) {
                    penalties.movement = Math.max(penalties.movement, 0.5);
                } else if (effect.includes('unusable') || effect.includes('lost')) {
                    penalties.specialEffects.push(effect);
                }
            });
        }
        
        // Apply injury effects
        if (wound.injuries) {
            wound.injuries.forEach(injuryName => {
                const injury = injuryTypes[injuryName];
                if (injury && injury.effects[wound.location.replace(/^(Left |Right )/, '')]) {
                    const effect = injury.effects[wound.location.replace(/^(Left |Right )/, '')];
                    if (effect.includes('-30 Strength')) {
                        penalties.characteristics.S = (penalties.characteristics.S || 0) - 30;
                    }
                    if (effect.includes('-30 Agility')) {
                        penalties.characteristics.Ag = (penalties.characteristics.Ag || 0) - 30;
                    }
                    if (effect.includes('half Move')) {
                        penalties.movement = Math.max(penalties.movement, 0.5);
                    }
                    if (effect.includes('unusable')) {
                        penalties.specialEffects.push(`${wound.location} unusable (${injuryName})`);
                    }
                }
            });
        }
        
        // Special wound effects
        if (wound.amputation) {
            penalties.specialEffects.push(`${wound.amputation} amputated`);
        }
    });
    
    return penalties;
}

window.updateWoundPenalties = function() {
    const penalties = window.getCriticalWoundPenalties();
    const summaryDiv = document.getElementById('wound-penalties-summary');
    const penaltyText = document.getElementById('wound-penalty-text');
    
    const penaltyStrings = [];
    
    // Characteristic penalties
    Object.keys(penalties.characteristics).forEach(char => {
        const penalty = penalties.characteristics[char];
        if (penalty !== 0) {
            penaltyStrings.push(`${char} ${penalty >= 0 ? '+' : ''}${penalty}`);
        }
    });
    
    // Test penalties
    Object.keys(penalties.tests).forEach(testType => {
        const penalty = penalties.tests[testType];
        if (penalty !== 0) {
            penaltyStrings.push(`${testType} Tests ${penalty >= 0 ? '+' : ''}${penalty}`);
        }
    });
    
    // Movement penalties
    if (penalties.movement > 0) {
        if (penalties.movement === 0.5) {
            penaltyStrings.push('Movement halved');
        } else {
            penaltyStrings.push(`Movement -${penalties.movement}`);
        }
    }
    
    // Special effects
    penalties.specialEffects.forEach(effect => penaltyStrings.push(effect));
    
    if (penaltyStrings.length > 0) {
        penaltyText.textContent = penaltyStrings.join(' â€¢ ');
        summaryDiv.style.display = 'block';
    } else {
        summaryDiv.style.display = 'none';
    }
}

window.removeAllWounds = function() {
    if (criticalWounds.length === 0) {
        alert('No critical wounds to remove!');
        return;
    }
    
    if (confirm(`Remove all ${criticalWounds.length} critical wounds?`)) {
        criticalWounds.length = 0;
        window.displayCriticalWounds();
        window.updateWoundPenalties();
        window.updateAllCharacteristicsFromWounds();
        // Update all skills to reflect wound penalties
        if (typeof window.updateAllSkillTotals === 'function') {
            window.updateAllSkillTotals();
        }
    }
}

window.openAddWoundModal = function() {
    // Reset form if not editing
    if (!window.editingWoundId) {
        document.getElementById('wound-name-input').value = '';
        document.getElementById('wound-location-select').value = '';
        document.getElementById('wound-wounds-input').value = '';
        document.getElementById('wound-healing-time-input').value = '';
        document.getElementById('wound-effects-input').value = '';
        document.getElementById('wound-notes-input').value = '';
        document.getElementById('wound-permanent-checkbox').checked = false;
        document.getElementById('wound-surgery-checkbox').checked = false;
        
        // Reset modal title and button
        document.querySelector('#add-wound-modal h3').textContent = 'Add Critical Wound';
        document.querySelector('#add-wound-modal .control-btn').textContent = 'Add Wound';
    }
    
    document.getElementById('add-wound-modal').style.display = 'block';
}

window.closeAddWoundModal = function() {
    document.getElementById('add-wound-modal').style.display = 'none';
    window.editingWoundId = null;
}

window.confirmAddWound = function() {
    const name = document.getElementById('wound-name-input').value.trim();
    const location = document.getElementById('wound-location-select').value;
    const wounds = document.getElementById('wound-wounds-input').value;
    const healingTime = parseInt(document.getElementById('wound-healing-time-input').value) || 0;
    const effects = document.getElementById('wound-effects-input').value.trim();
    const notes = document.getElementById('wound-notes-input').value.trim();
    const permanent = document.getElementById('wound-permanent-checkbox').checked;
    const surgeryRequired = document.getElementById('wound-surgery-checkbox').checked;
    
    if (!name) {
        alert('Please enter a wound name');
        return;
    }
    
    if (!location) {
        alert('Please select a location');
        return;
    }
    
    const woundData = {
        name: name,
        location: location,
        wounds: wounds || 0,
        healingTime: permanent ? 0 : healingTime,
        effects: effects,
        notes: notes,
        permanent: permanent,
        surgeryRequired: surgeryRequired,
        daysHealed: 0
    };
    
    if (window.editingWoundId) {
        // Edit existing wound
        const wound = criticalWounds.find(w => w.id === parseInt(window.editingWoundId));
        if (wound) {
            Object.assign(wound, woundData);
            window.displayCriticalWounds();
            window.updateWoundPenalties();
            window.updateAllCharacteristicsFromWounds();
            // Update all skills to reflect wound penalties
            if (typeof window.updateAllSkillTotals === 'function') {
                window.updateAllSkillTotals();
            }
        }
        window.editingWoundId = null;
    } else {
        // Add new wound
        window.addCriticalWound(woundData);
    }
    
    window.closeAddWoundModal();
}

// Reference Modal Functions
window.openWoundReferenceModal = function() {
    document.getElementById('wound-reference-modal').style.display = 'block';
    window.showWoundLocation('Head'); // Default to Head tab
}

window.closeWoundReferenceModal = function() {
    document.getElementById('wound-reference-modal').style.display = 'none';
}

window.showWoundLocation = function(location) {
    // Update tab appearance
    ['Head', 'Arm', 'Body', 'Leg'].forEach(loc => {
        const tab = document.getElementById(`wound-tab-${loc}`);
        if (loc === location) {
            tab.style.background = '#e8dfd0';
            tab.style.color = '#3e2f1f';
            tab.style.fontWeight = 'bold';
        } else {
            tab.style.background = '#f5f5f0';
            tab.style.color = '#666';
            tab.style.fontWeight = 'normal';
        }
    });
    
    // Get wounds for the selected location
    const searchText = (document.getElementById('wound-reference-search')?.value || '').toLowerCase();
    const content = document.getElementById('wound-reference-content');
    
    const locationWounds = wfrpCriticalWoundsByLocation[location] || {};
    let filteredWounds = Object.entries(locationWounds);
    
    // Apply search filter
    if (searchText) {
        filteredWounds = filteredWounds.filter(([key, wound]) =>
            wound.name.toLowerCase().includes(searchText) ||
            wound.effects.toLowerCase().includes(searchText)
        );
    }
    
    content.innerHTML = '';
    
    if (filteredWounds.length === 0) {
        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No wounds found matching your search.</div>';
        return;
    }
    
    // Create wounds table
    const table = document.createElement('table');
    table.style.cssText = 'width: 100%; border-collapse: collapse; background: #faf8f3; border: 2px solid #8b7355;';
    
    const thead = document.createElement('thead');
    thead.innerHTML = `
        <tr style="background: #e8dfd0; color: #3e2f1f; font-weight: bold;">
            <th style="border: 1px solid #8b7355; padding: 8px; text-align: center; width: 80px;">Roll (d100)</th>
            <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Wound Name</th>
            <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Wounds</th>
            <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Effects</th>
            <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Add</th>
        </tr>
    `;
    table.appendChild(thead);
    
    const tbody = document.createElement('tbody');
    
    filteredWounds.forEach(([rollRange, wound]) => {
        const row = document.createElement('tr');
        const severityColor = window.getSeverityColorForWound(wound.wounds);
        
        row.style.borderLeft = `4px solid ${severityColor}`;
        row.innerHTML = `
            <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle; font-weight: bold; background: #f8f6f0;">
                ${rollRange}
            </td>
            <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top;">
                <div style="font-weight: bold; color: ${severityColor};">${wound.name}</div>
                <div style="font-size: 10px; color: #666; text-transform: uppercase;">${wound.severity}</div>
            </td>
            <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle; font-weight: bold;">
                ${wound.wounds}
            </td>
            <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top; font-size: 12px; line-height: 1.3;">
                ${wound.effects}
            </td>
            <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle;">
                <button onclick="window.selectReferenceWound('${location}', '${rollRange}')" style="padding: 4px 8px; font-size: 10px; background: #4682b4; color: white; border: none; cursor: pointer; border-radius: 2px;">Add This</button>
            </td>
        `;
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    content.appendChild(table);
}

window.selectReferenceWound = function(location, rollRange) {
    const wound = wfrpCriticalWoundsByLocation[location] && wfrpCriticalWoundsByLocation[location][rollRange];
    if (!wound) return;
    
    // Close reference modal
    window.closeWoundReferenceModal();
    
    // Create wound data with defaults
    const woundData = {
        name: wound.name,
        location: wound.location === 'Arm' ? 'Right Arm' : wound.location === 'Leg' ? 'Right Leg' : wound.location,
        wounds: wound.wounds,
        effects: wound.effects,
        healingTime: wound.wounds === "Death" ? 0 : (wound.wounds >= 4 ? 30 : wound.wounds >= 2 ? 14 : 7),
        permanent: wound.severity === 'fatal' && wound.wounds !== "Death",
        surgeryRequired: wound.surgeryRequired || false,
        conditions: wound.conditions || [],
        injuries: wound.injuries || [],
        permanentEffects: wound.permanentEffects || [],
        amputation: wound.amputation || null,
        notes: `From WFRP reference (${wound.severity})`
    };
    
    // Add the wound
    const woundId = window.addCriticalWound(woundData);
    
    // Show success message
    alert(`Added "${wound.name}" to ${woundData.location}. ${wound.conditions ? `Applied ${wound.conditions.length} condition(s).` : ''}`);
}

// Add search listener for wounds
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('wounds-search')?.addEventListener('input', function() {
        window.displayCriticalWounds();
    });
    
    document.getElementById('wound-reference-search')?.addEventListener('input', function() {
        // Re-show current location with new search
        const activeTab = document.querySelector('[id^="wound-tab-"][style*="background: rgb(232, 223, 208)"]');
        if (activeTab) {
            const location = activeTab.id.replace('wound-tab-', '');
            window.showWoundLocation(location);
        }
    });
});

// Disease & Symptom Management System
window.openAddDiseaseModal = function() {
    const modal = document.getElementById('add-disease-modal');
    const select = document.getElementById('disease-select');
    
    // Clear and populate disease dropdown
    select.innerHTML = '<option value="">-- Choose a disease --</option>';
    
    if (srdDiseases && srdDiseases.length > 0) {
        srdDiseases.forEach(disease => {
            const option = document.createElement('option');
            option.value = disease.name;
            option.textContent = disease.name;
            select.appendChild(option);
        });
    }
    
    // Set default contract date to today
    document.getElementById('disease-contract-date').value = new Date().toISOString().split('T')[0];
    
    modal.style.display = 'block';
}

window.closeAddDiseaseModal = function() {
    document.getElementById('add-disease-modal').style.display = 'none';
    document.getElementById('disease-select').value = '';
    document.getElementById('disease-details').style.display = 'none';
    document.getElementById('disease-notes-input').value = '';
}

window.showDiseaseDetails = function() {
    const select = document.getElementById('disease-select');
    const detailsDiv = document.getElementById('disease-details');
    const infoDiv = document.getElementById('disease-info');
    const symptomsDiv = document.getElementById('disease-symptoms');
    
    if (!select.value) {
        detailsDiv.style.display = 'none';
        return;
    }
    
    const disease = srdDiseases.find(d => d.name === select.value);
    if (!disease) return;
    
    // Display disease information
    infoDiv.innerHTML = `
        <h4 style="margin: 0 0 8px 0; color: #3e2f1f;">${disease.name}</h4>
        <p style="margin: 5px 0; font-size: 12px;"><strong>Contraction:</strong> ${disease.contraction || 'N/A'}</p>
        <p style="margin: 5px 0; font-size: 12px;"><strong>Incubation:</strong> ${disease.incubation || 'N/A'}</p>
        <p style="margin: 5px 0; font-size: 12px;"><strong>Duration:</strong> ${disease.duration || 'N/A'}</p>
        ${disease.permanent ? `<p style="margin: 5px 0; font-size: 12px;"><strong>Permanent:</strong> ${disease.permanent}</p>` : ''}
    `;
    
    // Display associated symptoms
    if (disease.symptoms && disease.symptoms.length > 0) {
        const symptomDetails = disease.symptoms.map(symptomName => {
            const symptom = srdSymptoms.find(s => s.name.toLowerCase() === symptomName.toLowerCase().replace(/\s+/g, '').replace(/-/g, ''));
            return symptom ? symptom.name : symptomName;
        }).join(', ');
        
        symptomsDiv.innerHTML = `
            <p style="margin: 8px 0 0 0; font-size: 12px;"><strong>Symptoms:</strong> ${symptomDetails}</p>
            <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;"><em>These symptoms will be automatically applied when the disease is added.</em></p>
        `;
    } else {
        symptomsDiv.innerHTML = '';
    }
    
    detailsDiv.style.display = 'block';
}

window.confirmAddDisease = function() {
    const select = document.getElementById('disease-select');
    const contractDate = document.getElementById('disease-contract-date').value;
    const notes = document.getElementById('disease-notes-input').value;
    
    if (!select.value) {
        alert('Please select a disease');
        return;
    }
    
    if (!contractDate) {
        alert('Please enter a contract date');
        return;
    }
    
    const disease = srdDiseases.find(d => d.name === select.value);
    if (!disease) return;
    
    // Check if disease already exists
    const existingDisease = character.diseaseTracking.activeDiseases.find(d => d.name === disease.name);
    if (existingDisease) {
        alert(`${disease.name} is already affecting this character`);
        return;
    }
    
    // Create disease object
    const newDisease = {
        id: diseaseIdCounter++,
        name: disease.name,
        contractDate: contractDate,
        notes: notes,
        symptoms: disease.symptoms || [],
        diseaseData: disease
    };
    
    // Add to character
    character.diseaseTracking.activeDiseases.push(newDisease);
    
    // Apply symptoms automatically
    if (disease.symptoms && disease.symptoms.length > 0) {
        disease.symptoms.forEach(symptomName => {
            // Find matching symptom (handle different naming formats)
            const matchingSymptom = srdSymptoms.find(s => 
                s.name.toLowerCase() === symptomName.toLowerCase() ||
                s.name.toLowerCase().replace(/\s+/g, '') === symptomName.toLowerCase().replace(/\s+/g, '').replace(/-/g, '')
            );
            
            if (matchingSymptom) {
                // Add symptom to active list if not already present
                const activeSymptoms = window.getActiveSymptoms();
                if (!activeSymptoms.includes(matchingSymptom.name)) {
                    activeSymptoms.push(matchingSymptom.name);
                }
            }
        });
    }
    
    // Refresh displays
    window.displayActiveDiseases();
    window.updateSymptomEffects();
    window.closeAddDiseaseModal();
}

window.getActiveSymptoms = function() {
    // Get symptoms from all active diseases
    const activeSymptoms = [];
    character.diseaseTracking.activeDiseases.forEach(disease => {
        if (disease.symptoms) {
            disease.symptoms.forEach(symptomName => {
                // Find matching symptom in srdSymptoms
                const matchingSymptom = srdSymptoms.find(s => 
                    s.name.toLowerCase() === symptomName.toLowerCase() ||
                    s.name.toLowerCase().replace(/\s+/g, '') === symptomName.toLowerCase().replace(/\s+/g, '').replace(/-/g, '')
                );
                
                if (matchingSymptom && !activeSymptoms.includes(matchingSymptom.name)) {
                    activeSymptoms.push(matchingSymptom.name);
                }
            });
        }
    });
    return activeSymptoms;
}

window.displayActiveDiseases = function() {
    const display = document.getElementById('active-diseases-display');
    const noDiseasesMsg = document.getElementById('no-diseases-message');
    const searchText = (document.getElementById('diseases-search')?.value || '').toLowerCase();
    
    if (!display) return;
    
    // Clear current display
    display.innerHTML = '';
    
    const activeDiseases = character.diseaseTracking.activeDiseases || [];
    let filteredDiseases = activeDiseases;
    
    // Apply search filter
    if (searchText) {
        filteredDiseases = activeDiseases.filter(disease => 
            disease.name.toLowerCase().includes(searchText) ||
            (disease.notes && disease.notes.toLowerCase().includes(searchText))
        );
    }
    
    if (filteredDiseases.length === 0) {
        noDiseasesMsg.style.display = 'block';
        return;
    }
    
    noDiseasesMsg.style.display = 'none';
    
    filteredDiseases.forEach(disease => {
        const diseaseCard = document.createElement('div');
        diseaseCard.style.cssText = 'background: white; border: 2px solid #8b7355; border-radius: 5px; padding: 15px; position: relative;';
        
        const contractDate = new Date(disease.contractDate).toLocaleDateString();
        const daysSince = Math.floor((new Date() - new Date(disease.contractDate)) / (1000 * 60 * 60 * 24));
        
        // Build symptoms display
        let symptomsDisplay = 'None';
        if (disease.symptoms && disease.symptoms.length > 0) {
            symptomsDisplay = disease.symptoms.map(symptomName => {
                const symptom = srdSymptoms.find(s => 
                    s.name.toLowerCase() === symptomName.toLowerCase() ||
                    s.name.toLowerCase().replace(/\s+/g, '') === symptomName.toLowerCase().replace(/\s+/g, '').replace(/-/g, '')
                );
                return symptom ? symptom.name : symptomName;
            }).join(', ');
        }
        
        diseaseCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #3e2f1f; font-size: 14px;">${disease.name}</h4>
                <div>
                    <button onclick="window.editDisease(${disease.id})" style="padding: 3px 6px; font-size: 10px; margin-right: 5px; cursor: pointer;">Edit</button>
                    <button onclick="window.removeDisease(${disease.id})" style="padding: 3px 6px; font-size: 10px; background: #d44; color: white; cursor: pointer;">Remove</button>
                </div>
            </div>
            <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
                <strong>Contracted:</strong> ${contractDate} (${daysSince} days ago)
            </div>
            <div style="font-size: 11px; margin-bottom: 8px;">
                <strong>Symptoms:</strong> <span style="color: #8b4513;">${symptomsDisplay}</span>
            </div>
            ${disease.notes ? `<div style="font-size: 11px; margin-bottom: 8px;"><strong>Notes:</strong> ${disease.notes}</div>` : ''}
            <div style="font-size: 10px; color: #666;">
                <strong>Duration:</strong> ${disease.diseaseData?.duration || 'Unknown'} â€¢ 
                <strong>Incubation:</strong> ${disease.diseaseData?.incubation || 'Unknown'}
            </div>
        `;
        
        display.appendChild(diseaseCard);
    });
}

window.removeDisease = function(diseaseId) {
    const disease = character.diseaseTracking.activeDiseases.find(d => d.id === diseaseId);
    if (!disease) return;
    
    if (confirm(`Remove ${disease.name}? This will also remove associated symptoms.`)) {
        // Remove the disease
        const index = character.diseaseTracking.activeDiseases.findIndex(d => d.id === diseaseId);
        if (index !== -1) {
            character.diseaseTracking.activeDiseases.splice(index, 1);
        }
        
        // Refresh displays
        window.displayActiveDiseases();
        window.updateSymptomEffects();
    }
}

window.removeAllDiseases = function() {
    if (character.diseaseTracking.activeDiseases.length === 0) {
        alert('No diseases to remove');
        return;
    }
    
    if (confirm('Remove all diseases and their symptoms?')) {
        character.diseaseTracking.activeDiseases = [];
        window.displayActiveDiseases();
        window.updateSymptomEffects();
    }
}

window.updateSymptomEffects = function() {
    // Get all active symptoms from diseases
    const activeSymptoms = window.getActiveSymptoms();
    
    // Calculate combined effects
    const combinedEffects = {};
    activeSymptoms.forEach(symptomName => {
        const symptom = srdSymptoms.find(s => s.name === symptomName);
        if (symptom && symptom.mechanicalEffects) {
            Object.entries(symptom.mechanicalEffects).forEach(([key, value]) => {
                combinedEffects[key] = (combinedEffects[key] || 0) + value;
            });
        }
    });
    
    // Display effects summary
    const summary = document.getElementById('symptom-effects-summary');
    const text = document.getElementById('symptom-effects-text');
    
    if (Object.keys(combinedEffects).length > 0) {
        const effectStrings = Object.entries(combinedEffects)
            .map(([key, value]) => `${key.charAt(0).toUpperCase() + key.slice(1)}: ${value > 0 ? '+' : ''}${value}`)
            .join(' â€¢ ');
        
        text.textContent = effectStrings;
        summary.style.display = 'block';
    } else {
        summary.style.display = 'none';
    }
    
    // Update characteristic calculations
    window.updateAllCharacteristicsFromSymptoms();
    
    // Check for interactions
    window.checkStatusInteractions();
}

window.updateAllCharacteristicsFromSymptoms = function() {
    const characteristics = ['ws', 'bs', 's', 't', 'i', 'ag', 'dex', 'int', 'wp', 'fel'];
    characteristics.forEach(char => {
        const current = document.getElementById(`${char}-current`);
        if (current && current.updateFunction) {
            current.updateFunction();
        }
    });
}

window.getSymptomPenalties = function() {
    const penalties = {
        characteristics: {},
        tests: {}
    };
    
    const activeSymptoms = window.getActiveSymptoms();
    activeSymptoms.forEach(symptomName => {
        const symptom = srdSymptoms.find(s => s.name === symptomName);
        if (symptom && symptom.mechanicalEffects) {
            Object.entries(symptom.mechanicalEffects).forEach(([key, value]) => {
                if (['fellowship', 'toughness', 'strength', 'agility', 'dexterity', 'intelligence', 'willpower'].includes(key.toLowerCase())) {
                    const charKey = key.charAt(0).toUpperCase() + key.slice(1);
                    penalties.characteristics[charKey] = (penalties.characteristics[charKey] || 0) + value;
                } else {
                    penalties.tests[key] = (penalties.tests[key] || 0) + value;
                }
            });
        }
    });
    
    return penalties;
}

window.checkStatusInteractions = function() {
    const currentActiveConditions = window.activeConditions || [];
    const activeSymptoms = window.getActiveSymptoms();
    const interactions = [];
    
    // Check for condition/symptom overlaps
    currentActiveConditions.forEach(condition => {
        activeSymptoms.forEach(symptomName => {
            const symptom = srdSymptoms.find(s => s.name === symptomName);
            if (symptom && symptom.interactsWith && symptom.interactsWith.includes(condition.name.toLowerCase())) {
                interactions.push(`${symptom.name} interacts with ${condition.name} condition`);
            }
        });
    });
    
    // Check for Fellowship penalties stacking
    let fellowshipPenalties = 0;
    currentActiveConditions.forEach(condition => {
        if (condition.effects && condition.effects.includes('Fellowship')) {
            fellowshipPenalties++;
        }
    });
    
    const symptomPenalties = window.getSymptomPenalties();
    if (symptomPenalties.characteristics.Fellowship && fellowshipPenalties > 0) {
        interactions.push(`Fellowship penalties stacking: Conditions + Symptoms = ${symptomPenalties.characteristics.Fellowship + (fellowshipPenalties * -10)}`);
    }
    
    // Display interactions
    const interactionsDiv = document.getElementById('status-interactions');
    const warningsDiv = document.getElementById('interaction-warnings');
    
    if (interactions.length > 0) {
        warningsDiv.innerHTML = interactions.map(interaction => 
            `<div style="margin-bottom: 5px;">â€¢ ${interaction}</div>`
        ).join('');
        interactionsDiv.style.display = 'block';
    } else {
        interactionsDiv.style.display = 'none';
    }
}

window.updateTestReminders = function() {
    const textarea = document.getElementById('test-reminders');
    if (textarea) {
        character.diseaseTracking.testReminders = textarea.value;
    }
}

// Event listeners for disease tracking
document.addEventListener('DOMContentLoaded', function() {
    const testReminders = document.getElementById('test-reminders');
    const diseasesSearch = document.getElementById('diseases-search');
    
    if (testReminders) {
        testReminders.addEventListener('input', window.updateTestReminders);
    }
    
    if (diseasesSearch) {
        diseasesSearch.addEventListener('input', function() {
            window.displayActiveDiseases();
        });
    }
});

// Corruption & Mutation Management System
window.updateCorruptionThreshold = function() {
    const willpower = parseInt(document.getElementById('wp-current')?.value) || 0;
    const toughness = parseInt(document.getElementById('t-current')?.value) || 0;
    
    const wpBonus = Math.floor(willpower / 10);
    const tBonus = Math.floor(toughness / 10);
    const threshold = wpBonus + tBonus;
    
    character.corruption.threshold = threshold;
    
    const thresholdDisplay = document.getElementById('corruption-threshold');
    if (thresholdDisplay) {
        thresholdDisplay.textContent = threshold;
    }
    
    // Update mutation limits
    const physicalCounter = document.getElementById('physical-mutation-counter');
    const mentalCounter = document.getElementById('mental-corruption-counter');
    
    if (physicalCounter) {
        const physicalCount = character.corruption.physicalMutations.length;
        physicalCounter.textContent = `${physicalCount}/${tBonus}`;
        physicalCounter.style.color = physicalCount >= tBonus ? '#c41e3a' : (physicalCount >= tBonus - 1 ? '#ff8c00' : '#666');
    }
    
    if (mentalCounter) {
        const mentalCount = character.corruption.mentalCorruptions.length;
        mentalCounter.textContent = `${mentalCount}/${wpBonus}`;
        mentalCounter.style.color = mentalCount >= wpBonus ? '#c41e3a' : (mentalCount >= wpBonus - 1 ? '#ff8c00' : '#666');
    }
    
    window.updateCorruptionStatus();
    window.checkCharacterDestruction();
}

window.updateCorruptionStatus = function() {
    const points = parseInt(document.getElementById('corruption-points')?.value) || 0;
    character.corruption.points = points;
    
    const threshold = character.corruption.threshold;
    const testWarning = document.getElementById('corruption-test-warning');
    
    if (points > threshold && threshold > 0) {
        character.corruption.awaitingTest = true;
        if (testWarning) testWarning.style.display = 'block';
    } else {
        character.corruption.awaitingTest = false;
        if (testWarning) testWarning.style.display = 'none';
    }
    
    window.checkCharacterDestruction();
}

window.checkCharacterDestruction = function() {
    const willpower = parseInt(document.getElementById('wp-current')?.value) || 0;
    const toughness = parseInt(document.getElementById('t-current')?.value) || 0;
    const wpBonus = Math.floor(willpower / 10);
    const tBonus = Math.floor(toughness / 10);
    
    const physicalCount = character.corruption.physicalMutations.length;
    const mentalCount = character.corruption.mentalCorruptions.length;
    
    const destructionWarning = document.getElementById('character-destruction-warning');
    const destructionText = document.getElementById('destruction-warning-text');
    const lostWarning = document.getElementById('character-lost-warning');
    
    // Check if character is lost
    if (physicalCount > tBonus || mentalCount > wpBonus) {
        if (lostWarning) lostWarning.style.display = 'block';
        if (destructionWarning) destructionWarning.style.display = 'none';
    }
    // Check if character is at risk
    else if (physicalCount === tBonus || mentalCount === wpBonus) {
        if (destructionWarning) destructionWarning.style.display = 'block';
        if (lostWarning) lostWarning.style.display = 'none';
        
        let warnings = [];
        if (physicalCount === tBonus) {
            warnings.push(`Physical mutations at limit (${physicalCount}/${tBonus})`);
        }
        if (mentalCount === wpBonus) {
            warnings.push(`Mental corruptions at limit (${mentalCount}/${wpBonus})`);
        }
        if (destructionText) {
            destructionText.textContent = warnings.join(' â€¢ ') + ' - One more mutation will destroy this character!';
        }
    }
    // Character approaching risk
    else if (physicalCount === tBonus - 1 || mentalCount === wpBonus - 1) {
        if (destructionWarning) destructionWarning.style.display = 'block';
        if (lostWarning) lostWarning.style.display = 'none';
        
        let warnings = [];
        if (physicalCount === tBonus - 1) {
            warnings.push(`Physical mutations near limit (${physicalCount}/${tBonus})`);
        }
        if (mentalCount === wpBonus - 1) {
            warnings.push(`Mental corruptions near limit (${mentalCount}/${wpBonus})`);
        }
        if (destructionText) {
            destructionText.textContent = warnings.join(' â€¢ ') + ' - Character approaching corruption limits!';
        }
    }
    else {
        if (destructionWarning) destructionWarning.style.display = 'none';
        if (lostWarning) lostWarning.style.display = 'none';
    }
}

window.displayMutations = function() {
    const display = document.getElementById('active-mutations-display');
    const noMutationsMsg = document.getElementById('no-mutations-message');
    const searchText = (document.getElementById('mutations-search')?.value || '').toLowerCase();
    
    if (!display) return;
    
    const allMutations = [
        ...character.corruption.physicalMutations.map(m => ({...m, type: 'physical'})),
        ...character.corruption.mentalCorruptions.map(m => ({...m, type: 'mental'}))
    ];
    
    let filteredMutations = allMutations;
    if (searchText) {
        filteredMutations = allMutations.filter(m => 
            m.name.toLowerCase().includes(searchText) ||
            m.description.toLowerCase().includes(searchText) ||
            m.effect.toLowerCase().includes(searchText)
        );
    }
    
    display.innerHTML = '';
    
    if (filteredMutations.length === 0) {
        noMutationsMsg.style.display = 'block';
        display.style.display = 'none';
    } else {
        noMutationsMsg.style.display = 'none';
        display.style.display = 'block';
        
        const table = document.createElement('table');
        table.style.cssText = 'width: 100%; border-collapse: collapse; background: #faf8f3; border: 2px solid #8b7355;';
        
        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr style="background: #e8dfd0; color: #3e2f1f; font-weight: bold;">
                <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Mutation</th>
                <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Type</th>
                <th style="border: 1px solid #8b7355; padding: 8px; text-align: left;">Effects</th>
                <th style="border: 1px solid #8b7355; padding: 8px; text-align: center;">Action</th>
            </tr>
        `;
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        
        filteredMutations.forEach(mutation => {
            const row = document.createElement('tr');
            const typeColor = mutation.type === 'physical' ? '#c41e3a' : '#4682b4';
            
            row.innerHTML = `
                <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top;">
                    <div style="font-weight: bold; color: ${typeColor};">${mutation.name}</div>
                    <div style="font-size: 11px; font-style: italic; color: #666; margin-top: 3px;">${mutation.description}</div>
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle;">
                    <span style="color: ${typeColor}; font-weight: bold; text-transform: capitalize;">${mutation.type}</span>
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; vertical-align: top; font-size: 12px;">
                    ${mutation.effect}
                    ${mutation.obvious ? '<div style="color: #8b4513; font-size: 10px; margin-top: 5px;">âš ï¸ Obvious mutation</div>' : ''}
                </td>
                <td style="border: 1px solid #8b7355; padding: 8px; text-align: center; vertical-align: middle;">
                    <button onclick="window.removeMutation('${mutation.id}')" style="padding: 4px 8px; font-size: 10px; background: #c41e3a; color: white; border: none; cursor: pointer; border-radius: 2px;">Remove</button>
                </td>
            `;
            
            tbody.appendChild(row);
        });
        
        table.appendChild(tbody);
        display.appendChild(table);
    }
    
    window.updateFellowshipWarning();
}

window.updateFellowshipWarning = function() {
    const obviousMutations = character.corruption.physicalMutations.filter(m => m.obvious);
    const fellowshipWarning = document.getElementById('fellowship-warning');
    const fellowshipText = document.getElementById('fellowship-warning-text');
    
    if (obviousMutations.length > 0 && fellowshipWarning && fellowshipText) {
        fellowshipWarning.style.display = 'block';
        
        let warningText = '<strong>Obvious mutations affecting social interactions:</strong><br>';
        obviousMutations.forEach(mutation => {
            warningText += `â€¢ <strong>${mutation.name}:</strong> ${mutation.fellowshipImpact}<br>`;
        });
        
        fellowshipText.innerHTML = warningText;
    } else if (fellowshipWarning) {
        fellowshipWarning.style.display = 'none';
    }
    
    // Update Fellowship characteristic display
    window.updateCharacteristicWithMutations('fel');
}

window.updateCharacteristicWithMutations = function(charId) {
    const currentField = document.getElementById(`${charId}-current`);
    if (!currentField) return;
    
    const baseValue = parseInt(currentField.value) || 0;
    let mutationModifier = 0;
    
    // Calculate mutation modifiers
    const allMutations = [...character.corruption.physicalMutations, ...character.corruption.mentalCorruptions];
    allMutations.forEach(mutation => {
        if (mutation.modifiers) {
            const charMap = {
                'fel': 'fellowship',
                'int': 'intelligence',
                'agi': 'agility',
                't': 'toughness'
            };
            
            const modKey = charMap[charId] || charId;
            if (mutation.modifiers[modKey]) {
                mutationModifier += mutation.modifiers[modKey];
            }
        }
    });
    
    // Apply modifiers without changing the actual value
    if (mutationModifier !== 0) {
        const displayValue = baseValue + mutationModifier;
        // Show modified value with indicator
        currentField.setAttribute('data-mutation-modifier', mutationModifier);
    }
}

window.openAddMutationModal = function() {
    const modal = document.getElementById('add-mutation-modal');
    const species = document.getElementById('species')?.value || 'Human';
    const guidanceText = document.getElementById('species-guidance-text');
    
    if (guidanceText) {
        const speciesTable = speciesMutationTables[species];
        guidanceText.innerHTML = `<strong>${species}:</strong> Physical Mutations (${speciesTable.physical}), Mental Corruptions (${speciesTable.mental})`;
        
        if (species === 'High Elf' || species === 'Wood Elf') {
            guidanceText.innerHTML += '<br><span style="color: #c41e3a;">Note: Elves can only gain mental corruptions!</span>';
        }
    }
    
    modal.style.display = 'block';
    
    // Reset form
    document.getElementById('mutation-type-select').value = '';
    document.getElementById('mutation-selection').style.display = 'none';
    document.getElementById('mutation-details').style.display = 'none';
    document.getElementById('confirm-add-mutation-btn').disabled = true;
}

window.closeAddMutationModal = function() {
    document.getElementById('add-mutation-modal').style.display = 'none';
}

window.updateMutationOptions = function() {
    const typeSelect = document.getElementById('mutation-type-select');
    const mutationSelection = document.getElementById('mutation-selection');
    const mutationSelect = document.getElementById('mutation-select');
    
    if (!typeSelect.value) {
        mutationSelection.style.display = 'none';
        return;
    }
    
    mutationSelection.style.display = 'block';
    mutationSelect.innerHTML = '<option value="">-- Choose Mutation --</option>';
    
    const mutations = typeSelect.value === 'physical' ? physicalMutations : mentalCorruptions;
    
    Object.entries(mutations).forEach(([range, mutation]) => {
        const option = document.createElement('option');
        option.value = range;
        option.textContent = `[${range}] ${mutation.name}`;
        mutationSelect.appendChild(option);
    });
}

window.showMutationDetails = function() {
    const typeSelect = document.getElementById('mutation-type-select');
    const mutationSelect = document.getElementById('mutation-select');
    const detailsDiv = document.getElementById('mutation-details');
    const confirmBtn = document.getElementById('confirm-add-mutation-btn');
    
    if (!mutationSelect.value) {
        detailsDiv.style.display = 'none';
        confirmBtn.disabled = true;
        return;
    }
    
    const mutations = typeSelect.value === 'physical' ? physicalMutations : mentalCorruptions;
    const mutation = mutations[mutationSelect.value];
    
    if (mutation) {
        document.getElementById('detail-mutation-name').textContent = mutation.name;
        document.getElementById('detail-mutation-description').textContent = mutation.description;
        document.getElementById('detail-mutation-effects').textContent = mutation.effect;
        
        const obviousDiv = document.getElementById('detail-mutation-obvious');
        if (mutation.obvious) {
            obviousDiv.innerHTML = '<span style="color: #c41e3a;">âš ï¸ This is an obvious mutation that will affect social interactions</span>';
        } else {
            obviousDiv.innerHTML = '<span style="color: #4682b4;">âœ“ This mutation can be concealed</span>';
        }
        
        const fellowshipDiv = document.getElementById('detail-mutation-fellowship');
        if (mutation.fellowshipImpact) {
            fellowshipDiv.innerHTML = `<strong>Social Impact:</strong> ${mutation.fellowshipImpact}`;
        } else if (mutation.mentalEffect) {
            fellowshipDiv.innerHTML = `<strong>Mental Effect:</strong> ${mutation.mentalEffect}`;
        } else {
            fellowshipDiv.innerHTML = '';
        }
        
        detailsDiv.style.display = 'block';
        confirmBtn.disabled = false;
    }
}

window.confirmAddMutation = function() {
    const typeSelect = document.getElementById('mutation-type-select');
    const mutationSelect = document.getElementById('mutation-select');
    
    if (!typeSelect.value || !mutationSelect.value) return;
    
    const mutations = typeSelect.value === 'physical' ? physicalMutations : mentalCorruptions;
    const mutation = mutations[mutationSelect.value];
    
    if (!mutation) return;
    
    // Create mutation object with unique ID
    const mutationData = {
        ...mutation,
        id: Date.now(),
        range: mutationSelect.value
    };
    
    // Add to appropriate array
    if (typeSelect.value === 'physical') {
        character.corruption.physicalMutations.push(mutationData);
    } else {
        character.corruption.mentalCorruptions.push(mutationData);
    }
    
    // Reduce corruption by WP Bonus
    const willpower = parseInt(document.getElementById('wp-current')?.value) || 0;
    const wpBonus = Math.floor(willpower / 10);
    const currentCorruption = parseInt(document.getElementById('corruption-points')?.value) || 0;
    const newCorruption = Math.max(0, currentCorruption - wpBonus);
    
    document.getElementById('corruption-points').value = newCorruption;
    character.corruption.points = newCorruption;
    
    // Apply mutation effects to characteristics
    if (mutation.modifiers) {
        Object.keys(mutation.modifiers).forEach(stat => {
            if (stat === 'movement') {
                // Update movement
                const currentMove = parseInt(document.getElementById('movement')?.value) || 0;
                document.getElementById('movement').value = currentMove + mutation.modifiers[stat];
            }
        });
    }
    
    // Update displays
    window.updateCorruptionThreshold();
    window.displayMutations();
    window.updateCorruptionStatus();
    window.closeAddMutationModal();
    
    // Alert about corruption reduction
    alert(`Mutation added! Corruption reduced by ${wpBonus} points (WP Bonus).`);
}

window.removeMutation = function(mutationId) {
    mutationId = parseInt(mutationId);
    
    // Find and remove from physical mutations
    let index = character.corruption.physicalMutations.findIndex(m => m.id === mutationId);
    if (index !== -1) {
        const mutation = character.corruption.physicalMutations[index];
        if (confirm(`Remove physical mutation "${mutation.name}"?`)) {
            // Reverse mutation effects
            if (mutation.modifiers && mutation.modifiers.movement) {
                const currentMove = parseInt(document.getElementById('movement')?.value) || 0;
                document.getElementById('movement').value = currentMove - mutation.modifiers.movement;
            }
            
            character.corruption.physicalMutations.splice(index, 1);
            window.updateCorruptionThreshold();
            window.displayMutations();
            return;
        }
    }
    
    // Find and remove from mental corruptions
    index = character.corruption.mentalCorruptions.findIndex(m => m.id === mutationId);
    if (index !== -1) {
        const mutation = character.corruption.mentalCorruptions[index];
        if (confirm(`Remove mental corruption "${mutation.name}"?`)) {
            character.corruption.mentalCorruptions.splice(index, 1);
            window.updateCorruptionThreshold();
            window.displayMutations();
        }
    }
}

// Spells & Prayers Management Functions
window.displaySpells = function() {
    const tbody = document.getElementById('spells-tbody');
    if (!tbody) return;
    
    const searchText = (document.getElementById('spells-search')?.value || '').toLowerCase();
    const filterType = document.getElementById('spells-filter')?.value || 'all';
    
    tbody.innerHTML = '';
    
    let displayedSpells = spells;
    
    // Apply search filter
    if (searchText) {
        displayedSpells = displayedSpells.filter(s => 
            s.name.toLowerCase().includes(searchText) ||
            s.lore.toLowerCase().includes(searchText) ||
            s.effect.toLowerCase().includes(searchText) ||
            (s.ingredients && s.ingredients.toLowerCase().includes(searchText))
        );
    }
    
    // Apply type filter
    if (filterType !== 'all') {
        if (filterType === 'memorised') {
            displayedSpells = displayedSpells.filter(s => s.memorised);
        } else {
            displayedSpells = displayedSpells.filter(s => s.type === filterType);
        }
    }
    
    displayedSpells.sort((a, b) => a.name.localeCompare(b.name));
    
    displayedSpells.forEach((spell, index) => {
        const row = document.createElement('tr');
        const effectPreview = spell.effect.length > 80 ? 
            spell.effect.substring(0, 80) + '...' : 
            spell.effect;
        
        const loreColor = getLoreColor(spell.lore);
        const memIcon = spell.memorised ? 'âœ“' : 'â€”';
        const memStyle = spell.memorised ? 'color: #2a8a2a; font-weight: bold;' : 'color: #666;';
        
        row.innerHTML = `
            <td class="skill-name-cell" style="border-left: 3px solid ${loreColor};">
                ${spell.name}
                <div style="font-size: 10px; color: #666; font-style: italic;">${spell.lore}</div>
            </td>
            <td style="text-align: center; font-weight: bold;">${spell.cn}</td>
            <td style="font-size: 11px; padding: 5px;">${spell.range}</td>
            <td style="font-size: 11px; padding: 5px;">${spell.target}</td>
            <td style="font-size: 11px; padding: 5px;">${spell.duration}</td>
            <td style="font-size: 11px; padding: 5px;">${effectPreview}</td>
            <td style="text-align: center; ${memStyle}">${memIcon}</td>
            <td><button class="advance-btn" onclick="window.removeSpell(${spells.indexOf(spell)})" style="background: #d44; color: white;">Ã—</button></td>
        `;
        tbody.appendChild(row);
    });
}

window.getLoreColor = function(lore) {
    const colors = {
        'Fire': '#d44444',
        'Metal': '#888888',
        'Life': '#44d444', 
        'Light': '#ffd700',
        'Heavens': '#4444d4',
        'Shadow': '#444444',
        'Death': '#8B4B8B',
        'Beasts': '#8B6914',
        'Daemonology': '#8B0000',
        'Petty Magic': '#666666',
        'Sigmar': '#ffd700',
        'Ulric': '#87ceeb',
        'Morr': '#696969',
        'Verena': '#4169e1',
        'Shallya': '#f0f8ff',
        'Myrmidia': '#ffa500',
        'Ranald': '#32cd32',
        'Taal': '#228b22',
        'Rhya': '#9acd32',
        'Manann': '#00ced1'
    };
    return colors[lore] || '#8b7355';
}

window.removeSpell = function(index) {
    if (confirm('Remove this spell/prayer?')) {
        spells.splice(index, 1);
        displaySpells();
    }
}

window.addSpell = function() {
    document.getElementById('add-spell-modal').style.display = 'block';
    
    // Initialize to SRD view (default)
    document.getElementById('spell-source-input').value = 'srd';
    updateLoreOptions(); // Set initial lore options
    window.toggleSpellSource(); // Apply the SRD view
}

window.updateLoreOptions = function() {
    const loreSelect = document.getElementById('spell-lore-input');
    
    loreSelect.innerHTML = '';
    
    // Comprehensive lore options matching our categorization system
    const allLoreOptions = [
        { value: '', text: 'Select Lore/Type...' },
        
        // Petty Magic
        { value: 'Petty', text: 'Petty Magic' },
        
        // Arcane Spells (handled by folder structure in SRD)
        { value: 'Arcane', text: 'Arcane Spells' },
        
        // 8 Winds of Magic
        { value: 'Beasts', text: 'Beasts (Wind of Magic)' },
        { value: 'Death', text: 'Death (Wind of Magic)' },
        { value: 'Fire', text: 'Fire (Wind of Magic)' },
        { value: 'Heavens', text: 'Heavens (Wind of Magic)' },
        { value: 'Life', text: 'Life (Wind of Magic)' },
        { value: 'Light', text: 'Light (Wind of Magic)' },
        { value: 'Metal', text: 'Metal (Wind of Magic)' },
        { value: 'Shadows', text: 'Shadows (Wind of Magic)' },
        
        // Blessings & Divine
        { value: 'Blessings', text: 'Blessings (Divine Petty)' },
        { value: 'Sigmar', text: 'Sigmar (Divine)' },
        { value: 'Ulric', text: 'Ulric (Divine)' },
        { value: 'Taal', text: 'Taal (Divine)' },
        { value: 'Rhya', text: 'Rhya (Divine)' },
        { value: 'Manann', text: 'Manann (Divine)' },
        { value: 'Morr', text: 'Morr (Divine)' },
        { value: 'Shallya', text: 'Shallya (Divine)' },
        { value: 'Ranald', text: 'Ranald (Divine)' },
        { value: 'Verena', text: 'Verena (Divine)' },
        { value: 'Myrmidia', text: 'Myrmidia (Divine)' },
        
        // Witch Magic
        { value: 'Witchcraft', text: 'Witchcraft (Witch Magic)' },
        { value: 'Hedge Craft', text: 'Hedge Craft (Witch Magic)' },
        
        // Dark Magic
        { value: 'Daemonology', text: 'Daemonology (Dark Magic)' },
        { value: 'Necromancy', text: 'Necromancy (Dark Magic)' },
        
        // Chaos Magic
        { value: 'Nurgle', text: 'Nurgle (Chaos)' },
        { value: 'Slaanesh', text: 'Slaanesh (Chaos)' },
        { value: 'Tzeentch', text: 'Tzeentch (Chaos)' }
    ];
    
    allLoreOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.text;
        loreSelect.appendChild(option);
    });
}

window.confirmAddSpell = function() {
    const source = document.getElementById('spell-source-input').value;
    const memorised = document.getElementById('spell-memorised-input').checked;
    let spell;
    
    if (source === 'srd') {
        // Handle SRD spell selection
        const select = document.getElementById('srd-spell-select');
        const selectedOption = select.options[select.selectedIndex];
        
        if (!selectedOption) {
            alert('Please select a spell from the SRD list');
            return;
        }
        
        const srdSpell = JSON.parse(selectedOption.dataset.spell);
        
        // Check if spell already exists
        const exists = spells.some(s => s.name.toLowerCase() === srdSpell.name.toLowerCase());
        if (exists) {
            alert('A spell with this name already exists');
            return;
        }
        
        // Determine type based on lore
        const arcaneLores = ['Petty Magic', 'Fire', 'Metal', 'Life', 'Light', 'Heavens', 'Shadow', 'Death', 'Beasts', 'Daemonology'];
        const type = arcaneLores.includes(srdSpell.lore) ? 'arcane' : 'divine';
        
        spell = {
            name: srdSpell.name,
            type: type,
            lore: srdSpell.lore,
            cn: srdSpell.castingNumber,
            range: srdSpell.range,
            target: srdSpell.target.toString(),
            duration: srdSpell.duration,
            effect: `${srdSpell.name} (${srdSpell.lore} spell)`, // Placeholder since SRD doesn't include full effects
            ingredients: '',
            memorised: memorised
        };
    } else {
        // Handle custom spell entry
        const name = document.getElementById('spell-name-input').value.trim();
        const lore = document.getElementById('spell-lore-input').value;
        const cn = document.getElementById('spell-cn-input').value;
        const range = document.getElementById('spell-range-input').value.trim();
        const target = document.getElementById('spell-target-input').value.trim();
        const duration = document.getElementById('spell-duration-input').value.trim();
        const effect = document.getElementById('spell-effect-input').value.trim();
        const ingredients = document.getElementById('spell-ingredients-input').value.trim();
        
        if (!name) {
            alert('Please enter a spell/prayer name');
            return;
        }
        
        if (!lore) {
            alert('Please select a lore or deity');
            return;
        }
        
        if (!cn || cn < 0) {
            alert('Please enter a valid Casting Number');
            return;
        }
        
        if (!effect) {
            alert('Please describe the spell effect');
            return;
        }
        
        // Check if spell already exists
        const exists = spells.some(s => s.name.toLowerCase() === name.toLowerCase());
        if (exists) {
            alert('A spell with this name already exists');
            return;
        }
        
        spell = {
            name: name,
            lore: lore,
            cn: parseInt(cn),
            range: range || 'Touch',
            target: target || '1 target',
            duration: duration || 'Instant',
            effect: effect,
            ingredients: ingredients || '',
            memorised: memorised
        };
    }
    
    spells.push(spell);
    displaySpells();
    closeAddSpellModal();
}

window.closeAddSpellModal = function() {
    document.getElementById('add-spell-modal').style.display = 'none';
    document.getElementById('spell-source-input').value = 'srd';
    
    // Clear custom spell fields safely
    const customFields = [
        'spell-name-input', 'spell-lore-input', 'spell-cn-input', 
        'spell-range-input', 'spell-target-input', 'spell-duration-input', 
        'spell-effect-input', 'spell-ingredients-input'
    ];
    
    customFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
            field.value = '';
        }
    });
    
    // Clear memorised checkbox
    const memorisedField = document.getElementById('spell-memorised-input');
    if (memorisedField) {
        memorisedField.checked = false;
    }
    
    // Clear SRD fields
    document.getElementById('srd-spell-search').value = '';
    document.getElementById('srd-spell-select').value = '';
    document.getElementById('srd-spell-details').style.display = 'none';
    
    // Reset filters
    document.getElementById('srd-category-filter').value = '';
    document.getElementById('srd-lore-filter').value = '';
    
    toggleSpellSource(); // Reset to SRD view (default)
}

// SRD Spell Selection Functions
window.toggleSpellSource = function() {
    const source = document.getElementById('spell-source-input').value;
    const customSection = document.getElementById('custom-spell-section');
    const srdSection = document.getElementById('srd-spell-section');
    
    if (source === 'srd') {
        customSection.style.display = 'none';
        srdSection.style.display = 'block';
        window.populateSRDSpellSelect();
    } else {
        customSection.style.display = 'block';
        srdSection.style.display = 'none';
    }
}

window.populateSRDSpellSelect = function() {
    const select = document.getElementById('srd-spell-select');
    const loreFilter = document.getElementById('srd-lore-filter');
    select.innerHTML = '';
    
    console.log('populateSRDSpellSelect called, srdSpells length:', srdSpells.length);
    
    if (srdSpells.length === 0) {
        // If no spells loaded, show a message and try to load them
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Loading spells...';
        select.appendChild(option);
        
        // Try to reload spells data
        loadSpellsData().then(() => {
            if (srdSpells.length > 0) {
                window.populateSRDSpellSelect(); // Retry once data is loaded
            }
        });
        return;
    }
    
    // Populate lore filter if it's empty
    if (loreFilter && loreFilter.options.length <= 1) {
        const lores = [...new Set(srdSpells.map(s => s.lore))].sort();
        lores.forEach(lore => {
            const option = document.createElement('option');
            option.value = lore;
            option.textContent = lore;
            loreFilter.appendChild(option);
        });
    }
    
    const sortedSpells = [...srdSpells].sort((a, b) => a.name.localeCompare(b.name));
    
    sortedSpells.forEach(spell => {
        const option = document.createElement('option');
        option.value = spell.name;
        option.textContent = `${spell.name} (${spell.lore}) - CN ${spell.castingNumber}`;
        option.dataset.spell = JSON.stringify(spell);
        select.appendChild(option);
    });
    
    // Update count
    document.getElementById('srd-spell-count').textContent = `(${sortedSpells.length} spells)`;
    
    // Apply any existing filters
    window.filterSRDSpells();
}

// Helper function to categorize spells
function getSpellCategory(spell) {
    const lore = spell.lore;
    const folder = spell.folder || '';
    
    const windLores = ['Beasts', 'Death', 'Fire', 'Heavens', 'Life', 'Light', 'Metal', 'Shadows'];
    const witchLores = ['Witchcraft', 'Hedge Craft']; // Witch Magic encompasses both
    const darkLores = ['Daemonology', 'Necromancy']; // Dark Magic only
    const chaosLores = ['Nurgle', 'Slaanesh', 'Tzeentch']; // Khorne has no spells
    const divineLores = ['Sigmar', 'Ulric', 'Taal', 'Rhya', 'Manann', 'Morr', 'Shallya', 'Ranald', 'Verena', 'Myrmidia'];
    const blessingLores = ['Blessings']; // Divine equivalent of petty magic
    
    // Check for Arcane spells (based on folder structure)
    if (folder.includes('Arcane Spells')) return 'arcane';
    
    // Petty magic (excluding arcane spells)
    if (lore === 'Petty') return 'petty';
    
    // Blessings (divine petty magic)
    if (blessingLores.includes(lore)) return 'blessings';
    
    // 8 Winds of Magic
    if (windLores.includes(lore)) return 'winds';
    
    // Witch Magic (Hedge Craft)
    if (witchLores.includes(lore)) return 'witch';
    
    // Dark Magic (Daemonology & Necromancy only)
    if (darkLores.includes(lore)) return 'dark';
    
    // Chaos Magic (Nurgle, Slaanesh, Tzeentch - no Khorne)
    if (chaosLores.includes(lore)) return 'chaos';
    
    // Divine Miracles
    if (divineLores.includes(lore)) return 'divine';
    
    return 'other';
}

window.filterSRDSpells = function() {
    const searchText = document.getElementById('srd-spell-search').value.toLowerCase();
    const loreFilter = document.getElementById('srd-lore-filter').value;
    const categoryFilter = document.getElementById('srd-category-filter').value;
    const select = document.getElementById('srd-spell-select');
    
    // Clear and rebuild the select list with filtered options
    select.innerHTML = '';
    
    // Filter the spells data directly
    const filteredSpells = srdSpells.filter(spell => {
        const matchesSearch = searchText === '' || 
                       (spell.name && spell.name.toLowerCase().includes(searchText));
        const matchesLore = loreFilter === '' || spell.lore === loreFilter;
        const matchesCategory = categoryFilter === '' || getSpellCategory(spell) === categoryFilter;
        
        return matchesSearch && matchesLore && matchesCategory;
    });
    
    // Rebuild the select options with filtered spells
    const sortedSpells = filteredSpells.sort((a, b) => a.name.localeCompare(b.name));
    
    sortedSpells.forEach(spell => {
        const option = document.createElement('option');
        option.value = spell.name;
        option.textContent = `${spell.name} (${spell.lore}) - CN ${spell.castingNumber}`;
        option.dataset.spell = JSON.stringify(spell);
        select.appendChild(option);
    });
    
    // Update count
    document.getElementById('srd-spell-count').textContent = `(${sortedSpells.length} spells found)`;
    
    // Select first match if any
    if (sortedSpells.length > 0) {
        select.selectedIndex = 0;
        window.showSRDSpellDetails();
    }
}

window.showSRDSpellDetails = function() {
    const select = document.getElementById('srd-spell-select');
    const selectedOption = select.options[select.selectedIndex];
    
    if (!selectedOption) return;
    
    const spell = JSON.parse(selectedOption.dataset.spell);
    const detailsDiv = document.getElementById('srd-spell-details');
    
    document.getElementById('srd-detail-name').textContent = spell.name;
    document.getElementById('srd-detail-lore').textContent = spell.lore;
    document.getElementById('srd-detail-cn').textContent = spell.castingNumber;
    document.getElementById('srd-detail-range').textContent = spell.range;
    document.getElementById('srd-detail-target').textContent = spell.target;
    document.getElementById('srd-detail-duration').textContent = spell.duration;
    
    detailsDiv.style.display = 'block';
}

// Add search and filter listeners for spells
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('spells-search')?.addEventListener('input', function() {
        displaySpells();
    });
    
    document.getElementById('spells-filter')?.addEventListener('change', function() {
        displaySpells();
    });
});

        window.removeSkill = function(skillKey) {
            if (confirm('Are you sure you want to remove this skill?')) {
                // Remove from added skills
                addedSkills = addedSkills.filter(s => s.key !== skillKey);
                
                // Remove skill data
                delete characterSkills[skillKey];
                
                displaySkills();
            }
        }

        window.closeAddSkillModal = function() {
            document.getElementById('add-skill-modal').style.display = 'none';
            document.getElementById('skill-select').value = '';
            document.getElementById('specialisation-input').value = '';
            document.getElementById('specialisation-field').style.display = 'none';
        }

        // Filter functionality
        document.getElementById('skills-filter').addEventListener('change', function() {
            displaySkills();
        });
        
        // Species change listener for max wounds calculation
        document.getElementById('species')?.addEventListener('change', function() {
            if (typeof window.updateMaxWounds === 'function') {
                window.updateMaxWounds();
            }
        });

        // Generic function to modify values with + and - buttons (global scope)
        window.modifyValue = function(elementId, amount) {
            const element = document.getElementById(elementId);
            let newVal = (parseInt(element.value) || 0) + amount;
            newVal = Math.max(0, newVal);
            element.value = newVal;
        }

        // Save/Load functionality
        window.saveCharacter = function() {
            const characterData = {
                name: document.getElementById('character-name').value,
                species: document.getElementById('species').value,
                class: document.getElementById('class').value,
                career: document.getElementById('career').value,
                characteristics: {},
                wounds: {
                    current: document.getElementById('wounds-current').value,
                    max: document.getElementById('wounds-max').value
                },
                movement: document.getElementById('movement').value,
                fate: document.getElementById('fate').value,
                fortune: document.getElementById('fortune-current').value,
                resilience: document.getElementById('resilience').value,
                resolve: document.getElementById('resolve-current').value,
                motivation: document.getElementById('motivation').value,
                experience: {
                    total: document.getElementById('xp-total').value,
                    spent: document.getElementById('xp-spent').value
                },
                status: {
                    tier: document.getElementById('status-tier').value,
                    standing: document.getElementById('status-standing').value
                },
                sinPoints: document.getElementById('sin-points').value,
                notes: document.getElementById('quick-notes').value,
                skills: typeof characterSkills !== 'undefined' ? characterSkills : [],
                addedSkills: typeof addedSkills !== 'undefined' ? addedSkills : [],
                // New combat & equipment data
                weapons: typeof weapons !== 'undefined' ? weapons : [],
                armour: typeof armour !== 'undefined' ? armour : [],
                trappings: typeof trappings !== 'undefined' ? trappings : [],
                consumables: typeof consumables !== 'undefined' ? consumables : [],
                talents: typeof talents !== 'undefined' ? talents : [],
                activeConditions: typeof activeConditions !== 'undefined' ? activeConditions : [],
                criticalWounds: typeof criticalWounds !== 'undefined' ? criticalWounds : [],
                spells: typeof spells !== 'undefined' ? spells : [],
                corruptionPoints: document.getElementById('corruption-points').value,
                mutations: typeof mutations !== 'undefined' ? mutations : [],
                diseaseTracking: {
                    activeDiseases: (typeof character !== 'undefined' && character.diseaseTracking) ? character.diseaseTracking.activeDiseases || [] : [],
                    testReminders: document.getElementById('test-reminders').value || ''
                },
                money: {
                    gold: document.getElementById('money-gold').value,
                    silver: document.getElementById('money-silver').value,
                    brass: document.getElementById('money-brass').value
                },
                xpLog: typeof xpLog !== 'undefined' ? xpLog : []
            };
            
            // Save characteristics
            if (typeof characteristics !== 'undefined') {
                characteristics.forEach(char => {
                    characterData.characteristics[char] = {
                        initial: document.getElementById(`${char}-initial`).value,
                        advances: document.getElementById(`${char}-advances`).value
                    };
                });
            }
            
            localStorage.setItem('wfrpCharacter', JSON.stringify(characterData));
            alert('Character saved!');
        }

        window.loadCharacter = function() {
            const savedData = localStorage.getItem('wfrpCharacter');
            if (!savedData) {
                alert('No saved character found!');
                return;
            }
            
            const characterData = JSON.parse(savedData);
            
            // Load basic info
            document.getElementById('character-name').value = characterData.name || '';
            document.getElementById('species').value = characterData.species || '';
            document.getElementById('class').value = characterData.class || '';
            document.getElementById('career').value = characterData.career || '';
            
            // Load characteristics
            if (characterData.characteristics) {
                characteristics.forEach(char => {
                    if (characterData.characteristics[char]) {
                        document.getElementById(`${char}-initial`).value = characterData.characteristics[char].initial || '';
                        document.getElementById(`${char}-advances`).value = characterData.characteristics[char].advances || '';
                        // Trigger update
                        document.getElementById(`${char}-initial`).dispatchEvent(new Event('input'));
                    }
                });
            }
            
            // Load other stats
            if (characterData.wounds) {
                document.getElementById('wounds-current').value = characterData.wounds.current || '';
                document.getElementById('wounds-max').value = characterData.wounds.max || '';
            }
            
            
            document.getElementById('movement').value = characterData.movement || '';
            movement.dispatchEvent(new Event('input'));
            
            if (characterData.experience) {
                // Handle legacy data format (current + spent = total)
                if (characterData.experience.current !== undefined && characterData.experience.total === undefined) {
                    const current = parseInt(characterData.experience.current) || 0;
                    const spent = parseInt(characterData.experience.spent) || 0;
                    document.getElementById('xp-total').value = current + spent;
                    document.getElementById('xp-spent').value = spent;
                } else {
                    // New format (total - spent = current)
                    document.getElementById('xp-total').value = characterData.experience.total || '0';
                    document.getElementById('xp-spent').value = characterData.experience.spent || '0';
                }
                window.updateXPDisplay();
            }
            
            document.getElementById('fate').value = characterData.fate || '';
            document.getElementById('fortune-current').value = characterData.fortune || '';
            document.getElementById('resilience').value = characterData.resilience || '';
            document.getElementById('resolve-current').value = characterData.resolve || '';
            document.getElementById('motivation').value = characterData.motivation || '';
            
            // Update the max displays after loading data
            window.updateFateFortuneResilienceResolveDisplay();
            
            if (characterData.status) {
                document.getElementById('status-tier').value = characterData.status.tier || 'Brass';
                document.getElementById('status-standing').value = characterData.status.standing || '';
            }
            
            document.getElementById('sin-points').value = characterData.sinPoints || '';
            document.getElementById('quick-notes').value = characterData.notes || '';
            
            // Load skills
            if (characterData.skills) {
                characterSkills = characterData.skills;
            }
            
            // Load added skills
            if (characterData.addedSkills) {
                addedSkills = characterData.addedSkills;
            }
            if (characterData.talents) {
                talents = characterData.talents;
            }
            
            // Load active conditions
            if (characterData.activeConditions) {
                activeConditions = characterData.activeConditions;
            }
            
            // Load critical wounds
            if (characterData.criticalWounds) {
                criticalWounds = characterData.criticalWounds;
                // Update wound counter to prevent ID conflicts
                if (criticalWounds.length > 0) {
                    woundIdCounter = Math.max(...criticalWounds.map(w => w.id)) + 1;
                }
            }
            
            // Load spells
            if (characterData.spells) {
                spells = characterData.spells;
            }
            
            // Load corruption points and mutations
            if (characterData.corruptionPoints !== undefined) {
                document.getElementById('corruption-points').value = characterData.corruptionPoints;
                window.updateCorruptionStatus();
            }
            
            if (characterData.mutations) {
                mutations = characterData.mutations;
                // Update mutation counter to prevent ID conflicts
                if (mutations.length > 0) {
                    mutationIdCounter = Math.max(...mutations.map(m => m.id)) + 1;
                }
            }
            
            // Load combat & equipment data
            if (characterData.weapons) weapons = characterData.weapons;
            if (characterData.armour) armour = characterData.armour;
            if (characterData.trappings) trappings = characterData.trappings;
            if (characterData.consumables) consumables = characterData.consumables;
            
            if (characterData.money) {
                document.getElementById('money-gold').value = characterData.money.gold || '0';
                document.getElementById('money-silver').value = characterData.money.silver || '0';
                document.getElementById('money-brass').value = characterData.money.brass || '0';
            }
            
            // Load disease tracking data
            if (characterData.diseaseTracking) {
                document.getElementById('test-reminders').value = characterData.diseaseTracking.testReminders || '';
                character.diseaseTracking.activeDiseases = characterData.diseaseTracking.activeDiseases || [];
                character.diseaseTracking.testReminders = characterData.diseaseTracking.testReminders || '';
                
                // Update disease counter to prevent ID conflicts
                if (character.diseaseTracking.activeDiseases.length > 0) {
                    diseaseIdCounter = Math.max(...character.diseaseTracking.activeDiseases.map(d => d.id)) + 1;
                }
            }
            
            // Refresh all displays
            displaySkills();
            displayTalents();
            window.updateConditionDisplay();
            window.displayCriticalWounds();
            window.updateWoundPenalties();
            window.updateAllCharacteristicsFromWounds();
            // Update all skills to reflect wound penalties after characteristics are updated
            setTimeout(() => {
                if (typeof window.updateAllSkillTotals === 'function') {
                    window.updateAllSkillTotals();
                }
            }, 50);
            displaySpells();
            displayWeapons();
            displayArmour();
            displayTrappings();
            displayConsumables();
            updateTotalAP();
            window.displayMutations();
            window.updateCorruptionStatus();
            
            // Update disease system displays
            if (typeof window.displayActiveDiseases === 'function') {
                window.displayActiveDiseases();
            }
            if (typeof window.updateSymptomEffects === 'function') {
                window.updateSymptomEffects();
            }
            if (typeof window.checkStatusInteractions === 'function') {
                window.checkStatusInteractions();
            }
            
            // Load XP log if it exists
            if (characterData.xpLog) {
                xpLog = characterData.xpLog;
                saveXPLog(); // Save to localStorage for consistency
            }
            
            // Update encumbrance after everything is loaded
            setTimeout(() => {
                updateEncumbrance();
            }, 100);
            
            alert('Character loaded!');
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            
            // Initialize XP system variables
            xpTotal = document.getElementById('xp-total');
            xpSpent = document.getElementById('xp-spent');
            window.updateXPDisplay();
            
            // Initialize Fate/Fortune/Resilience/Resolve system
            previousFate = parseInt(document.getElementById('fate').value) || 0;
            previousResilience = parseInt(document.getElementById('resilience').value) || 0;
            window.updateFateFortuneResilienceResolveDisplay();
            
            // Load SRD data
            loadSRDData();
            loadTalentsData();
            loadConditionsData();
            loadSpellsData();
            loadDiseasesData();
            loadSymptomsData();
            loadCareers();
            
            try {
                displaySkills(); // Show basic skills immediately
                displayTalents();
                window.updateConditionDisplay();
                window.displayCriticalWounds();
                displaySpells();
                displayWeapons();
                displayArmour();
                displayTrappings();
                displayConsumables();
                window.displayMutations();
                
                // Set up initial encumbrance calculation after a short delay to ensure values are loaded
                setTimeout(() => {
                    updateEncumbrance();
                    // Trigger initial characteristic updates
                    characteristics.forEach(char => {
                        const current = document.getElementById(`${char}-current`);
                        if (current && current.updateFunction) {
                            current.updateFunction();
                        }
                    });
                    // Initialize max wounds calculation
                    if (typeof window.updateMaxWounds === 'function') {
                        window.updateMaxWounds();
                    }
                    
                    // Initialize corruption system
                    if (typeof window.updateCorruptionThreshold === 'function') {
                        window.updateCorruptionThreshold();
                    }
                    if (typeof window.updateCorruptionStatus === 'function') {
                        window.updateCorruptionStatus();
                    }
                    
                    // Initialize disease system
                    if (typeof window.displayActiveDiseases === 'function') {
                        window.displayActiveDiseases();
                    }
                }, 100);
                
                console.log('Initialization complete');
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });

        // Career System Functions
        
        // Load careers data from JSON file
        function loadCareers() {
            fetch('careers.json')
                .then(response => response.json())
                .then(data => {
                    careersData = data;
                    console.log('Loaded', data.careers.length, 'careers');
                    
                    console.log('Careers loaded with corrected tier availability format');
                    
                    // Map careers.json class names to dropdown class names
                    const classNameMapping = {
                        'academics': 'Academic',
                        'burghers': 'Burgher',
                        'courtiers': 'Courtier',
                        'peasants': 'Peasant',
                        'rangers': 'Ranger',
                        'riverfolk': 'Riverfolk',
                        'rogues': 'Rogue',
                        'warriors': 'Warrior'
                    };
                    
                    // Organize careers by class for dropdown filtering
                    careersByClass = {};
                    data.careers.forEach(career => {
                        const className = classNameMapping[career.class] || career.class.charAt(0).toUpperCase() + career.class.slice(1);
                        if (!careersByClass[className]) {
                            careersByClass[className] = [];
                        }
                        careersByClass[className].push(career);
                    });
                    
                    // Sort careers within each class alphabetically
                    Object.keys(careersByClass).forEach(className => {
                        careersByClass[className].sort((a, b) => a.name.localeCompare(b.name));
                    });
                    
                    // Populate career dropdown based on current class selection
                    updateCareerDropdown();
                    
                    // Restore career selection if saved
                    restoreCareerSelection();
                })
                .catch(error => {
                    console.error('Error loading careers:', error);
                });
        }
        
        // Update career dropdown based on selected class
        function updateCareerDropdown() {
            const careerSelect = document.getElementById('career-select');
            const classSelect = document.getElementById('class');
            const selectedClass = classSelect.value;
            
            // Clear existing options except the first one
            careerSelect.innerHTML = '<option value="">Select Career</option>';
            
            if (selectedClass && careersByClass[selectedClass]) {
                careersByClass[selectedClass].forEach(career => {
                    const option = document.createElement('option');
                    option.value = career.name;
                    option.textContent = career.name;
                    careerSelect.appendChild(option);
                });
                careerSelect.disabled = false;
            } else {
                careerSelect.disabled = true;
            }
        }
        
        // Handle career selection (preview only)
        function handleCareerSelection() {
            const careerSelect = document.getElementById('career-select');
            const selectedCareerName = careerSelect.value;
            
            if (selectedCareerName && careersData) {
                previewCareer = careersData.careers.find(c => c.name === selectedCareerName);
                if (previewCareer) {
                    showCareerPreview(previewCareer);
                }
            } else {
                previewCareer = null;
                clearCareerDisplay();
                document.getElementById('career-actions').style.display = 'none';
            }
        }
        
        // Show career preview without applying changes
        function showCareerPreview(career) {
            document.getElementById('career-class').textContent = career.class.charAt(0).toUpperCase() + career.class.slice(1);
            document.getElementById('tier-info').style.display = 'block';
            document.getElementById('career-actions').style.display = 'block';
            
            // Reset tier selector to 1
            document.getElementById('tier-select').value = '1';
            document.getElementById('tier-select').disabled = false;
            
            // Display tier 1 information
            displayTierInfo(career, 1);
        }
        
        // Confirm career selection and apply changes
        function confirmCareerSelection() {
            if (previewCareer) {
                currentCareer = previewCareer;
                currentTier = parseInt(document.getElementById('tier-select').value);
                previewCareer = null;
                
                // Apply characteristic limits and highlighting
                updateCharacteristicLimits();
                highlightCareerSkills();
                highlightCareerTalents();
                
                // Save career selection
                saveCareerSelection();
                
                // Hide action buttons
                document.getElementById('career-actions').style.display = 'none';
                
                console.log('Career confirmed:', currentCareer.name, 'Tier:', currentTier);
            }
        }
        
        // Cancel career selection
        function cancelCareerSelection() {
            previewCareer = null;
            document.getElementById('career-select').value = '';
            clearCareerDisplay();
            document.getElementById('career-actions').style.display = 'none';
        }
        
        // Handle tier selection
        function handleTierSelection() {
            const tierSelect = document.getElementById('tier-select');
            const globalTierSelect = document.getElementById('global-tier');
            const selectedTier = parseInt(tierSelect.value);
            
            // Sync with global tier
            currentTier = selectedTier;
            if (globalTierSelect) {
                globalTierSelect.value = selectedTier;
            }
            
            // If we're in preview mode, just update the preview display
            if (previewCareer) {
                displayTierInfo(previewCareer, selectedTier);
            } 
            // If we have a confirmed career, update everything
            else if (currentCareer) {
                updateTierDisplay();
                updateCharacteristicLimits();
                highlightCareerSkills();
                highlightCareerTalents();
                saveCareerSelection();
            }
        }
        
        // Select and display a career
        // Display tier information for preview or confirmed career
        function displayTierInfo(career, tierNumber) {
            if (!career || !career.tiers) return;
            
            const tier = career.tiers.find(t => t.tier === tierNumber);
            if (!tier) return;
            
            // Update tier header
            document.getElementById('tier-name').textContent = tier.name;
            document.getElementById('tier-status').textContent = tier.status || '-';
            
            // Update tier details
            document.getElementById('tier-skills').textContent = tier.skills ? tier.skills.join(', ') : '-';
            document.getElementById('tier-talents').textContent = tier.talents ? tier.talents.join(', ') : '-';
            document.getElementById('tier-trappings').textContent = tier.trappings ? tier.trappings.join(', ') : '-';
        }
        
        // Update tier information display
        function updateTierDisplay() {
            if (!currentCareer || !currentCareer.tiers) return;
            
            const tier = currentCareer.tiers.find(t => t.tier === currentTier);
            if (!tier) return;
            
            // Show tier info section
            document.getElementById('tier-info').style.display = 'block';
            
            // Update tier header
            document.getElementById('tier-name').textContent = tier.name;
            document.getElementById('tier-status').textContent = tier.status;
            
            // Update tier details
            document.getElementById('tier-skills').innerHTML = 
                tier.skills.length > 0 ? tier.skills.map(skill => `<div>${skill}</div>`).join('') : '<div style="font-style: italic; color: #999;">None</div>';
                
            document.getElementById('tier-talents').innerHTML = 
                tier.talents.length > 0 ? tier.talents.map(talent => `<div>${talent}</div>`).join('') : '<div style="font-style: italic; color: #999;">None</div>';
                
            document.getElementById('tier-trappings').innerHTML = 
                tier.trappings.length > 0 ? tier.trappings.map(trapping => `<div>${trapping}</div>`).join('') : '<div style="font-style: italic; color: #999;">None</div>';
        }
        
        // Clear career display
        function clearCareerDisplay() {
            document.getElementById('career-class').textContent = '-';
            document.getElementById('tier-select').disabled = true;
            document.getElementById('tier-info').style.display = 'none';
            
            // Clear highlighting
            clearCareerHighlights();
            clearCharacteristicLimits();
            saveCareerSelection();
        }
        
        // Update characteristic advancement limits based on career tier
        function updateCharacteristicLimits() {
            if (!currentCareer || !currentCareer.characteristicAdvances) {
                console.log('No career selected, clearing all restrictions');
                clearCharacteristicLimits();
                return;
            }
            
            console.log('Updating characteristic limits for:', currentCareer.name, 'Tier:', currentTier);
            
            const charRows = document.querySelectorAll('tr[data-characteristic]');
            
            charRows.forEach(row => {
                const charName = row.getAttribute('data-characteristic');
                const advanceData = currentCareer.characteristicAdvances[charName] || [];
                
                // Remove existing indicators
                const existingIndicator = row.querySelector('.advance-limit-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                
                // Clear existing highlighting
                row.classList.remove('career-available', 'career-future', 'career-tier-1', 'career-tier-2', 'career-tier-3', 'career-tier-4');
                
                // Check if this characteristic can be advanced at the current tier
                const availableAtCurrentTier = advanceData.includes(currentTier);
                const futureAdvances = advanceData.filter(tier => tier > currentTier);
                
                if (availableAtCurrentTier) {
                    // Characteristic is available at current tier - use tier-specific color
                    row.classList.add(`career-tier-${currentTier}`);
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'advance-limit-indicator';
                    indicator.innerHTML = `<strong>Available</strong> at tier ${currentTier}`;
                    
                    if (futureAdvances.length > 0) {
                        indicator.innerHTML += `<br><span style="color: #888; font-size: 10px;">Also at higher tiers</span>`;
                    }
                    
                    indicator.style.cssText = `
                        position: absolute;
                        right: 5px;
                        top: 50%;
                        transform: translateY(-50%);
                        font-size: 10px;
                        text-align: right;
                        line-height: 1.2;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    
                    row.style.position = 'relative';
                    row.appendChild(indicator);
                    
                    // Enable advance button
                    const advanceButton = row.querySelector('button[onclick*="advanceCharacteristic"]');
                    if (advanceButton) {
                        advanceButton.disabled = false;
                        advanceButton.style.opacity = '1';
                        advanceButton.style.cursor = 'pointer';
                    }
                    
                } else if (advanceData.length > 0) {
                    // Characteristic is available at future tiers only
                    row.classList.add('career-future');
                    
                    const indicator = document.createElement('div');
                    indicator.className = 'advance-limit-indicator';
                    const nextAvailableTier = Math.min(...advanceData);
                    indicator.innerHTML = `<span style="color: #888;">Available at tier ${nextAvailableTier}+</span>`;
                    
                    indicator.style.cssText = `
                        position: absolute;
                        right: 5px;
                        top: 50%;
                        transform: translateY(-50%);
                        font-size: 10px;
                        text-align: right;
                        line-height: 1.2;
                        pointer-events: none;
                        z-index: 1;
                    `;
                    
                    row.style.position = 'relative';
                    row.appendChild(indicator);
                    
                    // Disable advance button
                    const advanceButton = row.querySelector('button[onclick*="advanceCharacteristic"]');
                    if (advanceButton) {
                        advanceButton.disabled = true;
                        advanceButton.style.opacity = '0.5';
                        advanceButton.style.cursor = 'not-allowed';
                    }
                } else {
                    // Characteristic is never available for this career
                    const advanceButton = row.querySelector('button[onclick*="advanceCharacteristic"]');
                    if (advanceButton) {
                        advanceButton.disabled = true;
                        advanceButton.style.opacity = '0.5';
                        advanceButton.style.cursor = 'not-allowed';
                    }
                }
            });
        }
        
        // Clear characteristic limit indicators
        function clearCharacteristicLimits() {
            document.querySelectorAll('.advance-limit-indicator').forEach(indicator => indicator.remove());
            document.querySelectorAll('.advance-disabled').forEach(cell => cell.classList.remove('advance-disabled'));
            document.querySelectorAll('.career-available, .career-future, .career-tier-1, .career-tier-2, .career-tier-3, .career-tier-4').forEach(row => {
                row.classList.remove('career-available', 'career-future', 'career-tier-1', 'career-tier-2', 'career-tier-3', 'career-tier-4');
            });
            
            // Re-enable all advance buttons
            document.querySelectorAll('button[onclick*="advanceCharacteristic"]').forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
        }
        
        // Highlight career skills in skills section
        function highlightCareerSkills() {
            // Clear existing highlights
            document.querySelectorAll('.career-skill').forEach(el => el.classList.remove('career-skill'));
            
            if (!currentCareer || !currentCareer.tiers) return;
            
            // Get all skills for current and previous tiers
            const availableSkills = new Set();
            currentCareer.tiers
                .filter(tier => tier.tier <= currentTier)
                .forEach(tier => {
                    tier.skills.forEach(skill => {
                        // Normalize skill name for matching
                        const normalizedSkill = skill.toLowerCase().trim();
                        availableSkills.add(normalizedSkill);
                    });
                });
            
            // Highlight matching skills in the skills table
            const skillRows = document.querySelectorAll('#basic-skills-tbody tr, #advanced-skills-tbody tr');
            skillRows.forEach(row => {
                const skillNameCell = row.querySelector('.skill-name-cell');
                if (skillNameCell) {
                    const skillName = skillNameCell.textContent.toLowerCase().trim();
                    
                    // Check for exact match or partial match for specialized skills
                    for (const careerSkill of availableSkills) {
                        if (skillName === careerSkill || 
                            skillName.startsWith(careerSkill + ' (') ||
                            careerSkill.startsWith(skillName + ' (')) {
                            row.classList.add('career-skill');
                            break;
                        }
                    }
                }
            });
        }
        
        // Highlight career talents in talents section
        function highlightCareerTalents() {
            // Clear existing highlights
            document.querySelectorAll('.career-talent').forEach(el => el.classList.remove('career-talent'));
            
            if (!currentCareer || !currentCareer.tiers) return;
            
            // Get all talents for current and previous tiers
            const availableTalents = new Set();
            currentCareer.tiers
                .filter(tier => tier.tier <= currentTier)
                .forEach(tier => {
                    tier.talents.forEach(talent => {
                        const normalizedTalent = talent.toLowerCase().trim();
                        availableTalents.add(normalizedTalent);
                    });
                });
            
            // Highlight matching talents in the talents table
            const talentRows = document.querySelectorAll('#talents-tbody tr');
            talentRows.forEach(row => {
                const talentNameCell = row.querySelector('.talent-name');
                if (talentNameCell) {
                    const talentName = talentNameCell.textContent.toLowerCase().trim();
                    
                    // Check for exact match or partial match for specialized talents
                    for (const careerTalent of availableTalents) {
                        if (talentName === careerTalent || 
                            talentName.startsWith(careerTalent + ' (') ||
                            careerTalent.startsWith(talentName + ' (')) {
                            row.classList.add('career-talent');
                            break;
                        }
                    }
                }
            });
        }
        
        // Clear all career highlights
        function clearCareerHighlights() {
            document.querySelectorAll('.career-skill').forEach(el => el.classList.remove('career-skill'));
            document.querySelectorAll('.career-talent').forEach(el => el.classList.remove('career-talent'));
        }
        
        // Save career selection to localStorage
        function saveCareerSelection() {
            const careerData = {
                careerName: currentCareer ? currentCareer.name : null,
                tier: currentTier
            };
            localStorage.setItem('selectedCareer', JSON.stringify(careerData));
        }
        
        // Restore career selection from localStorage
        function restoreCareerSelection() {
            const saved = localStorage.getItem('selectedCareer');
            if (!saved) return;
            
            try {
                const careerData = JSON.parse(saved);
                if (careerData.careerName && careersData) {
                    const career = careersData.careers.find(c => c.name === careerData.careerName);
                    if (career) {
                        // Set dropdown values
                        document.getElementById('career-select').value = careerData.careerName;
                        document.getElementById('tier-select').value = careerData.tier || 1;
                        
                        // Update current variables
                        currentTier = careerData.tier || 1;
                        selectCareer(career);
                    }
                }
            } catch (error) {
                console.warn('Error restoring career selection:', error);
            }
        }
        
        // Connect career system to class dropdown
        function handleClassSelection() {
            // Update career dropdown when class changes
            updateCareerDropdown();
            
            // Clear current career if it doesn't match new class
            if (currentCareer) {
                const selectedClass = document.getElementById('class').value;
                const currentCareerClass = currentCareer.class.charAt(0).toUpperCase() + currentCareer.class.slice(1);
                
                if (selectedClass !== currentCareerClass) {
                    currentCareer = null;
                    document.getElementById('career-select').value = '';
                    clearCareerDisplay();
                }
            }
            
            // Call original class wizard logic if it exists
            const classSelect = document.getElementById('class');
            const selectedValue = classSelect.value;
            
            if (selectedValue && classTrappings[selectedValue]) {
                const currentClass = selectedClass;
                if (!currentClass || currentClass !== selectedValue) {
                    openClassWizard(selectedValue);
                }
            }
        }

        // SRD Data Loading
function loadSRDData() {
    // Load weapons data
    fetch('Weapons.json')
        .then(response => response.json())
        .then(data => {
            srdWeapons = data;
            console.log('Loaded', srdWeapons.length, 'weapons from SRD');
        })
        .catch(error => {
            console.error('Error loading weapons:', error);
            // Fallback to embedded data if file not found
            loadEmbeddedSRDData();
        });
    
    // Load armour data
    fetch('Armour.json')
        .then(response => response.json())
        .then(data => {
            srdArmour = data;
            console.log('Loaded', srdArmour.length, 'armour pieces from SRD');
        })
        .catch(error => {
            console.error('Error loading armour:', error);
            // Fallback to embedded data if file not found
            loadEmbeddedSRDData();
        });
    
    // Load ammunition data
    fetch('Ammunition.json')
        .then(response => response.json())
        .then(data => {
            srdAmmunition = data;
            console.log('Loaded', srdAmmunition.length, 'ammunition types from SRD');
        })
        .catch(error => {
            console.error('Error loading ammunition:', error);
            // Use embedded data as fallback
        });
}

// Load Talents Data - This should be OUTSIDE loadSRDData
function loadTalentsData() {
    fetch('Talents.json')
        .then(response => response.json())
        .then(data => {
            srdTalents = data;
            console.log('Loaded', srdTalents.length, 'talents from SRD');
        })
        .catch(error => {
            console.error('Error loading talents:', error);
            // Minimal fallback data
            srdTalents = [
                { name: "Hardy", max: "Toughness Bonus", tests: "", description: "You gain +1 Wound permanently per level in this Talent.", customisable: false },
                { name: "Lightning Reflexes", max: "1", tests: "", description: "+5 to Initiative permanently.", customisable: false },
                { name: "Marksman", max: "1", tests: "Ranged", description: "You gain a permanent +5 BS.", customisable: false }
            ];
        });
}

// Load Conditions Data
function loadConditionsData() {
    fetch('conditions.json')
        .then(response => response.json())
        .then(data => {
            srdConditions = data;
            console.log('Loaded', srdConditions.length, 'conditions from SRD');
        })
        .catch(error => {
            console.error('Error loading conditions:', error);
            // Complete fallback data
            srdConditions = [
                { name: "Ablaze", stackable: "Yes", effects: "You are on fire! At the end of every Round, you suffer 1d10 Wounds, modified by Toughness Bonus and the Armour Points on the least protected Hit Location, with a minimum of 1 Wound suffered. Each extra Ablaze Condition you have adds +1 to the Damage suffered." },
                { name: "Bleeding", stackable: "Yes", effects: "You are bleeding badly. Lose 1 Wound at the end of every Round, ignoring all modifiers. Additionally, suffer a penalty of â€“10 to any Tests to resist Festering Wounds, Minor Infection, or Blood Rot." },
                { name: "Blinded", stackable: "No", effects: "You cannot see. You automatically fail all Tests that rely on vision, and any other Tests are taken with a â€“30 penalty. You cannot perform ranged attacks beyond Point Blank range." },
                { name: "Broken", stackable: "No", effects: "Your spirit is broken. You automatically fail Psychology Tests and gain 1 Broken Condition whenever you fail a Psychology Test. You also suffer a â€“10 penalty to Willpower Tests and Weapon Skill Tests." },
                { name: "Deafened", stackable: "No", effects: "You cannot hear. You automatically fail all Tests that rely on hearing, and any other Tests involving communication or concentration suffer a â€“10 penalty." },
                { name: "Entangled", stackable: "Yes", effects: "You have been caught or snared, and cannot move freely. Whilst entangled, you are considered to be Stationary and cannot leave your current location. You may only take a single Move or Action during your turn, not both." },
                { name: "Fatigued", stackable: "Yes", effects: "You are exhausted or stressed, and certainly in need of rest. You suffer a â€“10 penalty to all Tests. Removing a Fatigued Condition normally requires rest, a spell, or a divine effect." },
                { name: "Poisoned", stackable: "Yes", effects: "You have been poisoned. The exact effects of the poison will be described in the creature, spell, or item that caused this Condition. Generally, Poisoned Conditions are removed by time or appropriate medical attention." },
                { name: "Prone", stackable: "No", effects: "You have been knocked to the ground. You suffer a â€“20 penalty to Weapon Skill Tests when in combat, and anyone making melee attacks against you gains a +20 bonus to hit." },
                { name: "Stunned", stackable: "Yes", effects: "You have been struck about the head or otherwise disorientated or confused. You are incapable of taking an Action on your turn but are capable of half your normal movement. You also suffer a â€“10 penalty to all Tests." },
                { name: "Surprised", stackable: "No", effects: "You have been caught off guard. You may not take an Action on your turn, though you may still Oppose any Tests made against you. This Condition is automatically removed at the end of your Turn." },
                { name: "Unconscious", stackable: "No", effects: "You have been knocked out. You automatically fail all Tests and become unaware of your surroundings. Whilst unconscious, you are considered to be Prone." }
            ];
            console.log('Using fallback conditions data:', srdConditions.length, 'conditions loaded');
        });
}

// Load Spells Data
function loadSpellsData() {
    return fetch('Spells.json')
        .then(response => response.json())
        .then(data => {
            srdSpells = data;
            console.log('Loaded', srdSpells.length, 'spells from SRD');
            return srdSpells;
        })
        .catch(error => {
            console.error('Error loading spells:', error);
            console.warn('Loading spells may fail when opening HTML directly from file system due to CORS restrictions. Consider serving from a web server.');
            
            // Enhanced fallback data with examples from each category
            srdSpells = [
                { name: "Dart", lore: "Petty", castingNumber: 3, range: "12 yards", target: "1", duration: "Instant", folder: "4. SRD/Magic/Petty Magic" },
                { name: "Light", lore: "Petty", castingNumber: 2, range: "Touch", target: "1", duration: "1 hour", folder: "4. SRD/Magic/Petty Magic" },
                { name: "Magic Lock", lore: "Petty", castingNumber: 3, range: "Touch", target: "1", duration: "24 hours", folder: "4. SRD/Magic/Petty Magic" },
                { name: "Aethyric Armour", lore: "Petty", castingNumber: 4, range: "Touch", target: "1", duration: "Willpower hours", folder: "4. SRD/Magic/Arcane Spells" },
                { name: "Fireball", lore: "Fire", castingNumber: 5, range: "24 yards", target: "1", duration: "Instant", folder: "4. SRD/Magic/Lores/Colour Magic/Lore of Fire" },
                { name: "Flaming Sword of Rhuin", lore: "Fire", castingNumber: 7, range: "6 yards", target: "1", duration: "Willpower Bonus rounds", folder: "4. SRD/Magic/Lores/Colour Magic/Lore of Fire" },
                { name: "Heal", lore: "Life", castingNumber: 4, range: "Touch", target: "1", duration: "Instant", folder: "4. SRD/Magic/Lores/Colour Magic/Lore of Life" },
                { name: "Beast Form", lore: "Beasts", castingNumber: 5, range: "You", target: "You", duration: "Willpower minutes", folder: "4. SRD/Magic/Lores/Colour Magic/Lore of Beasts" },
                { name: "Blessing", lore: "Sigmar", castingNumber: 3, range: "6 yards", target: "Willpower Bonus", duration: "Willpower Bonus rounds", folder: "4. SRD/Magic/Lores/Divine Magic/Sigmar" },
                { name: "Animate", lore: "Necromancy", castingNumber: 6, range: "12 yards", target: "1 corpse", duration: "Willpower hours", folder: "4. SRD/Magic/Lores/Dark Magic/Necromancy" },
                { name: "Summon Lesser Daemon", lore: "Daemonology", castingNumber: 15, range: "12 yards", target: "Special", duration: "Willpower minutes", folder: "4. SRD/Magic/Lores/Dark Magic/Daemonology" },
                { name: "Curse", lore: "Witchcraft", castingNumber: 4, range: "12 yards", target: "1", duration: "24 hours", folder: "4. SRD/Magic/Lores/Witch Magic/Witchcraft" }
            ];
            console.log('Using fallback spells data:', srdSpells.length, 'spells loaded');
            return srdSpells;
        });
}

// Load Diseases Data
function loadDiseasesData() {
    fetch('diseases.json')
        .then(response => response.json())
        .then(data => {
            srdDiseases = data;
            console.log('Loaded', srdDiseases.length, 'diseases from SRD');
        })
        .catch(error => {
            console.error('Error loading diseases:', error);
            // Fallback data with common WFRP diseases
            srdDiseases = [
                { name: "Itching Pox", contraction: "Average (+20) Endurance Test", incubation: "1d10 days", duration: "1d10+7 days", symptoms: ["coughs-sneezes", "pox"] },
                { name: "The Bloody Flux", contraction: "Easy (+40) Toughness Test", incubation: "2d10 days", duration: "1d10 days", symptoms: ["flux", "fever"] },
                { name: "Festering Wound", contraction: "Easy (+40) Endurance Test", incubation: "1d10 days", duration: "1d10 days", symptoms: ["fever", "lingering"] }
            ];
            console.log('Using fallback diseases data:', srdDiseases.length, 'diseases loaded');
        });
}

// Load Symptoms Data
function loadSymptomsData() {
    fetch('symptoms.json')
        .then(response => response.json())
        .then(data => {
            srdSymptoms = data;
            console.log('Loaded', srdSymptoms.length, 'symptoms from SRD');
        })
        .catch(error => {
            console.error('Error loading symptoms:', error);
            // Fallback data with common WFRP symptoms
            srdSymptoms = [
                { name: "Fever", mechanicalEffects: { fellowship: -10 }, diseases: ["The Black Plague", "Blood Rot"] },
                { name: "Pox", mechanicalEffects: { fellowship: -10 }, diseases: ["Itching Pox"] },
                { name: "Coughs and Sneezes", mechanicalEffects: {}, diseases: ["Itching Pox"] }
            ];
            console.log('Using fallback symptoms data:', srdSymptoms.length, 'symptoms loaded');
        });
}

        // Embedded SRD data as fallback (using your provided JSON)
        function loadEmbeddedSRDData() {
            // Embedded weapons data
            srdWeapons = [
                {"name":"Hand Weapon","category":"basic","damage":"SB+4","reach":"Average","encumbrance":1,"qualities":[],"flaws":[],"cost":"1GC"},
                {"name":"Dagger","category":"basic","damage":"SB+2","reach":"Very Short","encumbrance":0,"qualities":[],"flaws":[],"cost":"P16D"},
                {"name":"Sword","category":"basic","damage":"SB+4","reach":"Average","encumbrance":1,"qualities":[],"flaws":[],"cost":"1GC"},
                {"name":"Bow","category":"bow","damage":"SB+3","reach":50,"encumbrance":2,"qualities":[],"flaws":[],"cost":"4GC"},
                {"name":"Crossbow","category":"crossbow","damage":9,"reach":60,"encumbrance":2,"qualities":[],"flaws":["Reload 1"],"cost":"5GC"},
                {"name":"Pistol","category":"blackpowder","damage":8,"reach":20,"encumbrance":0,"qualities":["Blackpowder","Damaging","Pistol"],"flaws":["Reload 1"],"cost":"8GC"},
                {"name":"Shield","category":"basic","damage":"SB+2","reach":"Very Short","encumbrance":1,"qualities":["Shield 2","Defensive"],"flaws":["Undamaging"],"cost":"2GC"},
                {"name":"Spear","category":"polearm","damage":"SB+4","reach":"Very Long","encumbrance":2,"qualities":["Impale"],"flaws":[],"cost":"P15D"},
                {"name":"Halberd","category":"polearm","damage":"SB+4","reach":"Long","encumbrance":3,"qualities":["Defensive","Hack","Impale"],"flaws":[],"cost":"2GC"},
                {"name":"Rapier","category":"fencing","damage":"SB+4","reach":"Long","encumbrance":1,"qualities":["Fast","Impale"],"flaws":[],"cost":"5GC"}
            ];
            
            // Embedded armour data
            srdArmour = [
                {"name":"Leather Jerkin","category":"Soft Leather","ap":1,"locations":["Body"],"encumbrance":1,"cost":"P10D"},
                {"name":"Leather Jack","category":"Soft Leather","ap":1,"locations":["Arms","Body"],"encumbrance":1,"cost":"P12D"},
                {"name":"Leather Skullcap","category":"Soft Leather","ap":1,"locations":["Head"],"encumbrance":1,"cost":"P8D"},
                {"name":"Mail Shirt","category":"Mail","ap":2,"locations":["Body"],"encumbrance":2,"cost":"2GC"},
                {"name":"Mail Coat","category":"Mail","ap":2,"locations":["Arms","Body"],"encumbrance":3,"cost":"3GC"},
                {"name":"Breastplate (Plate)","category":"Plate","ap":2,"locations":["Body"],"encumbrance":3,"cost":"10GC"},
                {"name":"Helm","category":"Plate","ap":2,"locations":["Head"],"encumbrance":2,"cost":"3GC"},
                {"name":"Open Helm","category":"Plate","ap":2,"locations":["Head"],"encumbrance":1,"cost":"2GC"}
            ];
            
            // Standard ammunition types based on weapon categories
            srdAmmunition = [
                {"name":"Arrows","type":"bow","cost":"P1D","encumbrance":0.1,"notes":"Standard arrows for bows"},
                {"name":"Bolts","type":"crossbow","cost":"P2D","encumbrance":0.1,"notes":"Standard crossbow bolts"},
                {"name":"Lead Bullets","type":"sling","cost":"P1D","encumbrance":0.1,"notes":"Ammunition for slings"},
                {"name":"Powder & Shot","type":"blackpowder","cost":"P3D","encumbrance":0.1,"notes":"Single shot for blackpowder weapons"},
                {"name":"Throwing Knives","type":"throwing","cost":"P18D","encumbrance":0,"notes":"Can be recovered after battle"},
                {"name":"Darts","type":"throwing","cost":"P2D","encumbrance":0,"notes":"Light throwing weapons"},
                {"name":"Bandages","type":"medical","cost":"P3D","encumbrance":0,"notes":"Heals 1 Wound with successful Heal test"},
                {"name":"Healing Draught","type":"medical","cost":"3GC","encumbrance":0,"notes":"Heals 1d10 Wounds"},
                {"name":"Torches","type":"utility","cost":"P1D","encumbrance":0.5,"notes":"Provides light for 1 hour"},
                {"name":"Oil (lamp)","type":"utility","cost":"P2D","encumbrance":0.5,"notes":"Fuel for lanterns, 4 hours"},
                {"name":"Rations (1 day)","type":"provisions","cost":"P2D","encumbrance":0.5,"notes":"Food for one day"}
            ];
            
            console.log('Using embedded SRD data');
        }

        // Combat & Equipment Functions
        
        // Modal helper function
        window.closeModal = function() {
            // Try to find modal by specific IDs first
            const modalIds = ['weapon-modal', 'armour-modal', 'trapping-modal', 'consumable-modal', 'edit-weapon-modal', 'edit-armour-modal', 'edit-trapping-modal', 'edit-consumable-modal'];
            modalIds.forEach(id => {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.remove();
                }
            });
            
            // Find all modal elements by style and remove them
            const modals = document.querySelectorAll('div[style*="position: fixed"][style*="rgba(0,0,0,0.5)"]');
            modals.forEach(modal => {
                modal.remove();
            });
            
            // Additional fallback: remove any modal with z-index 1000
            const modalsByZIndex = document.querySelectorAll('div[style*="z-index: 1000"]');
            modalsByZIndex.forEach(modal => {
                if (modal.style.position === 'fixed') {
                    modal.remove();
                }
            });
        }
        
        // Weapons Management
        window.addWeapon = function() {
            // Close any existing modals first
            window.closeModal();
            
            // Create modal for weapon selection
            const modal = document.createElement('div');
            modal.id = 'weapon-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Weapon</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Select Weapon:</label>
                    <select id="weapon-select" style="width: 100%; padding: 5px;">
                        <option value="">Choose a weapon...</option>
                        <option value="custom">-- Custom Weapon --</option>
                        ${srdWeapons.map(w => `<option value="${w.name}">${w.name} (${w.category})</option>`).join('')}
                    </select>
                </div>
                <div id="weapon-details" style="display: none; margin-bottom: 15px; padding: 10px; background: #e8dfd0; border: 1px solid #8b7355;">
                    <p><strong>Category:</strong> <span id="detail-category"></span></p>
                    <p><strong>Damage:</strong> <span id="detail-damage"></span></p>
                    <p><strong>Reach/Range:</strong> <span id="detail-reach"></span></p>
                    <p><strong>Encumbrance:</strong> <span id="detail-enc"></span></p>
                    <p><strong>Qualities:</strong> <span id="detail-qualities"></span></p>
                    <p><strong>Flaws:</strong> <span id="detail-flaws"></span></p>
                    <p><strong>Cost:</strong> <span id="detail-cost"></span></p>
                </div>
                <div id="custom-weapon-fields" style="display: none;">
                    <input type="text" id="custom-name" placeholder="Weapon name" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-group" placeholder="Weapon group" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-enc" placeholder="Encumbrance" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-range" placeholder="Range/Reach" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-damage" placeholder="Damage" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-qualities" placeholder="Qualities" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                </div>
                <div style="text-align: center;">
                    <button onclick="window.confirmAddWeapon()" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Add Weapon</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add click-outside-to-close functionality
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    window.closeModal();
                }
            });
            
            // Add event listener for weapon selection
            document.getElementById('weapon-select').addEventListener('change', function() {
                const selectedName = this.value;
                const detailsDiv = document.getElementById('weapon-details');
                const customFields = document.getElementById('custom-weapon-fields');
                
                if (selectedName === 'custom') {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'block';
                } else if (selectedName) {
                    const weapon = srdWeapons.find(w => w.name === selectedName);
                    if (weapon) {
                        document.getElementById('detail-category').textContent = weapon.category;
                        document.getElementById('detail-damage').textContent = weapon.damage;
                        document.getElementById('detail-reach').textContent = weapon.reach;
                        document.getElementById('detail-enc').textContent = weapon.encumbrance;
                        document.getElementById('detail-qualities').textContent = weapon.qualities.join(', ') || 'None';
                        document.getElementById('detail-flaws').textContent = weapon.flaws.join(', ') || 'None';
                        document.getElementById('detail-cost').textContent = weapon.cost;
                        detailsDiv.style.display = 'block';
                        customFields.style.display = 'none';
                    }
                } else {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'none';
                }
            });
        }

        window.confirmAddWeapon = function() {
            const selectedName = document.getElementById('weapon-select').value;
            
            if (!selectedName) {
                alert('Please select a weapon');
                return;
            }
            
            let weapon;
            if (selectedName === 'custom') {
                const customQualities = document.getElementById('custom-qualities').value;
                weapon = {
                    name: document.getElementById('custom-name').value,
                    group: document.getElementById('custom-group').value,
                    encumbrance: parseInt(document.getElementById('custom-enc').value) || 0,
                    range: document.getElementById('custom-range').value,
                    damage: document.getElementById('custom-damage').value,
                    qualities: customQualities.split(',').map(q => q.trim()).filter(q => q),
                    flaws: [],  // Custom weapons don't have separate flaws
                    equipped: false
                };
                
                if (!weapon.name) {
                    alert('Please enter a weapon name');
                    return;
                }
            } else {
                const srdWeapon = srdWeapons.find(w => w.name === selectedName);
                weapon = {
                    name: srdWeapon.name,
                    group: srdWeapon.category,
                    encumbrance: srdWeapon.encumbrance,
                    range: srdWeapon.reach,
                    damage: srdWeapon.damage,
                    qualities: srdWeapon.qualities || [],
                    flaws: srdWeapon.flaws || [],
                    equipped: false
                };
            }
            
            weapons.push(weapon);
            displayWeapons();
            updateEncumbrance();
            
            // Close modal
            window.closeModal();
        }

        window.displayWeapons = function() {
            const tbody = document.getElementById('weapons-tbody');
            tbody.innerHTML = '';
            
            weapons.forEach((weapon, index) => {
                // Combine qualities and flaws into a single string
                let qualitiesAndFlaws = [];
                
                // Handle qualities - could be array or string
                if (weapon.qualities) {
                    if (Array.isArray(weapon.qualities)) {
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(weapon.qualities);
                    } else if (typeof weapon.qualities === 'string' && weapon.qualities.trim()) {
                        // If it's a string, split by comma and trim
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(weapon.qualities.split(',').map(q => q.trim()).filter(q => q));
                    }
                }
                
                // Handle flaws if they exist as separate property
                if (weapon.flaws && Array.isArray(weapon.flaws)) {
                    qualitiesAndFlaws = qualitiesAndFlaws.concat(weapon.flaws);
                }
                
                const qualitiesText = qualitiesAndFlaws.length > 0 ? qualitiesAndFlaws.join(', ') : '-';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="skill-name-cell">${weapon.name}</td>
                    <td>${weapon.group}</td>
                    <td>${weapon.encumbrance}</td>
                    <td>${weapon.range}</td>
                    <td>${weapon.damage}</td>
                    <td style="font-size: 11px;">${qualitiesText}</td>
                    <td><input type="checkbox" ${weapon.equipped ? 'checked' : ''} onchange="window.toggleWeaponEquipped(${index})"></td>
                    <td>
                        <button class="advance-btn" onclick="window.editWeapon(${index})" style="background: #8b7355; color: white; margin-right: 2px;">âœŽ</button>
                        <button class="advance-btn" onclick="window.removeWeapon(${index})" style="background: #d44; color: white;">Ã—</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        window.toggleWeaponEquipped = function(index) {
            weapons[index].equipped = !weapons[index].equipped;
        }

        window.removeWeapon = function(index) {
            if (confirm('Remove this weapon?')) {
                weapons.splice(index, 1);
                displayWeapons();
                updateEncumbrance();
            }
        }

        // Edit weapon function
        window.editWeapon = function(index) {
            const weapon = weapons[index];
            
            // Close any existing modals first
            window.closeModal();
            
            // Create modal for weapon editing
            const modal = document.createElement('div');
            modal.id = 'edit-weapon-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Edit Weapon</h3>
                <div>
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Weapon Name:</label>
                    <input type="text" id="edit-weapon-name" value="${weapon.name}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Weapon Group:</label>
                    <input type="text" id="edit-weapon-group" value="${weapon.group}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Encumbrance:</label>
                    <input type="number" id="edit-weapon-enc" value="${weapon.encumbrance}" step="0.1" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Range/Reach:</label>
                    <input type="text" id="edit-weapon-range" value="${weapon.range}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Damage:</label>
                    <input type="text" id="edit-weapon-damage" value="${weapon.damage}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Qualities & Flaws (comma-separated):</label>
                    <input type="text" id="edit-weapon-qualities" value="${Array.isArray(weapon.qualities) ? [...(weapon.qualities || []), ...(weapon.flaws || [])].join(', ') : weapon.qualities}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="window.confirmEditWeapon(${index})" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Save Changes</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add click-outside-to-close functionality
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    window.closeModal();
                }
            });
        }

        window.confirmEditWeapon = function(index) {
            const qualitiesInput = document.getElementById('edit-weapon-qualities').value;
            const allQualities = qualitiesInput.split(',').map(q => q.trim()).filter(q => q);
            
            // Update weapon with new values
            weapons[index] = {
                ...weapons[index],
                name: document.getElementById('edit-weapon-name').value,
                group: document.getElementById('edit-weapon-group').value,
                encumbrance: parseFloat(document.getElementById('edit-weapon-enc').value) || 0,
                range: document.getElementById('edit-weapon-range').value,
                damage: document.getElementById('edit-weapon-damage').value,
                qualities: allQualities,  // Store as array for consistency
                flaws: []  // Flaws are now part of qualities array
            };
            
            displayWeapons();
            updateEncumbrance();
            window.closeModal();
        }

        // Armour Management
        window.addArmour = function() {
            // Close any existing modals first
            window.closeModal();
            
            // Create modal for armour selection
            const modal = document.createElement('div');
            modal.id = 'armour-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Armour</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Select Armour:</label>
                    <select id="armour-select" style="width: 100%; padding: 5px;">
                        <option value="">Choose armour...</option>
                        <option value="custom">-- Custom Armour --</option>
                        ${srdArmour.map(a => `<option value="${a.name}">${a.name} (${a.category})</option>`).join('')}
                    </select>
                </div>
                <div id="armour-details" style="display: none; margin-bottom: 15px; padding: 10px; background: #e8dfd0; border: 1px solid #8b7355;">
                    <p><strong>Category:</strong> <span id="detail-category"></span></p>
                    <p><strong>Armour Points:</strong> <span id="detail-ap"></span></p>
                    <p><strong>Locations:</strong> <span id="detail-locations"></span></p>
                    <p><strong>Encumbrance:</strong> <span id="detail-enc"></span></p>
                    <p><strong>Cost:</strong> <span id="detail-cost"></span></p>
                </div>
                <div id="custom-armour-fields" style="display: none;">
                    <input type="text" id="custom-name" placeholder="Armour name" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-type" placeholder="Type (e.g., Leather, Mail, Plate)" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-enc" placeholder="Encumbrance" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-head" placeholder="Head AP (0 if none)" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-arms" placeholder="Arms AP (0 if none)" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-body" placeholder="Body AP (0 if none)" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="number" id="custom-legs" placeholder="Legs AP (0 if none)" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <input type="text" id="custom-qualities" placeholder="Qualities/Notes" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                </div>
                <div style="text-align: center;">
                    <button onclick="window.confirmAddArmour()" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Add Armour</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add event listener for armour selection
            document.getElementById('armour-select').addEventListener('change', function() {
                const selectedName = this.value;
                const detailsDiv = document.getElementById('armour-details');
                const customFields = document.getElementById('custom-armour-fields');
                
                if (selectedName === 'custom') {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'block';
                } else if (selectedName) {
                    const armourPiece = srdArmour.find(a => a.name === selectedName);
                    if (armourPiece) {
                        document.getElementById('detail-category').textContent = armourPiece.category;
                        document.getElementById('detail-ap').textContent = armourPiece.ap;
                        document.getElementById('detail-locations').textContent = armourPiece.locations.join(', ');
                        document.getElementById('detail-enc').textContent = armourPiece.encumbrance;
                        document.getElementById('detail-cost').textContent = armourPiece.cost;
                        detailsDiv.style.display = 'block';
                        customFields.style.display = 'none';
                    }
                } else {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'none';
                }
            });
        }

        window.confirmAddArmour = function() {
            const selectedName = document.getElementById('armour-select').value;
            
            if (!selectedName) {
                alert('Please select armour');
                return;
            }
            
            let armourPiece;
            if (selectedName === 'custom') {
                const customQualities = document.getElementById('custom-qualities').value || '';
                armourPiece = {
                    name: document.getElementById('custom-name').value,
                    type: document.getElementById('custom-type').value,
                    encumbrance: parseInt(document.getElementById('custom-enc').value) || 0,
                    head: parseInt(document.getElementById('custom-head').value) || 0,
                    arms: parseInt(document.getElementById('custom-arms').value) || 0,
                    body: parseInt(document.getElementById('custom-body').value) || 0,
                    legs: parseInt(document.getElementById('custom-legs').value) || 0,
                    qualities: customQualities.split(',').map(q => q.trim()).filter(q => q),
                    flaws: [],
                    worn: false
                };
                
                if (!armourPiece.name) {
                    alert('Please enter an armour name');
                    return;
                }
            } else {
                const srdArmourPiece = srdArmour.find(a => a.name === selectedName);
                armourPiece = {
                    name: srdArmourPiece.name,
                    type: srdArmourPiece.category,
                    encumbrance: srdArmourPiece.encumbrance,
                    head: srdArmourPiece.locations.includes('Head') ? srdArmourPiece.ap : 0,
                    arms: srdArmourPiece.locations.includes('Arms') ? srdArmourPiece.ap : 0,
                    body: srdArmourPiece.locations.includes('Body') ? srdArmourPiece.ap : 0,
                    legs: srdArmourPiece.locations.includes('Legs') ? srdArmourPiece.ap : 0,
                    qualities: srdArmourPiece.qualities || [],
                    flaws: srdArmourPiece.flaws || [],
                    worn: false
                };
            }
            
            armour.push(armourPiece);
            displayArmour();
            updateEncumbrance();
            updateTotalAP();
            
            // Close modal
            window.closeModal();
        }

        window.displayArmour = function() {
            const tbody = document.getElementById('armour-tbody');
            tbody.innerHTML = '';
            
            armour.forEach((piece, index) => {
                // Combine qualities and flaws into a single string
                let qualitiesAndFlaws = [];
                
                // Handle qualities - could be array or string
                if (piece.qualities) {
                    if (Array.isArray(piece.qualities)) {
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(piece.qualities);
                    } else if (typeof piece.qualities === 'string' && piece.qualities.trim()) {
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(piece.qualities.split(',').map(q => q.trim()).filter(q => q));
                    }
                }
                
                // Handle flaws if they exist
                if (piece.flaws && Array.isArray(piece.flaws)) {
                    qualitiesAndFlaws = qualitiesAndFlaws.concat(piece.flaws);
                }
                
                const qualitiesText = qualitiesAndFlaws.length > 0 ? qualitiesAndFlaws.join(', ') : '-';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="skill-name-cell">${piece.name}</td>
                    <td>${piece.type}</td>
                    <td>${piece.encumbrance}</td>
                    <td>${piece.head || '-'}</td>
                    <td>${piece.arms || '-'}</td>
                    <td>${piece.body || '-'}</td>
                    <td>${piece.legs || '-'}</td>
                    <td style="font-size: 11px;">${qualitiesText}</td>
                    <td><input type="checkbox" ${piece.worn ? 'checked' : ''} onchange="window.toggleArmourWorn(${index})"></td>
                    <td>
                        <button class="advance-btn" onclick="window.editArmour(${index})" style="background: #8b7355; color: white; margin-right: 2px;">âœŽ</button>
                        <button class="advance-btn" onclick="window.removeArmour(${index})" style="background: #d44; color: white;">Ã—</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        window.toggleArmourWorn = function(index) {
            armour[index].worn = !armour[index].worn;
            updateTotalAP();
            updateEncumbrance();
        }

        window.removeArmour = function(index) {
            if (confirm('Remove this armour?')) {
                armour.splice(index, 1);
                displayArmour();
                updateEncumbrance();
                updateTotalAP();
            }
        }

        // Edit armour function
        window.editArmour = function(index) {
            const piece = armour[index];
            
            // Create modal for armour editing
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Edit Armour</h3>
                <div>
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Armour Name:</label>
                    <input type="text" id="edit-armour-name" value="${piece.name}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Type:</label>
                    <input type="text" id="edit-armour-type" value="${piece.type}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Encumbrance:</label>
                    <input type="number" id="edit-armour-enc" value="${piece.encumbrance}" step="0.1" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Head AP:</label>
                            <input type="number" id="edit-armour-head" value="${piece.head || 0}" min="0" style="width: 100%; padding: 5px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Arms AP:</label>
                            <input type="number" id="edit-armour-arms" value="${piece.arms || 0}" min="0" style="width: 100%; padding: 5px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Body AP:</label>
                            <input type="number" id="edit-armour-body" value="${piece.body || 0}" min="0" style="width: 100%; padding: 5px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Legs AP:</label>
                            <input type="number" id="edit-armour-legs" value="${piece.legs || 0}" min="0" style="width: 100%; padding: 5px;">
                        </div>
                    </div>
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Qualities & Flaws (comma-separated):</label>
                    <input type="text" id="edit-armour-qualities" value="${Array.isArray(piece.qualities) ? [...(piece.qualities || []), ...(piece.flaws || [])].join(', ') : piece.qualities || ''}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="window.confirmEditArmour(${index})" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Save Changes</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        window.confirmEditArmour = function(index) {
            const qualitiesInput = document.getElementById('edit-armour-qualities').value;
            const allQualities = qualitiesInput.split(',').map(q => q.trim()).filter(q => q);
            
            // Update armour with new values
            armour[index] = {
                ...armour[index],
                name: document.getElementById('edit-armour-name').value,
                type: document.getElementById('edit-armour-type').value,
                encumbrance: parseFloat(document.getElementById('edit-armour-enc').value) || 0,
                head: parseInt(document.getElementById('edit-armour-head').value) || 0,
                arms: parseInt(document.getElementById('edit-armour-arms').value) || 0,
                body: parseInt(document.getElementById('edit-armour-body').value) || 0,
                legs: parseInt(document.getElementById('edit-armour-legs').value) || 0,
                qualities: allQualities,  // Store as array
                flaws: []  // Flaws are now part of qualities array
            };
            
            displayArmour();
            updateEncumbrance();
            updateTotalAP();
            window.closeModal();
        }

        window.updateTotalAP = function() {
            let totalHead = 0, totalArms = 0, totalBody = 0, totalLegs = 0;
            
            armour.forEach(piece => {
                if (piece.worn) {
                    totalHead += piece.head || 0;
                    totalArms += piece.arms || 0;
                    totalBody += piece.body || 0;
                    totalLegs += piece.legs || 0;
                }
            });
            
            document.getElementById('total-ap-head').value = totalHead;
            document.getElementById('total-ap-arms').value = totalArms;
            document.getElementById('total-ap-body').value = totalBody;
            document.getElementById('total-ap-legs').value = totalLegs;
        }

        // Trappings/Inventory Management
        window.addTrapping = function() {
            const name = prompt('Item name:');
            if (!name) return; // Exit immediately if user cancels or enters empty name
            
            const quantity = parseInt(prompt('Quantity:') || '1');
            if (quantity === null) return; // Exit if user cancels
            
            const encumbrance = parseFloat(prompt('Encumbrance per item:') || '0');
            if (encumbrance === null) return; // Exit if user cancels
            
            const location = prompt('Carried where? (e.g., Backpack, Belt, Worn):') || 'Backpack';
            if (location === null) return; // Exit if user cancels
            
            const notes = prompt('Notes:') || '';
            if (notes === null) return; // Exit if user cancels
            
            const item = {
                name: name,
                quantity: quantity,
                encumbrance: encumbrance,
                location: location,
                notes: notes
            };
            
            trappings.push(item);
            displayTrappings();
            updateEncumbrance();
        }

        window.displayTrappings = function() {
            const tbody = document.getElementById('trappings-tbody');
            tbody.innerHTML = '';
            
            trappings.forEach((item, index) => {
                const totalEnc = (item.quantity * item.encumbrance).toFixed(1);
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="skill-name-cell">${item.name}</td>
                    <td><input type="number" value="${item.quantity}" min="0" onchange="window.updateTrappingQuantity(${index}, this.value)" style="width: 60px;"></td>
                    <td>${item.encumbrance}</td>
                    <td style="font-weight: bold;">${totalEnc}</td>
                    <td>${item.location}</td>
                    <td><input type="text" value="${item.notes}" onchange="window.updateTrappingNotes(${index}, this.value)" style="width: 100%; border: none; font-size: 11px;"></td>
                    <td>
                        <button class="advance-btn" onclick="window.editTrapping(${index})" style="background: #8b7355; color: white; margin-right: 2px;">âœŽ</button>
                        <button class="advance-btn" onclick="window.removeTrapping(${index})" style="background: #d44; color: white;">Ã—</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        window.updateTrappingQuantity = function(index, value) {
            trappings[index].quantity = parseInt(value) || 0;
            displayTrappings();
            updateEncumbrance();
        }

        window.updateTrappingNotes = function(index, value) {
            trappings[index].notes = value;
        }

        window.removeTrapping = function(index) {
            if (confirm('Remove this item?')) {
                trappings.splice(index, 1);
                displayTrappings();
                updateEncumbrance();
            }
        }

        // Edit trapping function
        window.editTrapping = function(index) {
            const item = trappings[index];
            
            // Create modal for trapping editing
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Edit Trapping</h3>
                <div>
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Item Name:</label>
                    <input type="text" id="edit-trapping-name" value="${item.name}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Quantity:</label>
                    <input type="number" id="edit-trapping-quantity" value="${item.quantity}" min="1" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Encumbrance (per item):</label>
                    <input type="number" id="edit-trapping-enc" value="${item.encumbrance}" step="0.1" min="0" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Location:</label>
                    <select id="edit-trapping-location" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                        <option value="On person" ${item.location === 'On person' ? 'selected' : ''}>On person</option>
                        <option value="Backpack" ${item.location === 'Backpack' ? 'selected' : ''}>Backpack</option>
                        <option value="Belt" ${item.location === 'Belt' ? 'selected' : ''}>Belt</option>
                        <option value="Pouch" ${item.location === 'Pouch' ? 'selected' : ''}>Pouch</option>
                        <option value="Horse" ${item.location === 'Horse' ? 'selected' : ''}>Horse</option>
                        <option value="Cart" ${item.location === 'Cart' ? 'selected' : ''}>Cart</option>
                        <option value="Stashed" ${item.location === 'Stashed' ? 'selected' : ''}>Stashed</option>
                    </select>
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Notes:</label>
                    <textarea id="edit-trapping-notes" style="width: 100%; margin-bottom: 10px; padding: 5px; min-height: 60px;">${item.notes || ''}</textarea>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="window.confirmEditTrapping(${index})" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Save Changes</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        window.confirmEditTrapping = function(index) {
            // Update trapping with new values
            trappings[index] = {
                ...trappings[index],
                name: document.getElementById('edit-trapping-name').value,
                quantity: parseInt(document.getElementById('edit-trapping-quantity').value) || 1,
                encumbrance: parseFloat(document.getElementById('edit-trapping-enc').value) || 0,
                location: document.getElementById('edit-trapping-location').value,
                notes: document.getElementById('edit-trapping-notes').value
            };
            
            displayTrappings();
            updateEncumbrance();
            window.closeModal();
        }

        // Consumables Management
        window.addConsumable = function() {
            // Create modal for consumable selection
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            // Check what ranged weapons the character has to suggest appropriate ammo
            const weaponCategories = [...new Set(weapons.map(w => w.group))];
            
            let suggestedAmmo = '';
            const suggestions = [];
            
            // Map weapon categories to ammunition subtypes
            if (weaponCategories.includes('bow')) {
                const bowAmmo = srdAmmunition.filter(a => a.subtype === 'bow');
                suggestions.push(...bowAmmo);
            }
            if (weaponCategories.includes('crossbow')) {
                const crossbowAmmo = srdAmmunition.filter(a => a.subtype === 'crossbow');
                suggestions.push(...crossbowAmmo);
            }
            if (weaponCategories.includes('blackpowder') || weaponCategories.includes('engineering')) {
                const blackpowderAmmo = srdAmmunition.filter(a => a.subtype === 'blackpowder');
                suggestions.push(...blackpowderAmmo);
            }
            if (weaponCategories.includes('sling')) {
                const slingAmmo = srdAmmunition.filter(a => a.subtype === 'sling');
                suggestions.push(...slingAmmo);
            }
            
            if (suggestions.length > 0) {
                suggestedAmmo = '<optgroup label="Suggested Ammunition (based on your weapons)">';
                suggestions.forEach(ammo => {
                    suggestedAmmo += `<option value="${ammo.name}">${ammo.name} (${ammo.quantity} for ${ammo.cost})</option>`;
                });
                suggestedAmmo += '</optgroup>';
            }
            
            // Group ammunition by subtype
            const ammoByType = {
                bow: srdAmmunition.filter(a => a.subtype === 'bow'),
                crossbow: srdAmmunition.filter(a => a.subtype === 'crossbow'),
                blackpowder: srdAmmunition.filter(a => a.subtype === 'blackpowder'),
                sling: srdAmmunition.filter(a => a.subtype === 'sling')
            };
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Add Ammunition/Consumable</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Select Item:</label>
                    <select id="consumable-select" style="width: 100%; padding: 5px;">
                        <option value="">Choose an item...</option>
                        ${suggestedAmmo}
                        ${ammoByType.bow.length > 0 ? `
                            <optgroup label="Bow Ammunition">
                                ${ammoByType.bow.map(a => `<option value="${a.name}">${a.name} (${a.quantity} for ${a.cost})</option>`).join('')}
                            </optgroup>
                        ` : ''}
                        ${ammoByType.crossbow.length > 0 ? `
                            <optgroup label="Crossbow Ammunition">
                                ${ammoByType.crossbow.map(a => `<option value="${a.name}">${a.name} (${a.quantity} for ${a.cost})</option>`).join('')}
                            </optgroup>
                        ` : ''}
                        ${ammoByType.blackpowder.length > 0 ? `
                            <optgroup label="Blackpowder Ammunition">
                                ${ammoByType.blackpowder.map(a => `<option value="${a.name}">${a.name} (${a.quantity} for ${a.cost})</option>`).join('')}
                            </optgroup>
                        ` : ''}
                        ${ammoByType.sling.length > 0 ? `
                            <optgroup label="Sling Ammunition">
                                ${ammoByType.sling.map(a => `<option value="${a.name}">${a.name} (${a.quantity} for ${a.cost})</option>`).join('')}
                            </optgroup>
                        ` : ''}
                        <optgroup label="Other">
                            <option value="Bandages">Bandages (Medical)</option>
                            <option value="Healing Draught">Healing Draught (Medical)</option>
                            <option value="Torches">Torches (Utility)</option>
                            <option value="Oil (lamp)">Oil for Lanterns (Utility)</option>
                            <option value="Rations">Rations (1 day)</option>
                        </optgroup>
                        <option value="custom">-- Custom Item --</option>
                    </select>
                </div>
                <div id="consumable-details" style="display: none; margin-bottom: 15px; padding: 10px; background: #e8dfd0; border: 1px solid #8b7355;">
                    <p><strong>Type:</strong> <span id="detail-type"></span></p>
                    <p><strong>Standard Quantity:</strong> <span id="detail-quantity"></span></p>
                    <p><strong>Cost:</strong> <span id="detail-cost"></span></p>
                    <p><strong>Availability:</strong> <span id="detail-availability"></span></p>
                    <p><strong>Qualities:</strong> <span id="detail-qualities"></span></p>
                    <p><strong>Range Modifier:</strong> <span id="detail-range"></span></p>
                    <p><strong>Damage Modifier:</strong> <span id="detail-damage"></span></p>
                    <p><strong>Notes:</strong> <span id="detail-notes"></span></p>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Quantity to Add:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <label style="font-size: 12px;">Current:</label>
                            <input type="number" id="consumable-current" value="12" min="0" style="width: 100%; padding: 5px;">
                        </div>
                        <div>
                            <label style="font-size: 12px;">Maximum:</label>
                            <input type="number" id="consumable-max" value="24" min="0" style="width: 100%; padding: 5px;">
                        </div>
                    </div>
                </div>
                <div id="custom-consumable-fields" style="display: none;">
                    <input type="text" id="custom-name" placeholder="Item name" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    <textarea id="custom-notes" placeholder="Notes" style="width: 100%; margin-bottom: 10px; padding: 5px; height: 60px;"></textarea>
                </div>
                <div style="text-align: center;">
                    <button onclick="window.confirmAddConsumable()" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Add Item</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Set default quantities based on item type
            document.getElementById('consumable-select').addEventListener('change', function() {
                const selectedName = this.value;
                const detailsDiv = document.getElementById('consumable-details');
                const customFields = document.getElementById('custom-consumable-fields');
                const currentInput = document.getElementById('consumable-current');
                const maxInput = document.getElementById('consumable-max');
                
                if (selectedName === 'custom') {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'block';
                } else if (selectedName) {
                    const item = srdAmmunition.find(a => a.name === selectedName);
                    if (item) {
                        document.getElementById('detail-type').textContent = item.subtype || item.type;
                        document.getElementById('detail-quantity').textContent = item.quantity + ' per package';
                        document.getElementById('detail-cost').textContent = item.cost;
                        document.getElementById('detail-availability').textContent = item.availability || 'Common';
                        document.getElementById('detail-qualities').textContent = item.qualities?.join(', ') || 'None';
                        document.getElementById('detail-range').textContent = item.rangeModifier || 'N/A';
                        document.getElementById('detail-damage').textContent = item.damageModifier || 'N/A';
                        document.getElementById('detail-notes').textContent = item.notes || '';
                        detailsDiv.style.display = 'block';
                        customFields.style.display = 'none';
                        
                        // Set default quantities based on standard package
                        currentInput.value = item.quantity;
                        maxInput.value = item.quantity * 2;
                    } else {
                        // Handle non-ammunition items
                        detailsDiv.style.display = 'none';
                        customFields.style.display = 'none';
                        currentInput.value = 1;
                        maxInput.value = 5;
                    }
                } else {
                    detailsDiv.style.display = 'none';
                    customFields.style.display = 'none';
                }
            });
        }

        window.confirmAddConsumable = function() {
            const selectedName = document.getElementById('consumable-select').value;
            const current = parseInt(document.getElementById('consumable-current').value) || 0;
            const maximum = parseInt(document.getElementById('consumable-max').value) || 0;
            
            if (!selectedName) {
                alert('Please select an item');
                return;
            }
            
            let consumable;
            if (selectedName === 'custom') {
                consumable = {
                    name: document.getElementById('custom-name').value,
                    current: current,
                    maximum: maximum,
                    qualities: [],
                    flaws: [],
                    notes: document.getElementById('custom-notes').value || ''
                };
                
                if (!consumable.name) {
                    alert('Please enter an item name');
                    return;
                }
            } else {
                const item = srdAmmunition.find(a => a.name === selectedName);
                if (item) {
                    consumable = {
                        name: item.name,
                        current: current,
                        maximum: maximum,
                        qualities: item.qualities || [],
                        flaws: item.flaws || [],
                        notes: item.notes || ''
                    };
                } else {
                    // Handle non-ammunition items
                    consumable = {
                        name: selectedName,
                        current: current,
                        maximum: maximum,
                        qualities: [],
                        flaws: [],
                        notes: ''
                    };
                }
            }
            
            // Check if this consumable already exists and combine quantities
            const existing = consumables.find(c => c.name === consumable.name);
            if (existing) {
                existing.current += consumable.current;
                existing.maximum += consumable.maximum;
            } else {
                consumables.push(consumable);
            }
            
            displayConsumables();
            
            // Close modal
            window.closeModal();
        }

        window.displayConsumables = function() {
            const tbody = document.getElementById('consumables-tbody');
            tbody.innerHTML = '';
            
            consumables.forEach((item, index) => {
                // Combine qualities and flaws into a single string
                let qualitiesAndFlaws = [];
                
                // Handle qualities - could be array or string
                if (item.qualities) {
                    if (Array.isArray(item.qualities)) {
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(item.qualities);
                    } else if (typeof item.qualities === 'string' && item.qualities.trim()) {
                        qualitiesAndFlaws = qualitiesAndFlaws.concat(item.qualities.split(',').map(q => q.trim()).filter(q => q));
                    }
                }
                
                // Handle flaws if they exist
                if (item.flaws && Array.isArray(item.flaws)) {
                    qualitiesAndFlaws = qualitiesAndFlaws.concat(item.flaws);
                }
                
                const qualitiesText = qualitiesAndFlaws.length > 0 ? qualitiesAndFlaws.join(', ') : '-';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="skill-name-cell">${item.name}</td>
                    <td>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <button onclick="window.adjustConsumable(${index}, -1)" style="width: 25px; height: 22px; cursor: pointer;">-</button>
                            <input type="number" value="${item.current}" min="0" max="${item.maximum}" onchange="window.setConsumableCurrent(${index}, this.value)" style="width: 40px; text-align: center;">
                            <button onclick="window.adjustConsumable(${index}, 1)" style="width: 25px; height: 22px; cursor: pointer;">+</button>
                        </div>
                    </td>
                    <td><input type="number" value="${item.maximum}" min="0" onchange="window.setConsumableMax(${index}, this.value)" style="width: 50px;"></td>
                    <td style="font-size: 11px;">${qualitiesText}</td>
                    <td><input type="text" value="${item.notes || ''}" onchange="window.updateConsumableNotes(${index}, this.value)" style="width: 100%; border: none; font-size: 11px;"></td>
                    <td>
                        <button class="advance-btn" onclick="window.editConsumable(${index})" style="background: #8b7355; color: white; margin-right: 2px;">âœŽ</button>
                        <button class="advance-btn" onclick="window.removeConsumable(${index})" style="background: #d44; color: white;">Ã—</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        window.adjustConsumable = function(index, amount) {
            const newValue = consumables[index].current + amount;
            consumables[index].current = Math.max(0, Math.min(newValue, consumables[index].maximum));
            displayConsumables();
        }

        window.setConsumableCurrent = function(index, value) {
            consumables[index].current = Math.max(0, Math.min(parseInt(value) || 0, consumables[index].maximum));
            displayConsumables();
        }

        window.setConsumableMax = function(index, value) {
            consumables[index].maximum = parseInt(value) || 0;
            if (consumables[index].current > consumables[index].maximum) {
                consumables[index].current = consumables[index].maximum;
            }
            displayConsumables();
        }

        window.updateConsumableNotes = function(index, value) {
            consumables[index].notes = value;
        }

        window.removeConsumable = function(index) {
            if (confirm('Remove this consumable?')) {
                consumables.splice(index, 1);
                displayConsumables();
            }
        }

        // Edit consumable function
        window.editConsumable = function(index) {
            const item = consumables[index];
            
            // Create modal for consumable editing
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #faf8f3; border: 3px solid #3e2f1f; padding: 20px; max-width: 500px; max-height: 70vh; overflow-y: auto;';
            
            modalContent.innerHTML = `
                <h3 style="color: #3e2f1f; margin-bottom: 15px;">Edit Consumable</h3>
                <div>
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Item Name:</label>
                    <input type="text" id="edit-consumable-name" value="${item.name}" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Current Amount:</label>
                    <input type="number" id="edit-consumable-current" value="${item.current}" min="0" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Maximum Amount:</label>
                    <input type="number" id="edit-consumable-max" value="${item.maximum}" min="0" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Type:</label>
                    <select id="edit-consumable-type" style="width: 100%; margin-bottom: 10px; padding: 5px;">
                        <option value="Ammunition" ${item.type === 'Ammunition' ? 'selected' : ''}>Ammunition</option>
                        <option value="Food & Drink" ${item.type === 'Food & Drink' ? 'selected' : ''}>Food & Drink</option>
                        <option value="Medicine" ${item.type === 'Medicine' ? 'selected' : ''}>Medicine</option>
                        <option value="Poison" ${item.type === 'Poison' ? 'selected' : ''}>Poison</option>
                        <option value="Potion" ${item.type === 'Potion' ? 'selected' : ''}>Potion</option>
                        <option value="Other" ${item.type === 'Other' ? 'selected' : ''}>Other</option>
                    </select>
                    
                    <label style="display: block; margin-bottom: 5px; color: #3e2f1f;">Notes:</label>
                    <textarea id="edit-consumable-notes" style="width: 100%; margin-bottom: 10px; padding: 5px; min-height: 60px;">${item.notes || ''}</textarea>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="window.confirmEditConsumable(${index})" style="margin-right: 10px; padding: 8px 16px; background: #3e2f1f; color: #faf8f3; border: none; cursor: pointer;">Save Changes</button>
                    <button onclick="window.closeModal()" style="padding: 8px 16px; background: #8b7355; color: #faf8f3; border: none; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        window.confirmEditConsumable = function(index) {
            const currentVal = parseInt(document.getElementById('edit-consumable-current').value) || 0;
            const maxVal = parseInt(document.getElementById('edit-consumable-max').value) || 0;
            
            // Update consumable with new values
            consumables[index] = {
                ...consumables[index],
                name: document.getElementById('edit-consumable-name').value,
                current: Math.min(currentVal, maxVal),
                maximum: maxVal,
                type: document.getElementById('edit-consumable-type').value,
                notes: document.getElementById('edit-consumable-notes').value
            };
            
            displayConsumables();
            window.closeModal();
        }

        // Encumbrance Calculation
        window.updateEncumbrance = function() {
            let weaponsEnc = 0;
            let armourEnc = 0;
            let trappingsEnc = 0;
            
            // Add weapon encumbrance (only equipped weapons count)
            weapons.forEach(weapon => {
                if (weapon.equipped) {
                    weaponsEnc += weapon.encumbrance || 0;
                }
            });
            
            // Add armour encumbrance (worn items get -1 encumbrance reduction)
            armour.forEach(piece => {
                if (piece.worn) {
                    // Worn items get their encumbrance reduced by 1 (minimum 0)
                    const wornEnc = Math.max(0, (piece.encumbrance || 0) - 1);
                    armourEnc += wornEnc;
                } else {
                    // Not worn, full encumbrance
                    armourEnc += piece.encumbrance || 0;
                }
            });
            
            // Add trapping encumbrance
            trappings.forEach(item => {
                trappingsEnc += (item.quantity * item.encumbrance) || 0;
            });
            
            // Add money weight (1 Enc per 200 coins)
            const gold = parseInt(document.getElementById('money-gold').value) || 0;
            const silver = parseInt(document.getElementById('money-silver').value) || 0;
            const brass = parseInt(document.getElementById('money-brass').value) || 0;
            const totalCoins = gold + silver + brass;
            const moneyEnc = Math.floor(totalCoins / 200);
            
            // Calculate total encumbrance
            const totalEnc = weaponsEnc + armourEnc + trappingsEnc + moneyEnc;
            
            // Calculate max encumbrance (Strength Bonus + Toughness Bonus)
            const strength = parseInt(document.getElementById('s-current').value) || 0;
            const toughness = parseInt(document.getElementById('t-current').value) || 0;
            const sb = Math.floor(strength / 10);
            const tb = Math.floor(toughness / 10);
            const maxEnc = sb + tb;
            
            // Update display
            document.getElementById('current-enc').value = totalEnc.toFixed(1);
            document.getElementById('max-enc').value = maxEnc;
            
            // Update breakdown display
            document.getElementById('enc-weapons').textContent = weaponsEnc.toFixed(1);
            document.getElementById('enc-armour').textContent = armourEnc.toFixed(1);
            document.getElementById('enc-trappings').textContent = trappingsEnc.toFixed(1);
            document.getElementById('enc-money').textContent = moneyEnc + (totalCoins > 0 ? ` (${totalCoins} coins)` : '');
            
            // Calculate penalties based on encumbrance level
            const statusField = document.getElementById('enc-status');
            const penaltiesField = document.getElementById('enc-penalties');
            const movementField = document.getElementById('movement');
            const baseMovement = parseInt(movementField.getAttribute('data-base-movement') || movementField.value || 4);
            
            // Store base movement if not already stored
            if (!movementField.getAttribute('data-base-movement')) {
                movementField.setAttribute('data-base-movement', movementField.value || 4);
            }
            
            let movementPenalty = 0;
            let agilityPenalty = 0;
            let travelFatigue = 0;
            let statusText = '';
            let statusColor = '';
            let penaltiesText = '';
            let penaltiesColor = '';
            
            if (totalEnc <= maxEnc) {
                // No penalties
                statusText = 'Unencumbered';
                statusColor = 'green';
                penaltiesText = 'None';
                penaltiesColor = 'green';
                movementPenalty = 0;
                agilityPenalty = 0;
                travelFatigue = 0;
            } else if (totalEnc <= maxEnc * 2) {
                // Up to double limit
                statusText = 'Encumbered';
                statusColor = 'orange';
                penaltiesText = '-1 Movement (min 3), -10 Agility, +1 Travel Fatigue';
                penaltiesColor = 'orange';
                movementPenalty = 1;
                agilityPenalty = 10;
                travelFatigue = 1;
            } else if (totalEnc <= maxEnc * 3) {
                // Up to triple limit
                statusText = 'Very Encumbered';
                statusColor = 'red';
                penaltiesText = '-2 Movement (min 2), -20 Agility (min 10), +2 Travel Fatigue';
                penaltiesColor = 'red';
                movementPenalty = 2;
                agilityPenalty = 20;
                travelFatigue = 2;
            } else {
                // More than 3x limit
                statusText = 'Immobilized!';
                statusColor = 'darkred';
                penaltiesText = 'Cannot move! Drop items immediately!';
                penaltiesColor = 'darkred';
                movementPenalty = 999; // Effectively immobilized
            }
            
            statusField.value = statusText;
            statusField.style.color = statusColor;
            penaltiesField.textContent = penaltiesText;
            penaltiesField.style.color = penaltiesColor;
            
            // Apply movement penalty (minimum based on encumbrance level)
            let newMovement = baseMovement - movementPenalty;
            if (totalEnc <= maxEnc * 2) {
                newMovement = Math.max(3, newMovement); // Minimum 3 for encumbered
            } else if (totalEnc <= maxEnc * 3) {
                newMovement = Math.max(2, newMovement); // Minimum 2 for very encumbered
            } else {
                newMovement = 0; // Cannot move when over 3x limit
            }
            
            // Update movement field with penalty applied
            if (movementPenalty > 0 && movementPenalty < 999) {
                movementField.value = newMovement;
                movementField.style.color = 'red';
                movementField.title = `Base Movement: ${baseMovement}, Encumbrance Penalty: -${movementPenalty}`;
            } else if (movementPenalty === 999) {
                movementField.value = 0;
                movementField.style.color = 'darkred';
                movementField.title = 'Too encumbered to move!';
            } else {
                movementField.value = baseMovement;
                movementField.style.color = '';
                movementField.title = '';
            }
            
            // Update walk and run based on new movement
            const walkField = document.getElementById('walk');
            const runField = document.getElementById('run');
            walkField.value = newMovement * 2;
            runField.value = newMovement * 4;
            
            // Store penalties for reference (could be displayed elsewhere)
            document.getElementById('enc-status').setAttribute('data-agility-penalty', agilityPenalty);
            document.getElementById('enc-status').setAttribute('data-travel-fatigue', travelFatigue);
            
            // Update Agility to show penalty
            const agCurrent = document.getElementById('agi-current');
            if (agCurrent && agCurrent.updateFunction) {
                agCurrent.updateFunction();
            }
        }

        // Species Creation Wizard Variables
        let currentWizardStep = 1;
        let selectedSpecies = '';
        let wizardData = {
            characteristics: {},
            wounds: 0,
            fate: { base: 0, extra: 0, total: 0 },
            resilience: { base: 0, extra: 0, total: 0 },
            movement: 0,
            skills: { step3: [], step4: [] },
            talents: { fixed: [], choices: [], selected: [] },
            extraPoints: 0,
            usedExtraPoints: 0
        };

        // Class Trappings Wizard Variables
        let currentClassWizardStep = 1;
        let selectedClass = '';
        let classWizardData = {
            fixed: [],
            rolls: {},
            choices: {},
            finalEquipment: []
        };

        // Species Creation Wizard Functions
        function openSpeciesWizard(species) {
            selectedSpecies = species;
            const speciesInfo = speciesData[species];
            
            if (!speciesInfo) {
                console.error('Species not found:', species);
                return;
            }

            // Reset wizard data
            wizardData = {
                characteristics: {},
                wounds: 0,
                fate: { base: speciesInfo.baseFate, extra: 0, total: speciesInfo.baseFate },
                resilience: { base: speciesInfo.baseResilience, extra: 0, total: speciesInfo.baseResilience },
                movement: speciesInfo.movement,
                skills: { step3: [], step4: [] },
                talents: { random: [], selected: [] },
                extraPoints: speciesInfo.extraPoints,
                usedExtraPoints: 0
            };

            // Initialize Step 1 with species data
            initializeStep1(speciesInfo);
            
            // Show modal and start at step 1
            currentWizardStep = 1;
            updateWizardDisplay();
            document.getElementById('species-wizard-modal').style.display = 'block';
        }

        function initializeStep1(speciesInfo) {
            // Update species info display
            const speciesInfoDiv = document.getElementById('species-info');
            speciesInfoDiv.innerHTML = `
                <h4 style="color: #3e2f1f; margin-bottom: 10px;">${selectedSpecies}</h4>
                <p><strong>Fate:</strong> ${speciesInfo.baseFate} | <strong>Resilience:</strong> ${speciesInfo.baseResilience} | <strong>Movement:</strong> ${speciesInfo.movement}</p>
                <p><strong>Species Skills:</strong> ${speciesInfo.skills.join(', ')}</p>
                <p><strong>Fixed Talents:</strong> ${speciesInfo.fixedTalents ? speciesInfo.fixedTalents.join(', ') : 'None'}</p>
            `;

            // Create characteristics grid dynamically
            const characteristicsGrid = document.getElementById('characteristics-grid');
            characteristicsGrid.innerHTML = '';
            
            Object.keys(speciesInfo.characteristics).forEach(char => {
                const charData = speciesInfo.characteristics[char];
                const charDiv = document.createElement('div');
                charDiv.className = 'char-advance-group';
                charDiv.innerHTML = `
                    <label>${char}</label>
                    <div style="display: flex; align-items: center; gap: 5px; flex-direction: column;">
                        <div style="font-size: 11px; color: #666;">
                            Range: <span id="char-${char.toLowerCase()}-range">${charData.min}-${charData.max}</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span id="char-${char.toLowerCase()}-base">${charData.base}</span>
                            <span>+</span>
                            <input type="number" id="char-${char.toLowerCase()}-roll" min="2" max="20" value="0" style="width: 50px; text-align: center;" placeholder="2-20" oninput="updateCharacteristicTotal('${char.toLowerCase()}')">
                            <span>=</span>
                            <strong id="char-${char.toLowerCase()}-total">${charData.base}</strong>
                        </div>
                    </div>
                `;
                characteristicsGrid.appendChild(charDiv);
                
                // Store in wizard data
                wizardData.characteristics[char] = {
                    base: charData.base,
                    roll: 0,
                    total: charData.base,
                    min: charData.min,
                    max: charData.max
                };
            });
        }

        // Characteristic calculation function
        function updateCharacteristicTotal(char) {
            const speciesInfo = speciesData[selectedSpecies];
            
            // Find the correct characteristic key (handle case sensitivity)
            const charKey = Object.keys(speciesInfo.characteristics).find(key => 
                key.toLowerCase() === char.toLowerCase()
            );
            
            if (charKey) {
                const charData = speciesInfo.characteristics[charKey];
                const rollInput = document.getElementById(`char-${char.toLowerCase()}-roll`);
                const totalSpan = document.getElementById(`char-${char.toLowerCase()}-total`);
                
                const roll = parseInt(rollInput.value) || 0;
                const total = charData.base + roll;
                
                totalSpan.textContent = total;
                
                // Store in wizard data using the correct key
                wizardData.characteristics[charKey] = {
                    base: charData.base,
                    roll: roll,
                    total: total,
                    min: charData.min,
                    max: charData.max
                };
            }
        }


        // Step 2 functions: Wounds, Fate, and Resilience
        function initializeStep2() {
            const speciesInfo = speciesData[selectedSpecies];
            
            // Update wounds formula display
            document.getElementById('wounds-formula').textContent = speciesInfo.woundsFormula;
            
            // Calculate and display wounds
            calculateWounds();
            
            // Update fate and resilience displays
            document.getElementById('base-fate-resilience').textContent = `Fate ${speciesInfo.baseFate}, Resilience ${speciesInfo.baseResilience}`;
            document.getElementById('extra-points-remaining').textContent = speciesInfo.extraPoints;
            
            document.getElementById('base-fate').textContent = speciesInfo.baseFate;
            document.getElementById('base-resilience').textContent = speciesInfo.baseResilience;
            document.getElementById('total-fate').textContent = speciesInfo.baseFate;
            document.getElementById('total-resilience').textContent = speciesInfo.baseResilience;
            
            // Reset extra points
            document.getElementById('extra-fate').value = 0;
            document.getElementById('extra-resilience').value = 0;
            
            // Update movement
            document.getElementById('species-movement').textContent = speciesInfo.movement;
        }

        function calculateWounds() {
            const speciesInfo = speciesData[selectedSpecies];
            let wounds = 0;
            
            // Get current characteristic values from the totals
            const s = parseInt(document.getElementById('char-s-total')?.textContent) || wizardData.characteristics.S?.total || 0;
            const t = parseInt(document.getElementById('char-t-total')?.textContent) || wizardData.characteristics.T?.total || 0;
            const wp = parseInt(document.getElementById('char-wp-total')?.textContent) || wizardData.characteristics.WP?.total || 0;
            
            // Calculate bonus values (tens digit)
            const sb = Math.floor(s / 10);
            const tb = Math.floor(t / 10);
            const wpb = Math.floor(wp / 10);
            
            // Apply species-specific formula
            if (selectedSpecies === "Halfling") {
                wounds = (2 * tb) + wpb;
            } else {
                wounds = sb + (2 * tb) + wpb;
            }
            
            wizardData.wounds = wounds;
            document.getElementById('calculated-wounds').textContent = wounds;
        }

        function updateExtraPointsDistribution() {
            const speciesInfo = speciesData[selectedSpecies];
            const extraFate = parseInt(document.getElementById('extra-fate').value) || 0;
            const extraResilience = parseInt(document.getElementById('extra-resilience').value) || 0;
            const totalUsed = extraFate + extraResilience;
            
            // Validate total doesn't exceed available points
            if (totalUsed > speciesInfo.extraPoints) {
                alert(`You can only distribute ${speciesInfo.extraPoints} extra points total.`);
                // Reset the field that caused the overflow
                if (event.target.id === 'extra-fate') {
                    document.getElementById('extra-fate').value = Math.max(0, speciesInfo.extraPoints - extraResilience);
                } else {
                    document.getElementById('extra-resilience').value = Math.max(0, speciesInfo.extraPoints - extraFate);
                }
                return;
            }
            
            // Update totals
            const totalFate = speciesInfo.baseFate + extraFate;
            const totalResilience = speciesInfo.baseResilience + extraResilience;
            
            document.getElementById('total-fate').textContent = totalFate;
            document.getElementById('total-resilience').textContent = totalResilience;
            document.getElementById('extra-points-remaining').textContent = speciesInfo.extraPoints - totalUsed;
            
            // Store in wizard data
            wizardData.fate = { base: speciesInfo.baseFate, extra: extraFate, total: totalFate };
            wizardData.resilience = { base: speciesInfo.baseResilience, extra: extraResilience, total: totalResilience };
            wizardData.usedExtraPoints = totalUsed;
        }

        function nextWizardStep() {
            if (currentWizardStep < 6) {
                // Validate current step before proceeding
                if (validateWizardStep(currentWizardStep)) {
                    currentWizardStep++;
                    
                    // Initialize the next step
                    if (currentWizardStep === 2) initializeStep2();
                    else if (currentWizardStep === 3) initializeStep3();
                    else if (currentWizardStep === 4) initializeStep4();
                    else if (currentWizardStep === 5) initializeStep5();
                    else if (currentWizardStep === 6) initializeStep6();
                    
                    updateWizardDisplay();
                }
            }
        }

        function previousWizardStep() {
            if (currentWizardStep > 1) {
                currentWizardStep--;
                updateWizardDisplay();
            }
        }

        function validateWizardStep(step) {
            const speciesInfo = speciesData[selectedSpecies];
            
            switch(step) {
                case 1:
                    // Update characteristics from input fields and validate ranges
                    let allValid = true;
                    Object.keys(speciesInfo.characteristics).forEach(char => {
                        const rollInput = document.getElementById(`char-${char.toLowerCase()}-roll`);
                        const totalSpan = document.getElementById(`char-${char.toLowerCase()}-total`);
                        if (rollInput && totalSpan) {
                            const roll = parseInt(rollInput.value) || 0;
                            const total = parseInt(totalSpan.textContent) || speciesInfo.characteristics[char].base;
                            const charData = speciesInfo.characteristics[char];
                            
                            // Validate dice roll range (2-20)
                            if (roll > 0 && (roll < 2 || roll > 20)) {
                                alert(`Dice roll for ${char} must be between 2 and 20.`);
                                allValid = false;
                                return;
                            }
                            
                            // Validate final total range
                            if (total < charData.min || total > charData.max) {
                                alert(`${char} total (${total}) must be between ${charData.min} and ${charData.max} for ${selectedSpecies}.`);
                                allValid = false;
                                return;
                            }
                            
                            wizardData.characteristics[char] = {
                                base: charData.base,
                                roll: roll,
                                total: total,
                                min: charData.min,
                                max: charData.max
                            };
                        }
                    });
                    return allValid;
                    
                case 2:
                    // Validate extra points distribution
                    if (wizardData.usedExtraPoints !== speciesInfo.extraPoints) {
                        alert(`Please distribute all ${speciesInfo.extraPoints} extra points between Fate and Resilience.`);
                        return false;
                    }
                    return true;
                    
                case 3:
                    // Check if 3 skills are selected
                    if (wizardData.skills.step3.length !== 3) {
                        alert('Please select exactly 3 skills for +5 advances.');
                        return false;
                    }
                    return true;
                    
                case 4:
                    // Check if 3 skills are selected
                    if (wizardData.skills.step4.length !== 3) {
                        alert('Please select exactly 3 skills for +3 advances.');
                        return false;
                    }
                    return true;
                    
                case 5:
                    // Check talent selections
                    if (speciesInfo.talentChoices) {
                        // Check that all talent choices are made
                        for (let i = 0; i < speciesInfo.talentChoices.length; i++) {
                            const choice = speciesInfo.talentChoices[i];
                            const selection = wizardData.talents.choices[i];
                            
                            if (choice.multiple) {
                                // Multiple selection validation
                                if (!selection || !Array.isArray(selection) || selection.length !== choice.count) {
                                    alert(`Please select exactly ${choice.count} talents for choice ${i + 1}.`);
                                    return false;
                                }
                                
                                // Validate customizations for talents that need them
                                for (const talentChoice of selection) {
                                    const talent = typeof talentChoice === 'string' ? talentChoice : talentChoice.talent;
                                    if (talent.includes('(any one)') || talent.includes('(choose one)')) {
                                        const customization = typeof talentChoice === 'object' ? talentChoice.customization : '';
                                        if (!customization || customization.trim() === '') {
                                            alert(`Please specify the customization for "${talent}".`);
                                            return false;
                                        }
                                    }
                                }
                            } else {
                                // Single selection validation
                                if (!selection) {
                                    alert(`Please make a selection for talent choice ${i + 1}.`);
                                    return false;
                                }
                                
                                // Validate customization for talent that needs it
                                const talent = typeof selection === 'string' ? selection : selection.talent;
                                if (talent.includes('(any one)') || talent.includes('(choose one)')) {
                                    const customization = typeof selection === 'object' ? selection.customization : '';
                                    if (!customization || customization.trim() === '') {
                                        alert(`Please specify the customization for "${talent}".`);
                                        return false;
                                    }
                                }
                            }
                        }
                    } else {
                        // Fallback for old system
                        if (wizardData.talents.selected.length !== 1) {
                            alert('Please select exactly 1 additional talent.');
                            return false;
                        }
                    }
                    return true;
                    
                default:
                    return true;
            }
        }

        function initializeStep3() {
            const speciesInfo = speciesData[selectedSpecies];
            const skillsList = document.getElementById('species-skills-list-1');
            skillsList.innerHTML = '';

            speciesInfo.skills.forEach(skill => {
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-checkbox-item';
                skillDiv.innerHTML = `
                    <input type="checkbox" id="skill3-${skill}" value="${skill}" onchange="updateSkillSelection(3, this)">
                    <label for="skill3-${skill}">${skill}</label>
                `;
                skillsList.appendChild(skillDiv);
            });

            document.getElementById('remaining-skill-points-1').textContent = 3;
        }

        function initializeStep4() {
            const speciesInfo = speciesData[selectedSpecies];
            const skillsList = document.getElementById('species-skills-list-2');
            skillsList.innerHTML = '';

            // Only show skills not selected in step 3
            const availableSkills = speciesInfo.skills.filter(skill => 
                !wizardData.skills.step3.includes(skill)
            );

            availableSkills.forEach(skill => {
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-checkbox-item';
                skillDiv.innerHTML = `
                    <input type="checkbox" id="skill4-${skill}" value="${skill}" onchange="updateSkillSelection(4, this)">
                    <label for="skill4-${skill}">${skill}</label>
                `;
                skillsList.appendChild(skillDiv);
            });

            document.getElementById('remaining-skill-points-2').textContent = 3;
        }

        function updateSkillSelection(step, checkbox) {
            const maxSelections = 3; // Both steps now select 3 skills each
            const currentSelections = step === 3 ? wizardData.skills.step3 : wizardData.skills.step4;
            const remainingSpan = step === 3 ? 
                document.getElementById('remaining-skill-points-1') : 
                document.getElementById('remaining-skill-points-2');

            if (checkbox.checked) {
                if (currentSelections.length >= maxSelections) {
                    checkbox.checked = false;
                    alert(`You can only select ${maxSelections} skills in this step.`);
                    return;
                }
                currentSelections.push(checkbox.value);
            } else {
                const index = currentSelections.indexOf(checkbox.value);
                if (index > -1) {
                    currentSelections.splice(index, 1);
                }
            }

            remainingSpan.textContent = maxSelections - currentSelections.length;
        }

        function initializeStep5() {
            const speciesInfo = speciesData[selectedSpecies];
            
            // Handle fixed talents (automatic)
            if (speciesInfo.fixedTalents) {
                wizardData.talents.fixed = [...speciesInfo.fixedTalents];
                const randomTalentsList = document.getElementById('random-talents-list');
                randomTalentsList.innerHTML = wizardData.talents.fixed.map(talent => 
                    `<span style="display: inline-block; background: #d4e6f1; padding: 5px 10px; margin: 2px; border-radius: 3px;">${talent}</span>`
                ).join('');
            }

            const talentsList = document.getElementById('species-talents-list');
            talentsList.innerHTML = '';

            // Handle talent choices
            if (speciesInfo.talentChoices) {
                speciesInfo.talentChoices.forEach((choice, choiceIndex) => {
                    const choiceDiv = document.createElement('div');
                    choiceDiv.style.marginBottom = '20px';
                    choiceDiv.style.padding = '15px';
                    choiceDiv.style.border = '1px solid #d0c5a0';
                    choiceDiv.style.borderRadius = '5px';
                    choiceDiv.style.background = '#f9f7f1';
                    
                    let choiceHTML = `<h5 style="color: #3e2f1f; margin-bottom: 10px;">${choice.description}</h5>`;
                    
                    choice.options.forEach((talent, talentIndex) => {
                        const needsCustomization = talent.includes('(any one)') || talent.includes('(choose one)');
                        const baseTalentName = needsCustomization ? talent.replace(/\s*\(.+\)/, '') : talent;
                        const inputId = `talent-${choiceIndex}-${talentIndex}-custom`;
                        
                        if (choice.multiple) {
                            choiceHTML += `
                                <div style="margin-bottom: 8px;">
                                    <label style="display: block; cursor: pointer;">
                                        <input type="checkbox" name="talent-choice-${choiceIndex}" value="${talent}" onchange="updateMultipleTalentChoiceSelection(${choiceIndex}, this)" style="margin-right: 8px;">
                                        ${talent}
                                    </label>
                                    ${needsCustomization ? `
                                        <div style="margin-left: 24px; margin-top: 5px;">
                                            <input type="text" id="${inputId}" placeholder="Specify ${baseTalentName}..." style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; width: 200px;" disabled oninput="updateTalentCustomization(${choiceIndex}, ${talentIndex}, this.value)">
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        } else {
                            choiceHTML += `
                                <div style="margin-bottom: 8px;">
                                    <label style="display: block; cursor: pointer;">
                                        <input type="radio" name="talent-choice-${choiceIndex}" value="${talent}" onchange="updateTalentChoiceSelection(${choiceIndex}, this)" style="margin-right: 8px;">
                                        ${talent}
                                    </label>
                                    ${needsCustomization ? `
                                        <div style="margin-left: 24px; margin-top: 5px;">
                                            <input type="text" id="${inputId}" placeholder="Specify ${baseTalentName}..." style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; width: 200px;" disabled oninput="updateTalentCustomization(${choiceIndex}, ${talentIndex}, this.value)">
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }
                    });
                    
                    choiceDiv.innerHTML = choiceHTML;
                    talentsList.appendChild(choiceDiv);
                });
                
                // Initialize choices array
                wizardData.talents.choices = speciesInfo.talentChoices.map(choice => 
                    choice.multiple ? [] : null
                );
            } else {
                // Fallback for species that still use the old single-choice system
                const selectableTalents = speciesInfo.talents.filter(talent => 
                    !wizardData.talents.fixed.includes(talent)
                );

                selectableTalents.forEach(talent => {
                    const talentDiv = document.createElement('div');
                    talentDiv.className = 'talent-checkbox-item';
                    talentDiv.innerHTML = `
                        <input type="radio" name="selected-talent" id="talent-${talent}" value="${talent}" onchange="updateTalentSelection(this)">
                        <label for="talent-${talent}">${talent}</label>
                    `;
                    talentsList.appendChild(talentDiv);
                });
            }
        }

        function updateTalentSelection(radio) {
            wizardData.talents.selected = radio.checked ? [radio.value] : [];
        }

        function updateTalentChoiceSelection(choiceIndex, radio) {
            if (radio.checked) {
                // Find the talent index to get the customization input
                const choiceGroup = document.querySelectorAll(`input[name="talent-choice-${choiceIndex}"]`);
                let talentIndex = -1;
                choiceGroup.forEach((input, index) => {
                    if (input === radio) talentIndex = index;
                });
                
                // Enable/disable customization inputs
                choiceGroup.forEach((input, index) => {
                    const customInput = document.getElementById(`talent-${choiceIndex}-${index}-custom`);
                    if (customInput) {
                        if (index === talentIndex) {
                            customInput.disabled = false;
                            customInput.focus();
                        } else {
                            customInput.disabled = true;
                            customInput.value = '';
                        }
                    }
                });
                
                wizardData.talents.choices[choiceIndex] = {
                    talent: radio.value,
                    customization: ''
                };
            }
        }

        function updateTalentCustomization(choiceIndex, talentIndex, customization) {
            const choice = wizardData.talents.choices[choiceIndex];
            
            if (Array.isArray(choice)) {
                // Multiple choice - find the talent and update its customization
                const talent = choice.find(t => {
                    const choiceGroup = document.querySelectorAll(`input[name="talent-choice-${choiceIndex}"]`);
                    const talentValue = choiceGroup[talentIndex]?.value;
                    return (typeof t === 'string' ? t : t.talent) === talentValue;
                });
                
                if (talent && typeof talent === 'object') {
                    talent.customization = customization;
                }
            } else if (choice && typeof choice === 'object') {
                // Single choice - update the customization
                choice.customization = customization;
            }
        }

        function updateMultipleTalentChoiceSelection(choiceIndex, checkbox) {
            if (!wizardData.talents.choices[choiceIndex]) {
                wizardData.talents.choices[choiceIndex] = [];
            }
            
            // Find the talent index to get the customization input
            const choiceGroup = document.querySelectorAll(`input[name="talent-choice-${choiceIndex}"]`);
            let talentIndex = -1;
            choiceGroup.forEach((input, index) => {
                if (input === checkbox) talentIndex = index;
            });
            
            const customInput = document.getElementById(`talent-${choiceIndex}-${talentIndex}-custom`);
            
            if (checkbox.checked) {
                // Enable customization input if needed
                if (customInput) {
                    customInput.disabled = false;
                }
                
                // Add talent object with customization support
                const existingIndex = wizardData.talents.choices[choiceIndex].findIndex(t => 
                    (typeof t === 'string' ? t : t.talent) === checkbox.value
                );
                
                if (existingIndex === -1) {
                    wizardData.talents.choices[choiceIndex].push({
                        talent: checkbox.value,
                        customization: ''
                    });
                }
            } else {
                // Disable and clear customization input
                if (customInput) {
                    customInput.disabled = true;
                    customInput.value = '';
                }
                
                // Remove talent
                const index = wizardData.talents.choices[choiceIndex].findIndex(t => 
                    (typeof t === 'string' ? t : t.talent) === checkbox.value
                );
                if (index > -1) {
                    wizardData.talents.choices[choiceIndex].splice(index, 1);
                }
            }
        }

        function initializeStep6() {
            const speciesInfo = speciesData[selectedSpecies];
            const summaryDiv = document.getElementById('creation-summary');
            
            let summaryHTML = `
                <h4 style="color: #3e2f1f; margin-bottom: 15px;">${selectedSpecies} Character Summary</h4>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f;">Characteristics:</h5>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0;">
            `;

            Object.keys(wizardData.characteristics).forEach(char => {
                const charData = wizardData.characteristics[char];
                const rollText = charData.roll ? ` (rolled ${charData.roll})` : '';
                summaryHTML += `
                    <div style="text-align: center; padding: 8px; background: white; border: 1px solid #d0c5a0;">
                        <strong>${char}</strong><br>
                        ${charData.base}${rollText} = <strong>${charData.total}</strong>
                    </div>
                `;
            });

            summaryHTML += `
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f;">Wounds, Fate, and Resilience:</h5>
                    <p><strong>Wounds:</strong> ${wizardData.wounds}</p>
                    <p><strong>Fate:</strong> ${wizardData.fate.base} + ${wizardData.fate.extra} = ${wizardData.fate.total}</p>
                    <p><strong>Resilience:</strong> ${wizardData.resilience.base} + ${wizardData.resilience.extra} = ${wizardData.resilience.total}</p>
                    <p><strong>Movement:</strong> ${wizardData.movement}</p>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f;">Skills with +5 Advances (3 selected):</h5>
                    <p>${wizardData.skills.step3.join(', ')}</p>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f;">Skills with +3 Advances (3 selected):</h5>
                    <p>${wizardData.skills.step4.join(', ')}</p>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f;">Talents:</h5>
                    <p><strong>Fixed Talents:</strong> ${wizardData.talents.fixed.join(', ')}</p>
                    ${wizardData.talents.choices.length > 0 ? 
                        (() => {
                            let chosenTalents = [];
                            wizardData.talents.choices.forEach(choice => {
                                if (Array.isArray(choice)) {
                                    chosenTalents.push(...choice);
                                } else if (choice) {
                                    chosenTalents.push(choice);
                                }
                            });
                            return chosenTalents.length > 0 ? 
                                `<p><strong>Chosen Talents:</strong> ${chosenTalents.join(', ')}</p>` : '';
                        })() : 
                        (wizardData.talents.selected.length > 0 ? 
                            `<p><strong>Selected Talent:</strong> ${wizardData.talents.selected.join(', ')}</p>` : '')}
                </div>
            `;

            summaryDiv.innerHTML = summaryHTML;
        }

        function updateWizardDisplay() {
            // Update step indicators
            for (let i = 1; i <= 6; i++) {
                const indicator = document.getElementById(`step-indicator-${i}`);
                indicator.className = 'wizard-step';
                if (i < currentWizardStep) {
                    indicator.classList.add('completed');
                } else if (i === currentWizardStep) {
                    indicator.classList.add('active');
                }
            }

            // Show/hide wizard content
            for (let i = 1; i <= 6; i++) {
                const content = document.getElementById(`wizard-step-${i}`);
                content.style.display = i === currentWizardStep ? 'block' : 'none';
            }

            // Update navigation buttons
            const prevBtn = document.getElementById('wizard-prev-btn');
            const nextBtn = document.getElementById('wizard-next-btn');
            const applyBtn = document.getElementById('wizard-apply-btn');

            prevBtn.disabled = currentWizardStep === 1;
            nextBtn.style.display = currentWizardStep === 6 ? 'none' : 'inline-block';
            applyBtn.style.display = currentWizardStep === 6 ? 'inline-block' : 'none';
        }

        // Helper function to directly add a skill to the character
        function addSkillDirectly(skillName, advances = 0) {
            // Parse skill name and specialization
            let baseName, specialization = '';
            const match = skillName.match(/^(.+?)\s*\((.+)\)$/);
            
            if (match) {
                baseName = match[1].trim();
                specialization = match[2].trim();
            } else {
                baseName = skillName;
            }

            // Find the base skill in allSkills
            const baseSkill = allSkills.find(s => s.name === baseName);
            if (!baseSkill) {
                console.warn(`Base skill "${baseName}" not found in allSkills`);
                return;
            }

            // Create skill key and display name
            const skillKey = skillName; // Use full name as key (e.g., "Melee (Basic)")
            const displayName = skillName;

            // For basic ungrouped skills, they should already exist in characterSkills
            // Just add advances to them rather than creating duplicates
            if (baseSkill.type === 'Basic' && !baseSkill.grouped && !specialization) {
                // This is a basic skill like "Charm" - just add advances
                if (!characterSkills[skillKey]) {
                    characterSkills[skillKey] = { career: false, advances: 0, notes: '' };
                }
                characterSkills[skillKey].advances += advances;
                displaySkills();
                return;
            }

            // Check if this exact skill already exists in addedSkills
            if (addedSkills.find(s => s.key === skillKey)) {
                // If it exists, just add advances
                if (characterSkills[skillKey]) {
                    characterSkills[skillKey].advances += advances;
                }
                displaySkills();
                return;
            }

            // Add the skill to addedSkills (for specialized/grouped skills)
            addedSkills.push({
                key: skillKey,
                name: baseName,
                displayName: displayName,
                characteristic: baseSkill.characteristic,
                type: baseSkill.type,
                specialisation: specialization
            });

            // Initialize skill data with advances
            characterSkills[skillKey] = { career: false, advances: advances, notes: '' };

            // Refresh the skills display
            displaySkills();
        }

        // Helper function to directly add a talent to the character
        function addTalentDirectly(talentName) {
            // Parse talent name and customization
            let baseName, customisation = '';
            const match = talentName.match(/^(.+?)\s*\((.+)\)$/);
            
            if (match) {
                baseName = match[1].trim();
                const customPart = match[2].trim();
                
                // Handle specific customizations
                if (customPart.toLowerCase().includes('any one') || customPart.toLowerCase().includes('choose one')) {
                    // For "any one" talents, use a default or prompt for specification
                    if (baseName === 'Acute Sense') {
                        customisation = 'Sight'; // Default to sight for character creation
                    } else if (baseName === 'Craftsman') {
                        customisation = 'Metalworking'; // Default craft
                    } else if (baseName === 'Resistance') {
                        customisation = 'Disease'; // Default resistance
                    } else {
                        customisation = customPart; // Use the original text for now
                    }
                } else {
                    customisation = customPart;
                }
            } else {
                baseName = talentName;
            }

            // Find the talent in srdTalents using base name
            const baseTalent = srdTalents.find(t => t.name === baseName);
            if (!baseTalent) {
                console.warn(`Talent "${baseName}" not found in srdTalents`);
                return;
            }

            // Create display name
            const displayName = customisation ? `${baseName} (${customisation})` : baseName;

            // Check if talent already exists (by name and customisation)
            const existingTalent = talents.find(t => t.name === baseName && (t.customisation || '') === customisation);
            if (existingTalent) {
                // If it's a multiple talent, increase the times taken
                if (baseTalent.max && baseTalent.max !== "1") {
                    existingTalent.timesTaken = Math.min((existingTalent.timesTaken || 1) + 1, parseInt(baseTalent.max) || 1);
                }
                return;
            }

            // Add the talent with proper structure
            talents.push({
                name: baseName,
                displayName: displayName,
                max: baseTalent.max || "1",
                tests: baseTalent.tests || '',
                description: baseTalent.description || '',
                timesTaken: 1,
                customisation: customisation,
                notes: ''
            });

            // Refresh the talents display
            displayTalents();
        }

        function applySpeciesCreation() {
            const speciesInfo = speciesData[selectedSpecies];
            
            try {
                // Apply species selection
                const speciesField = document.getElementById('species');
                if (speciesField) {
                    speciesField.value = selectedSpecies;
                }

                // Apply characteristics to initial values
                Object.keys(wizardData.characteristics).forEach(char => {
                    const charData = wizardData.characteristics[char];
                    const initialField = document.getElementById(`${char.toLowerCase()}-initial`);
                    if (initialField) {
                        initialField.value = charData.total;
                        // Trigger any update functions
                        const event = new Event('input', { bubbles: true });
                        initialField.dispatchEvent(event);
                    }
                });

                // Apply wounds
                const woundsField = document.getElementById('wounds-max');
                if (woundsField) {
                    woundsField.value = wizardData.wounds;
                }

                // Apply fate, resilience, and movement using wizard data
                const fateField = document.getElementById('fate');
                const resilienceField = document.getElementById('resilience');
                const movementField = document.getElementById('movement');

                if (fateField) fateField.value = wizardData.fate.total;
                if (resilienceField) resilienceField.value = wizardData.resilience.total;
                if (movementField) movementField.value = wizardData.movement;

                // Apply skills (add them to existing skills)
                const allSelectedSkills = [...wizardData.skills.step3, ...wizardData.skills.step4];
                allSelectedSkills.forEach(skillName => {
                    const advances = wizardData.skills.step3.includes(skillName) ? 5 : 3;
                    addSkillDirectly(skillName, advances);
                });

                // Apply talents
                const allTalents = [...wizardData.talents.fixed];
                wizardData.talents.choices.forEach((choice, choiceIndex) => {
                    if (Array.isArray(choice)) {
                        choice.forEach((talentChoice, talentIndex) => {
                            let talentName, customization = '';
                            
                            if (typeof talentChoice === 'string') {
                                talentName = talentChoice;
                            } else {
                                talentName = talentChoice.talent;
                                customization = talentChoice.customization;
                            }
                            
                            // Get customization from input field if needed
                            if (!customization && (talentName.includes('(any one)') || talentName.includes('(choose one)'))) {
                                const choiceGroup = document.querySelectorAll(`input[name="talent-choice-${choiceIndex}"]`);
                                let inputIndex = -1;
                                choiceGroup.forEach((input, index) => {
                                    if (input.value === talentName && input.checked) {
                                        inputIndex = index;
                                    }
                                });
                                
                                if (inputIndex >= 0) {
                                    const customInput = document.getElementById(`talent-${choiceIndex}-${inputIndex}-custom`);
                                    if (customInput) {
                                        customization = customInput.value.trim();
                                    }
                                }
                            }
                            
                            allTalents.push(customization ? `${talentName.replace(/\s*\(.+\)/, '')} (${customization})` : talentName);
                        });
                    } else if (choice) {
                        let talentName, customization = '';
                        
                        if (typeof choice === 'string') {
                            talentName = choice;
                        } else {
                            talentName = choice.talent;
                            customization = choice.customization;
                        }
                        
                        // Get customization from input field if needed
                        if (!customization && (talentName.includes('(any one)') || talentName.includes('(choose one)'))) {
                            const choiceGroup = document.querySelectorAll(`input[name="talent-choice-${choiceIndex}"]`);
                            let inputIndex = -1;
                            choiceGroup.forEach((input, index) => {
                                if (input.value === talentName && input.checked) {
                                    inputIndex = index;
                                }
                            });
                            
                            if (inputIndex >= 0) {
                                const customInput = document.getElementById(`talent-${choiceIndex}-${inputIndex}-custom`);
                                if (customInput) {
                                    customization = customInput.value.trim();
                                }
                            }
                        }
                        
                        allTalents.push(customization ? `${talentName.replace(/\s*\(.+\)/, '')} (${customization})` : talentName);
                    }
                });
                
                allTalents.forEach(talentName => {
                    addTalentDirectly(talentName);
                });

                // Close wizard and show success message
                closeSpeciesWizard();
                alert(`${selectedSpecies} character creation completed successfully!`);
                
            } catch (error) {
                console.error('Error applying species creation:', error);
                alert('There was an error applying the character creation. Please try again.');
            }
        }

        function closeSpeciesWizard() {
            document.getElementById('species-wizard-modal').style.display = 'none';
            
            // Reset wizard state
            currentWizardStep = 1;
            selectedSpecies = '';
            wizardData = {
                characteristics: {},
                wounds: 0,
                fate: { base: 0, extra: 0, total: 0 },
                resilience: { base: 0, extra: 0, total: 0 },
                movement: 0,
                skills: { step3: [], step4: [] },
                talents: { fixed: [], choices: [], selected: [] },
                extraPoints: 0,
                usedExtraPoints: 0
            };
        }

        // Manual species wizard trigger
        function manualOpenSpeciesWizard() {
            const speciesSelect = document.getElementById('species');
            const selectedValue = speciesSelect.value;
            
            if (!selectedValue) {
                alert('Please select a species first before opening the wizard.');
                return;
            }
            
            if (!speciesData[selectedValue]) {
                alert('Species data not found. Please refresh the page and try again.');
                return;
            }
            
            // Ask for confirmation if character has data
            const hasData = checkCharacterHasData();
            if (hasData) {
                const confirmed = confirm('This will overwrite existing character data. Are you sure you want to proceed with the species creation wizard?');
                if (!confirmed) {
                    return;
                }
            }
            
            openSpeciesWizard(selectedValue);
        }

        // Check if character has significant data
        function checkCharacterHasData() {
            const characterName = document.getElementById('character-name').value;
            const wsValue = document.getElementById('ws-current').value;
            const bsValue = document.getElementById('bs-current').value;
            
            // Character has data if:
            // - Has a name, or
            // - Any characteristic is not default (20), or
            // - Has any skills with advances
            return characterName || 
                   (wsValue && wsValue != 20) || 
                   (bsValue && bsValue != 20);
        }

        // Add species dropdown change detection
        function initializeSpeciesDropdown() {
            const speciesSelect = document.getElementById('species');
            if (speciesSelect) {
                speciesSelect.addEventListener('change', function() {
                    const selectedValue = this.value;
                    if (selectedValue && speciesData[selectedValue]) {
                        // Check if character is mostly empty (new character)
                        const hasData = checkCharacterHasData();
                        
                        if (!hasData) {
                            // Auto-open wizard for new character
                            openSpeciesWizard(selectedValue);
                        } else {
                            // Ask if they want to open the wizard for existing character
                            const shouldOpen = confirm('Would you like to open the Species Creation Wizard? This will overwrite existing character data.');
                            if (shouldOpen) {
                                openSpeciesWizard(selectedValue);
                            }
                        }
                    }
                });
            }
        }

        // Initialize species dropdown on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeSpeciesDropdown();
        });

        // =============== CHARACTER SETUP WIZARD FUNCTIONS ===============
        
        let setupCurrentStep = 0;
        const setupSteps = ['species-selection', 'characteristics', 'skills', 'talents', 'class', 'trappings', 'career'];
        let setupWizardData = {};
        let selectedSpeciesForSetup = '';
        
        // Start Character Setup Wizard
        function startCharacterSetup() {
            document.getElementById('character-setup-modal').style.display = 'block';
            document.getElementById('setup-warning').style.display = 'block';
            document.getElementById('setup-steps').style.display = 'none';
            setupCurrentStep = 0;
            setupWizardData = {};
        }
        
        // Close Setup Wizard
        function closeSetupWizard() {
            document.getElementById('character-setup-modal').style.display = 'none';
        }
        
        // Confirm data reset and start wizard
        function confirmDataReset() {
            // Clear all character data
            clearAllCharacterData();
            
            // Hide warning, show wizard steps
            document.getElementById('setup-warning').style.display = 'none';
            document.getElementById('setup-steps').style.display = 'block';
            
            // Start with first step
            setupCurrentStep = 0;
            initializeSetupStep(0);
            updateSetupWizardDisplay();
        }
        
        // Clear all character data
        function clearAllCharacterData() {
            // Clear basic info
            document.getElementById('character-name').value = '';
            document.getElementById('species').value = '';
            document.getElementById('class').value = '';
            document.getElementById('player').value = '';
            
            // Reset global tier to 1
            document.getElementById('global-tier').value = '1';
            currentTier = 1;
            
            // Clear characteristics
            const characteristics = ['ws', 'bs', 's', 't', 'i', 'agi', 'dex', 'int', 'wp', 'fel'];
            characteristics.forEach(char => {
                const initialField = document.getElementById(`${char}-initial`);
                const advancesField = document.getElementById(`${char}-advances`);
                const currentField = document.getElementById(`${char}-current`);
                if (initialField) initialField.value = '';
                if (advancesField) advancesField.value = '';
                if (currentField) currentField.value = '';
            });
            
            // Clear career
            document.getElementById('career-select').value = '';
            currentCareer = null;
            clearCareerDisplay();
            clearCharacteristicLimits();
            
            // Clear XP
            document.getElementById('xp-total').value = '';
            document.getElementById('xp-spent').value = '';
            window.updateXPDisplay();
            
            console.log('Character data cleared for setup wizard');
        }
        
        // Show specific setup step
        function showSetupStep(stepIndex) {
            setupCurrentStep = stepIndex;
            updateSetupWizardDisplay();
            initializeSetupStep(stepIndex);
        }
        
        // Update the wizard display - following species wizard pattern
        function updateSetupWizardDisplay() {
            // Hide all step contents
            for (let i = 0; i <= 6; i++) {
                const stepElement = document.getElementById(`setup-wizard-step-${i}`);
                if (stepElement) {
                    stepElement.style.display = 'none';
                }
            }
            
            // Show current step
            const currentStepElement = document.getElementById(`setup-wizard-step-${setupCurrentStep}`);
            if (currentStepElement) {
                currentStepElement.style.display = 'block';
            }
            
            // Update step indicators
            for (let i = 0; i <= 6; i++) {
                const indicator = document.getElementById(`setup-step-indicator-${i}`);
                if (indicator) {
                    indicator.classList.remove('active', 'completed');
                    if (i < setupCurrentStep) {
                        indicator.classList.add('completed');
                    } else if (i === setupCurrentStep) {
                        indicator.classList.add('active');
                    }
                }
            }
            
            // Update navigation buttons
            const prevBtn = document.getElementById('setup-wizard-prev-btn');
            const nextBtn = document.getElementById('setup-wizard-next-btn');
            
            if (prevBtn) {
                prevBtn.disabled = setupCurrentStep === 0;
            }
            
            if (nextBtn) {
                nextBtn.textContent = setupCurrentStep === 6 ? 'Finish Character' : 'Next â†’';
            }
        }
        
        // Navigation functions
        function nextSetupStep() {
            if (validateCurrentSetupStep()) {
                if (setupCurrentStep < 6) {
                    setupCurrentStep++;
                    initializeSetupStep(setupCurrentStep);
                    updateSetupWizardDisplay();
                } else {
                    // Finish wizard
                    finishSetup();
                }
            }
        }
        
        function previousSetupStep() {
            if (setupCurrentStep > 0) {
                setupCurrentStep--;
                updateSetupWizardDisplay();
            }
        }
        
        // Handle species selection in setup wizard
        function handleSetupSpeciesSelection() {
            const species = document.getElementById('setup-species-select').value;
            const speciesInfo = document.getElementById('setup-species-info');
            
            if (species && speciesData[species]) {
                selectedSpeciesForSetup = species;
                setupWizardData.species = species;
                
                // Initialize wizard data like the species wizard
                const speciesDataObj = speciesData[species];
                setupWizardData = {
                    species: species,
                    characteristics: {},
                    wounds: 0,
                    fate: { base: speciesDataObj.baseFate, extra: 0, total: speciesDataObj.baseFate },
                    resilience: { base: speciesDataObj.baseResilience, extra: 0, total: speciesDataObj.baseResilience },
                    movement: speciesDataObj.movement,
                    skills: { step3: [], step4: [] },
                    talents: { fixed: speciesDataObj.fixedTalents || [], choices: [], selected: [] },
                    extraPoints: speciesDataObj.extraPoints,
                    usedExtraPoints: 0,
                    class: '',
                    career: '',
                    trappings: []
                };
                
                // Show species info
                speciesInfo.style.display = 'block';
                speciesInfo.innerHTML = `
                    <h4 style="color: #3e2f1f; margin-bottom: 10px;">${species}</h4>
                    <p><strong>Fate:</strong> ${speciesDataObj.baseFate} | <strong>Resilience:</strong> ${speciesDataObj.baseResilience} | <strong>Movement:</strong> ${speciesDataObj.movement}</p>
                    <p><strong>Species Skills:</strong> ${speciesDataObj.skills.join(', ')}</p>
                    <p><strong>Fixed Talents:</strong> ${speciesDataObj.fixedTalents ? speciesDataObj.fixedTalents.join(', ') : 'None'}</p>
                `;
            } else {
                speciesInfo.style.display = 'none';
                selectedSpeciesForSetup = '';
                setupWizardData.species = '';
            }
        }
        
        // Initialize each step when entering it
        function initializeSetupStep(stepIndex) {
            const speciesInfo = setupWizardData.species ? speciesData[setupWizardData.species] : null;
            
            switch (stepIndex) {
                case 1: // Characteristics
                    if (speciesInfo) {
                        initializeSetupCharacteristics(speciesInfo);
                    }
                    break;
                case 2: // Skills
                    if (speciesInfo) {
                        initializeSetupSkills(speciesInfo);
                    }
                    break;
                case 3: // Talents
                    if (speciesInfo) {
                        initializeSetupTalents(speciesInfo);
                    }
                    break;
                case 4: // Class
                    initializeSetupClass();
                    break;
                case 5: // Trappings
                    initializeSetupTrappings();
                    break;
                case 6: // Career
                    initializeSetupCareer();
                    break;
            }
        }
        
        // Validate current step
        function validateCurrentSetupStep() {
            switch (setupCurrentStep) {
                case 0: // Species selection
                    return validateSetupSpeciesStep();
                case 1: // Characteristics
                    return validateSetupCharacteristicsStep();
                case 2: // Skills
                    return validateSetupSkillsStep();
                case 3: // Talents
                    return validateSetupTalentsStep();
                case 4: // Class
                    return validateSetupClassStep();
                case 5: // Trappings
                    return true; // Trappings are optional
                case 6: // Career
                    return validateSetupCareerStep();
                default:
                    return true;
            }
        }
        
        // Add the missing validation functions
        function validateSetupSpeciesStep() {
            const species = document.getElementById('setup-species-select').value;
            if (!species) {
                alert('Please select a species.');
                return false;
            }
            return true;
        }
        
        function validateSetupCharacteristicsStep() {
            // Validate that all characteristics have been set
            if (!setupWizardData.characteristics || Object.keys(setupWizardData.characteristics).length < 10) {
                alert('Please enter all characteristic values before proceeding.');
                return false;
            }
            return true;
        }
        
        function validateSetupSkillsStep() {
            // Validate skills selection
            if (!setupWizardData.skills || 
                (setupWizardData.skills.step3.length < 3 || setupWizardData.skills.step4.length < 3)) {
                alert('Please complete skill selections before proceeding.');
                return false;
            }
            return true;
        }
        
        function validateSetupTalentsStep() {
            // Validate talent selections are complete
            return true; // For now, we'll implement this later
        }
        
        function validateSetupClassStep() {
            if (!setupWizardData.class) {
                alert('Please select a class.');
                return false;
            }
            return true;
        }
        
        function validateSetupCareerStep() {
            if (!setupWizardData.career) {
                alert('Please select a career.');
                return false;
            }
            return true;
        }
        
        // Initialize characteristics step for setup wizard
        function initializeSetupCharacteristics(speciesInfo) {
            // Populate species details
            const speciesDetails = document.getElementById('setup-species-details');
            speciesDetails.innerHTML = `
                <h4 style="color: #3e2f1f; margin: 0 0 10px 0;">${setupWizardData.species}</h4>
                <p style="margin: 0; color: #666; font-size: 14px;">${speciesInfo.description || 'No description available.'}</p>
            `;

            // Create characteristics grid dynamically
            const characteristicsGrid = document.getElementById('setup-characteristics-grid');
            characteristicsGrid.innerHTML = '';
            
            Object.keys(speciesInfo.characteristics).forEach(char => {
                const charData = speciesInfo.characteristics[char];
                const charDiv = document.createElement('div');
                charDiv.className = 'char-advance-group';
                charDiv.innerHTML = `
                    <label>${char}</label>
                    <div style="display: flex; align-items: center; gap: 5px; flex-direction: column;">
                        <div style="font-size: 11px; color: #666;">
                            Range: <span id="setup-char-${char.toLowerCase()}-range">${charData.min}-${charData.max}</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span id="setup-char-${char.toLowerCase()}-base">${charData.base}</span>
                            <span>+</span>
                            <input type="number" id="setup-char-${char.toLowerCase()}-roll" min="2" max="20" value="0" style="width: 50px; text-align: center;" placeholder="2-20" oninput="updateSetupCharacteristicTotal('${char.toLowerCase()}')">
                            <span>=</span>
                            <strong id="setup-char-${char.toLowerCase()}-total">${charData.base}</strong>
                        </div>
                    </div>
                `;
                characteristicsGrid.appendChild(charDiv);
                
                // Store in wizard data
                setupWizardData.characteristics[char] = {
                    base: charData.base,
                    roll: 0,
                    total: charData.base,
                    min: charData.min,
                    max: charData.max
                };
            });
        }

        // Update characteristic total in setup wizard
        function updateSetupCharacteristicTotal(char) {
            const speciesInfo = speciesData[setupWizardData.species];
            
            // Find the correct characteristic key (handle case sensitivity)
            const charKey = Object.keys(speciesInfo.characteristics).find(key => 
                key.toLowerCase() === char.toLowerCase()
            );
            
            if (charKey) {
                const charData = speciesInfo.characteristics[charKey];
                const rollInput = document.getElementById(`setup-char-${char.toLowerCase()}-roll`);
                const rollValue = parseInt(rollInput.value) || 0;
                const baseValue = charData.base;
                const total = baseValue + rollValue;
                
                // Update total display
                document.getElementById(`setup-char-${char.toLowerCase()}-total`).textContent = total;
                
                // Update wizard data
                setupWizardData.characteristics[charKey] = {
                    base: baseValue,
                    roll: rollValue,
                    total: total,
                    min: charData.min,
                    max: charData.max
                };
                
                // Check if total is within range and update styling
                if (total < charData.min || total > charData.max) {
                    rollInput.style.borderColor = '#cc0000';
                    rollInput.style.backgroundColor = '#ffe6e6';
                } else {
                    rollInput.style.borderColor = '#8b7355';
                    rollInput.style.backgroundColor = 'white';
                }
            }
        }
        
        function initializeSetupSkills(speciesInfo) {
            // This will be implemented to replicate species wizard skills steps
            console.log('Initializing skills step');
        }
        
        function initializeSetupTalents(speciesInfo) {
            // This will be implemented to replicate species wizard talents step
            console.log('Initializing talents step');
        }
        
        function initializeSetupClass() {
            // Show class selection
            const content = document.getElementById('setup-class-content');
            content.innerHTML = `
                <div style="margin: 20px 0;">
                    <select id="setup-class-select" onchange="handleSetupClassSelection()" style="padding: 10px; font-size: 14px; width: 100%; border: 1px solid #8b7355;">
                        <option value="">Select Class</option>
                        <option value="Academic">Academic</option>
                        <option value="Burgher">Burgher</option>
                        <option value="Courtier">Courtier</option>
                        <option value="Peasant">Peasant</option>
                        <option value="Ranger">Ranger</option>
                        <option value="Riverfolk">Riverfolk</option>
                        <option value="Rogue">Rogue</option>
                        <option value="Warrior">Warrior</option>
                    </select>
                </div>
            `;
        }
        
        function handleSetupClassSelection() {
            const classValue = document.getElementById('setup-class-select').value;
            setupWizardData.class = classValue;
        }
        
        function initializeSetupTrappings() {
            // Show trappings for selected class
            console.log('Initializing trappings step');
        }
        
        function initializeSetupCareer() {
            // Show career selection based on class
            const content = document.getElementById('setup-career-content');
            const classValue = setupWizardData.class;
            let careerOptions = '';
            
            // Build career options based on selected class
            if (classValue && careersData && careersData.careers) {
                const filteredCareers = careersData.careers.filter(career => {
                    const careerClass = career.class.toLowerCase();
                    const selectedClass = classValue.toLowerCase();
                    
                    // Handle the mapping from display names to JSON names
                    const classMapping = {
                        'academic': 'academics',
                        'burgher': 'burghers',
                        'courtier': 'courtiers',
                        'peasant': 'peasants',
                        'ranger': 'rangers',
                        'riverfolk': 'riverfolk',
                        'rogue': 'rogues',
                        'warrior': 'warriors'
                    };
                    
                    const mappedClass = classMapping[selectedClass] || selectedClass;
                    return careerClass === mappedClass;
                });
                
                filteredCareers.forEach(career => {
                    careerOptions += `<option value="${career.name}">${career.name}</option>`;
                });
            }
            
            content.innerHTML = `
                <p style="margin-bottom: 15px; color: #666;">Select your starting career from the ${classValue} class. This will be set to Tier 1.</p>
                <div style="margin: 20px 0;">
                    <select id="setup-career-select" onchange="handleSetupCareerSelection()" style="padding: 10px; font-size: 14px; width: 100%; border: 1px solid #8b7355;">
                        <option value="">Select Career</option>
                        ${careerOptions}
                    </select>
                </div>
                <p style="color: #666; font-size: 12px;">Your character will start at Tier 1 with access to tier 1 characteristic advances.</p>
            `;
        }
        
        function handleSetupCareerSelection() {
            const career = document.getElementById('setup-career-select').value;
            setupWizardData.career = career;
        }
        
        // =============== OLD VALIDATION FUNCTIONS (TO BE REPLACED) ===============
        
        function validateSpeciesStep() {
            const species = document.getElementById('setup-species').value;
            if (!species) {
                alert('Please select a species.');
                return false;
            }
            setupWizardData.species = species;
            
            // Check if all characteristics have been entered (all 10)
            if (!setupWizardData.characteristics || Object.keys(setupWizardData.characteristics).length < 10) {
                alert('Please enter all characteristic roll values (2-20) before proceeding.');
                return false;
            }
            
            // Validate all characteristics are within proper range
            const characteristics = ['ws', 'bs', 's', 't', 'i', 'agi', 'dex', 'int', 'wp', 'fel'];
            for (let char of characteristics) {
                const value = setupWizardData.characteristics[char];
                if (!value || value < 22 || value > 120) {
                    alert(`Invalid total for ${char.toUpperCase()}. Please check your input.`);
                    return false;
                }
            }
            
            // Validate species selections
            if (!setupWizardData.species_selections) {
                alert('Please complete all species selections (Fate/Resilience, Skills, Talents).');
                return false;
            }
            
            // Check Fate & Resilience
            if (!setupWizardData.species_selections.fate || !setupWizardData.species_selections.resilience) {
                alert('Please select Fate and Resilience values.');
                return false;
            }
            
            // Check Skills
            if (!setupWizardData.species_selections.skills || setupWizardData.species_selections.skills.length === 0) {
                alert('Please select species skills.');
                return false;
            }
            
            // Check Talents - validate that all talent choices are made
            const speciesInfo = speciesData[species];
            if (speciesInfo && speciesInfo.talentChoices) {
                for (let i = 0; i < speciesInfo.talentChoices.length; i++) {
                    const choice = speciesInfo.talentChoices[i];
                    const selectedTalents = setupWizardData.species_selections.talents?.[i] || [];
                    const expectedCount = choice.count || 1;
                    
                    if (selectedTalents.length < expectedCount) {
                        alert(`Please complete talent selection: "${choice.description}"`);
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        function validateCharacteristicsStep() {
            const characteristics = ['ws', 'bs', 's', 't', 'i', 'agi', 'dex', 'int', 'wp', 'fel'];
            const characteristicValues = {};
            
            for (let char of characteristics) {
                const value = document.getElementById(`setup-${char}`).value;
                if (!value || value < 1 || value > 100) {
                    alert(`Please enter a valid value for ${char.toUpperCase()} (1-100).`);
                    return false;
                }
                characteristicValues[char] = parseInt(value);
            }
            
            // Update the stored characteristics with any manual changes
            setupWizardData.characteristics = characteristicValues;
            return true;
        }
        
        function validateClassStep() {
            const classValue = document.getElementById('setup-class').value;
            if (!classValue) {
                alert('Please select a class.');
                return false;
            }
            setupWizardData.class = classValue;
            return true;
        }
        
        function validateCareerStep() {
            const careerSelect = document.getElementById('setup-career');
            if (!careerSelect) {
                alert('Career selection not available. Please go back and select a class first.');
                return false;
            }
            
            const career = careerSelect.value;
            if (!career) {
                alert('Please select a career.');
                return false;
            }
            setupWizardData.career = career;
            return true;
        }
        
        // Finish setup wizard
        function finishSetup() {
            // Apply all the collected data
            document.getElementById('character-name').focus(); // Focus on name for user to enter
            document.getElementById('species').value = setupWizardData.species;
            document.getElementById('class').value = setupWizardData.class;
            
            // Set characteristics from stored wizard data
            const characteristics = ['ws', 'bs', 's', 't', 'i', 'agi', 'dex', 'int', 'wp', 'fel'];
            characteristics.forEach(char => {
                const initialField = document.getElementById(`${char}-initial`);
                const currentField = document.getElementById(`${char}-current`);
                if (initialField && setupWizardData.characteristics && setupWizardData.characteristics[char]) {
                    initialField.value = setupWizardData.characteristics[char];
                    if (currentField) {
                        currentField.value = setupWizardData.characteristics[char];
                    }
                }
            });
            
            // Apply species selections
            if (setupWizardData.species_selections) {
                // Set Fate and Resilience
                if (setupWizardData.species_selections.fate) {
                    const fateField = document.getElementById('fate');
                    if (fateField) {
                        fateField.value = setupWizardData.species_selections.fate;
                    }
                }
                
                if (setupWizardData.species_selections.resilience) {
                    const resilienceField = document.getElementById('resilience');
                    if (resilienceField) {
                        resilienceField.value = setupWizardData.species_selections.resilience;
                    }
                }
                
                // Note: Skills and talents would need to be added to the appropriate sections
                // This would require integration with the existing skills and talents systems
                console.log('Species selections applied:', setupWizardData.species_selections);
            }
            
            // Set career and tier
            if (setupWizardData.career) {
                document.getElementById('career-select').value = setupWizardData.career;
                document.getElementById('global-tier').value = '1';
                currentTier = 1;
                
                // Find and select the career
                const career = careersData?.careers?.find(c => c.name === setupWizardData.career);
                if (career) {
                    currentCareer = career;
                    updateCharacteristicLimits();
                    updateTierDisplay();
                    highlightCareerSkills();
                    highlightCareerTalents();
                }
            }
            
            // Close wizard
            closeSetupWizard();
            
            // Show success message with summary
            const speciesSelections = setupWizardData.species_selections;
            let summaryMessage = 'Character setup complete!\n\n';
            summaryMessage += `Species: ${setupWizardData.species}\n`;
            summaryMessage += `Class: ${setupWizardData.class}\n`;
            summaryMessage += `Career: ${setupWizardData.career}\n`;
            if (speciesSelections) {
                summaryMessage += `Fate: ${speciesSelections.fate}, Resilience: ${speciesSelections.resilience}\n`;
                if (speciesSelections.skills) {
                    summaryMessage += `Species Skills: ${speciesSelections.skills.join(', ')}\n`;
                }
            }
            
            alert(summaryMessage);
            
            // Update XP display and trigger save
            window.updateXPDisplay();
            window.updateCharacteristics();
            
            // Clear wizard data
            setupWizardData = {};
        }

        // =============== CLASS TRAPPINGS WIZARD FUNCTIONS ===============

        function manualOpenClassWizard() {
            const classSelect = document.getElementById('class');
            const selectedValue = classSelect.value;
            
            if (!selectedValue) {
                alert('Please select a class first before opening the wizard.');
                return;
            }
            
            if (!classTrappings[selectedValue]) {
                alert('Class data not found. Please refresh the page and try again.');
                return;
            }
            
            openClassWizard(selectedValue);
        }

        function openClassWizard(className) {
            selectedClass = className;
            const classInfo = classTrappings[className];
            
            // Reset wizard data
            classWizardData = {
                fixed: [...classInfo.fixed],
                rolls: {},
                choices: {},
                finalEquipment: []
            };
            
            // Initialize step 1
            initializeClassStep1(classInfo);
            
            // Show modal and start at step 1
            currentClassWizardStep = 1;
            updateClassWizardDisplay();
            document.getElementById('class-wizard-modal').style.display = 'block';
        }

        function initializeClassStep1(classInfo) {
            const overviewDiv = document.getElementById('class-overview');
            
            let overviewHTML = `
                <h4 style="color: #3e2f1f; margin-bottom: 15px;">${selectedClass} Starting Equipment</h4>
                <p style="margin-bottom: 15px; color: #666;">This class receives the following equipment:</p>
                
                <div style="background: #f9f7f1; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h5 style="color: #3e2f1f; margin-bottom: 10px;">Fixed Equipment:</h5>
                    <ul style="margin-left: 20px;">
            `;
            
            classInfo.fixed.forEach(item => {
                overviewHTML += `<li>${item}</li>`;
            });
            
            overviewHTML += `</ul></div>`;
            
            // Show dice rolls if any
            if (classInfo.rolls && classInfo.rolls.length > 0) {
                overviewHTML += `
                    <div style="background: #e8f4fd; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 10px;">Dice Roll Required:</h5>
                        <ul style="margin-left: 20px;">
                `;
                
                classInfo.rolls.forEach(roll => {
                    overviewHTML += `<li>Roll ${roll.dice} for ${roll.item}${roll.unit ? ` (${roll.unit})` : ''}</li>`;
                });
                
                overviewHTML += `</ul></div>`;
            }
            
            // Show choices if any
            if (classInfo.choices && classInfo.choices.length > 0) {
                overviewHTML += `
                    <div style="background: #fff4e6; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 10px;">Choices Required:</h5>
                        <ul style="margin-left: 20px;">
                `;
                
                classInfo.choices.forEach(choice => {
                    overviewHTML += `<li>Choose ${choice.choose} from: ${choice.from.join(', ')}</li>`;
                });
                
                overviewHTML += `</ul></div>`;
            }
            
            overviewHTML += `<p style="color: #666; margin-top: 15px;">Click "Next" to proceed to customisation${(!classInfo.rolls || classInfo.rolls.length === 0) && (!classInfo.choices || classInfo.choices.length === 0) ? ' (or skip if no customisation needed)' : ''}.</p>`;
            
            overviewDiv.innerHTML = overviewHTML;
        }

        function initializeClassStep2() {
            const classInfo = classTrappings[selectedClass];
            const customisationDiv = document.getElementById('class-customisation');
            
            let needsCustomisation = false;
            let customisationHTML = '';
            
            // Handle dice rolls
            if (classInfo.rolls && classInfo.rolls.length > 0) {
                needsCustomisation = true;
                customisationHTML += `
                    <div style="background: #e8f4fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 15px;">Dice Rolls</h5>
                `;
                
                classInfo.rolls.forEach((roll, index) => {
                    customisationHTML += `
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #3e2f1f; font-weight: bold;">
                                Roll ${roll.dice} for ${roll.item}${roll.unit ? ` (${roll.unit})` : ''}:
                            </label>
                            <input type="number" id="roll-${index}" min="1" max="10" placeholder="Enter result..." 
                                   style="padding: 8px; border: 1px solid #ccc; border-radius: 3px; width: 100px;"
                                   oninput="updateRollResult(${index}, this.value)">
                        </div>
                    `;
                });
                
                customisationHTML += `</div>`;
            }
            
            // Handle choices
            if (classInfo.choices && classInfo.choices.length > 0) {
                needsCustomisation = true;
                customisationHTML += `
                    <div style="background: #fff4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 15px;">Equipment Choices</h5>
                `;
                
                classInfo.choices.forEach((choice, choiceIndex) => {
                    customisationHTML += `
                        <div style="margin-bottom: 15px;">
                            <p style="margin-bottom: 10px; color: #3e2f1f; font-weight: bold;">Choose ${choice.choose}:</p>
                    `;
                    
                    choice.from.forEach((option, optionIndex) => {
                        customisationHTML += `
                            <label style="display: block; margin-bottom: 5px; cursor: pointer;">
                                <input type="radio" name="choice-${choiceIndex}" value="${option}" 
                                       onchange="updateChoiceResult(${choiceIndex}, this.value)" style="margin-right: 8px;">
                                ${option}
                            </label>
                        `;
                    });
                    
                    customisationHTML += `</div>`;
                });
                
                customisationHTML += `</div>`;
            }
            
            if (!needsCustomisation) {
                customisationHTML = `
                    <div style="text-align: center; padding: 40px; color: #666; font-style: italic;">
                        <p>No customisation needed for this class.</p>
                        <p>All equipment is fixed. Click "Next" to proceed to confirmation.</p>
                    </div>
                `;
            }
            
            customisationDiv.innerHTML = customisationHTML;
        }

        function updateRollResult(rollIndex, value) {
            const classInfo = classTrappings[selectedClass];
            const roll = classInfo.rolls[rollIndex];
            
            if (value && value > 0) {
                classWizardData.rolls[roll.item] = parseInt(value);
            } else {
                delete classWizardData.rolls[roll.item];
            }
        }

        function updateChoiceResult(choiceIndex, value) {
            classWizardData.choices[choiceIndex] = value;
        }

        function initializeClassStep3() {
            const classInfo = classTrappings[selectedClass];
            const confirmationDiv = document.getElementById('class-confirmation');
            
            // Generate final equipment list
            const finalEquipment = [...classInfo.fixed];
            
            // Add rolled items
            if (classInfo.rolls) {
                classInfo.rolls.forEach(roll => {
                    const rollResult = classWizardData.rolls[roll.item];
                    if (rollResult) {
                        const itemName = roll.unit ? `${roll.item} (${rollResult})` : `${rollResult} ${roll.item}`;
                        finalEquipment.push(itemName);
                    }
                });
            }
            
            // Add chosen items
            if (classInfo.choices) {
                classInfo.choices.forEach((choice, index) => {
                    const chosen = classWizardData.choices[index];
                    if (chosen) {
                        finalEquipment.push(chosen);
                    }
                });
            }
            
            classWizardData.finalEquipment = finalEquipment;
            
            // Categorize equipment
            const weapons = finalEquipment.filter(item => 
                item.toLowerCase().includes('dagger') || 
                item.toLowerCase().includes('hand weapon')
            );
            
            const trappings = finalEquipment.filter(item => 
                !item.toLowerCase().includes('dagger') && 
                !item.toLowerCase().includes('hand weapon')
            );
            
            let confirmationHTML = `
                <h4 style="color: #3e2f1f; margin-bottom: 15px;">Final Equipment Summary</h4>
                <p style="margin-bottom: 20px; color: #666;">The following equipment will be added to your character sheet:</p>
            `;
            
            if (weapons.length > 0) {
                confirmationHTML += `
                    <div style="background: #ffe6e6; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 10px;">Weapons (will be added to Weapons table):</h5>
                        <ul style="margin-left: 20px;">
                `;
                weapons.forEach(weapon => {
                    confirmationHTML += `<li>${weapon}</li>`;
                });
                confirmationHTML += `</ul></div>`;
            }
            
            if (trappings.length > 0) {
                confirmationHTML += `
                    <div style="background: #e6f3ff; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <h5 style="color: #3e2f1f; margin-bottom: 10px;">Trappings (will be added to Trappings list):</h5>
                        <ul style="margin-left: 20px;">
                `;
                trappings.forEach(trapping => {
                    confirmationHTML += `<li>${trapping}</li>`;
                });
                confirmationHTML += `</ul></div>`;
            }
            
            confirmationHTML += `<p style="color: #666; margin-top: 15px;">Click "Add to Character Sheet" to complete the process.</p>`;
            
            confirmationDiv.innerHTML = confirmationHTML;
        }

        function validateClassWizardStep(step) {
            const classInfo = classTrappings[selectedClass];
            
            switch(step) {
                case 1:
                    return true;
                    
                case 2:
                    // Validate dice rolls
                    if (classInfo.rolls) {
                        for (const roll of classInfo.rolls) {
                            if (!classWizardData.rolls[roll.item]) {
                                alert(`Please enter the dice roll result for ${roll.item}.`);
                                return false;
                            }
                        }
                    }
                    
                    // Validate choices
                    if (classInfo.choices) {
                        for (let i = 0; i < classInfo.choices.length; i++) {
                            if (!classWizardData.choices[i]) {
                                alert(`Please make a choice for option ${i + 1}.`);
                                return false;
                            }
                        }
                    }
                    
                    return true;
                    
                default:
                    return true;
            }
        }

        function nextClassWizardStep() {
            if (currentClassWizardStep < 3) {
                // Validate current step before proceeding
                if (validateClassWizardStep(currentClassWizardStep)) {
                    currentClassWizardStep++;
                    
                    // Initialize the next step
                    if (currentClassWizardStep === 2) initializeClassStep2();
                    else if (currentClassWizardStep === 3) initializeClassStep3();
                    
                    updateClassWizardDisplay();
                }
            }
        }

        function previousClassWizardStep() {
            if (currentClassWizardStep > 1) {
                currentClassWizardStep--;
                updateClassWizardDisplay();
            }
        }

        function updateClassWizardDisplay() {
            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const indicator = document.getElementById(`class-step-indicator-${i}`);
                indicator.className = 'wizard-step';
                if (i < currentClassWizardStep) {
                    indicator.classList.add('completed');
                } else if (i === currentClassWizardStep) {
                    indicator.classList.add('active');
                }
            }

            // Show/hide wizard content
            for (let i = 1; i <= 3; i++) {
                const content = document.getElementById(`class-wizard-step-${i}`);
                content.style.display = i === currentClassWizardStep ? 'block' : 'none';
            }

            // Update navigation buttons
            const prevBtn = document.getElementById('class-wizard-prev-btn');
            const nextBtn = document.getElementById('class-wizard-next-btn');
            const applyBtn = document.getElementById('class-wizard-apply-btn');

            prevBtn.disabled = currentClassWizardStep === 1;
            nextBtn.style.display = currentClassWizardStep === 3 ? 'none' : 'inline-block';
            applyBtn.style.display = currentClassWizardStep === 3 ? 'inline-block' : 'none';
        }

        function applyClassTrappings() {
            try {
                // Set class selection
                const classField = document.getElementById('class');
                if (classField) {
                    classField.value = selectedClass;
                }

                // Apply equipment
                classWizardData.finalEquipment.forEach(item => {
                    if (item.toLowerCase().includes('dagger') || item.toLowerCase().includes('hand weapon')) {
                        // Add to weapons
                        addWeaponDirectly(item);
                    } else {
                        // Add to trappings
                        addTrappingDirectly(item);
                    }
                });

                // Close wizard and show success message
                closeClassWizard();
                alert(`${selectedClass} equipment added successfully!`);
                
            } catch (error) {
                console.error('Error applying class trappings:', error);
                alert('There was an error applying the class equipment. Please try again.');
            }
        }

        function addWeaponDirectly(weaponName) {
            // Try to find weapon in srdWeapons data
            let weaponData = null;
            
            if (weaponName.toLowerCase().includes('dagger')) {
                weaponData = srdWeapons.find(w => w.name.toLowerCase() === 'dagger');
            } else if (weaponName.toLowerCase().includes('hand weapon')) {
                weaponData = srdWeapons.find(w => w.name.toLowerCase() === 'hand weapon');
            }
            
            if (weaponData) {
                // Add weapon with full stats
                weapons.push({
                    name: weaponData.name,
                    damage: weaponData.damage || '',
                    group: weaponData.group || '',
                    reach: weaponData.reach || '',
                    range: weaponData.range || '',
                    reload: weaponData.reload || '',
                    traits: weaponData.traits || '',
                    enc: weaponData.enc || 0,
                    cost: weaponData.cost || '',
                    availability: weaponData.availability || ''
                });
                
                displayWeapons();
            } else {
                // Add as basic weapon entry
                weapons.push({
                    name: weaponName,
                    damage: '',
                    group: '',
                    reach: '',
                    range: '',
                    reload: '',
                    traits: '',
                    enc: 0,
                    cost: '',
                    availability: ''
                });
                
                displayWeapons();
            }
        }

        function addTrappingDirectly(trappingName) {
            // Add to trappings list
            trappings.push({
                name: trappingName,
                enc: 0,
                notes: ''
            });
            
            displayTrappings();
        }

        function closeClassWizard() {
            document.getElementById('class-wizard-modal').style.display = 'none';
            
            // Reset wizard state
            currentClassWizardStep = 1;
            selectedClass = '';
            classWizardData = {
                fixed: [],
                rolls: {},
                choices: {},
                finalEquipment: []
            };
        }

        // =============== SESSION NOTES SYSTEM ===============

        // Session Notes Variables
        let sessionNotes = JSON.parse(localStorage.getItem('wfrpSessionNotes')) || [];
        let currentSessionId = null;
        let autoSaveTimer = null;
        let lastSavedContent = '';

        // Session Notes Templates
        const sessionTemplates = {
            'combat': `<h3>Combat Encounter</h3>
<p><strong>Enemy:</strong> </p>
<p><strong>Location:</strong> </p>
<p><strong>Initiative Order:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Key Events:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Outcome:</strong> </p>
<p><strong>Rewards/Consequences:</strong> </p>`,

            'npc': `<h3>NPC Interaction</h3>
<p><strong>NPC Name:</strong> </p>
<p><strong>Location:</strong> </p>
<p><strong>Disposition:</strong> </p>
<p><strong>Conversation Topics:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Information Gained:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Outcome:</strong> </p>`,

            'skill-test': `<h3>Skill Test</h3>
<p><strong>Test Type:</strong> </p>
<p><strong>Difficulty:</strong> </p>
<p><strong>Character(s):</strong> </p>
<p><strong>Modifiers:</strong> </p>
<p><strong>Roll Results:</strong> </p>
<p><strong>Outcome:</strong> </p>
<p><strong>Consequences:</strong> </p>`,

            'treasure': `<h3>Treasure & Rewards</h3>
<p><strong>Location Found:</strong> </p>
<p><strong>Items Discovered:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Money:</strong> </p>
<p><strong>XP Awarded:</strong> </p>
<p><strong>Special Notes:</strong> </p>`,

            'session-start': `<h2>Session Start</h2>
<p><strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
<p><strong>Present Characters:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Previous Session Recap:</strong> </p>
<p><strong>Starting Location:</strong> </p>
<p><strong>Session Goals:</strong></p>
<ul>
<li></li>
</ul>`,

            'session-end': `<h2>Session End</h2>
<p><strong>Key Accomplishments:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Unresolved Threads:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>Next Session Hooks:</strong></p>
<ul>
<li></li>
</ul>
<p><strong>XP Awarded:</strong> </p>
<p><strong>Notes for GM:</strong> </p>`
        };

        // Initialize Session Notes on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date to today
            document.getElementById('session-date').value = new Date().toISOString().split('T')[0];
            
            // Load last session or create first session
            if (sessionNotes.length > 0) {
                loadSession(sessionNotes[sessionNotes.length - 1].id);
            } else {
                // Auto-create first session
                createNewSession();
            }
        });

        // Create New Session
        function createNewSession() {
            const newSessionId = 'session_' + Date.now();
            const sessionNumber = sessionNotes.length + 1;
            
            const newSession = {
                id: newSessionId,
                number: sessionNumber,
                date: new Date().toISOString().split('T')[0],
                gmName: '',
                campaignName: '',
                location: '',
                content: '',
                wordCount: 0,
                created: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            
            sessionNotes.push(newSession);
            saveSessionNotes();
            loadSession(newSessionId);
            
            // Focus on the editor
            document.getElementById('session-editor').focus();
        }

        // Load Session
        function loadSession(sessionId) {
            const session = sessionNotes.find(s => s.id === sessionId);
            if (!session) return;
            
            currentSessionId = sessionId;
            
            // Update UI with session data
            document.getElementById('session-number').value = session.number;
            document.getElementById('session-date').value = session.date;
            document.getElementById('gm-name').value = session.gmName || '';
            document.getElementById('campaign-name').value = session.campaignName || '';
            document.getElementById('session-location').value = session.location || '';
            document.getElementById('session-editor').innerHTML = session.content || '';
            
            // Update current session display
            const sessionTitle = `Session ${session.number} - ${new Date(session.date).toLocaleDateString()}`;
            document.getElementById('current-session-title').textContent = sessionTitle;
            
            // Update word count
            updateWordCount();
            
            // Store current content for comparison
            lastSavedContent = session.content || '';
            
            // Start auto-save timer
            startAutoSave();
        }

        // Save Session Notes to localStorage
        function saveSessionNotes() {
            localStorage.setItem('wfrpSessionNotes', JSON.stringify(sessionNotes));
        }

        // Auto-save functionality
        function startAutoSave() {
            // Clear any existing timer
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            
            // Set up new timer for every 30 seconds
            autoSaveTimer = setInterval(autoSaveSession, 30000);
        }

        function autoSaveSession() {
            if (!currentSessionId) return;
            
            const currentContent = document.getElementById('session-editor').innerHTML;
            
            // Only save if content has changed
            if (currentContent !== lastSavedContent) {
                saveCurrentSession();
                updateAutoSaveStatus('âœ“ Auto-saved', '#28a745');
                lastSavedContent = currentContent;
            }
        }

        function saveCurrentSession() {
            if (!currentSessionId) return;
            
            const session = sessionNotes.find(s => s.id === currentSessionId);
            if (!session) return;
            
            // Update session with current values
            session.number = parseInt(document.getElementById('session-number').value) || session.number;
            session.date = document.getElementById('session-date').value;
            session.gmName = document.getElementById('gm-name').value;
            session.campaignName = document.getElementById('campaign-name').value;
            session.location = document.getElementById('session-location').value;
            session.content = document.getElementById('session-editor').innerHTML;
            session.wordCount = countWords(session.content);
            session.lastModified = new Date().toISOString();
            
            saveSessionNotes();
        }

        function updateAutoSaveStatus(message, color) {
            const statusElement = document.getElementById('auto-save-status');
            statusElement.textContent = message;
            statusElement.style.color = color;
            
            // Reset to saved status after 3 seconds
            setTimeout(() => {
                statusElement.textContent = 'âœ“ Saved';
                statusElement.style.color = '#28a745';
            }, 3000);
        }

        // Editor Input Handler
        function onEditorInput() {
            updateWordCount();
            updateAutoSaveStatus('â— Unsaved', '#ffc107');
        }

        // Rich Text Formatting
        function formatText(command) {
            document.execCommand(command, false, null);
            document.getElementById('session-editor').focus();
            onEditorInput();
        }

        function formatHeading(tag) {
            if (tag) {
                document.execCommand('formatBlock', false, tag);
                document.getElementById('session-editor').focus();
                onEditorInput();
            }
        }

        // Insert WFRP Templates
        function insertTemplate(templateKey) {
            if (!templateKey || !sessionTemplates[templateKey]) return;
            
            const editor = document.getElementById('session-editor');
            const template = sessionTemplates[templateKey];
            
            // Insert template at cursor position
            document.execCommand('insertHTML', false, template);
            
            // Reset dropdown
            event.target.value = '';
            
            editor.focus();
            onEditorInput();
        }

        // Word Count
        function updateWordCount() {
            const content = document.getElementById('session-editor').innerText || '';
            const wordCount = countWords(content);
            document.getElementById('word-count').textContent = wordCount;
        }

        function countWords(text) {
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        // Session List Management
        function showSessionList() {
            const modal = document.getElementById('session-list-modal');
            const content = document.getElementById('session-list-content');
            
            if (sessionNotes.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No sessions found. Create your first session to get started!</p>';
            } else {
                // Sort sessions by number (descending)
                const sortedSessions = [...sessionNotes].sort((a, b) => b.number - a.number);
                
                let listHTML = '<div style="display: grid; gap: 10px;">';
                
                sortedSessions.forEach(session => {
                    const isActive = session.id === currentSessionId;
                    const date = new Date(session.date).toLocaleDateString();
                    const lastModified = new Date(session.lastModified).toLocaleDateString();
                    
                    listHTML += `
                        <div style="padding: 15px; border: 2px solid ${isActive ? '#3e2f1f' : '#e8dfd0'}; border-radius: 5px; background: ${isActive ? '#f0f7ff' : '#faf8f3'};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #3e2f1f; margin: 0;">Session ${session.number}</h4>
                                <div style="display: flex; gap: 5px;">
                                    <button onclick="loadSession('${session.id}'); closeSessionList();" class="control-btn" style="padding: 5px 10px; font-size: 11px;">${isActive ? 'Current' : 'Load'}</button>
                                    <button onclick="deleteSession('${session.id}')" class="control-btn" style="padding: 5px 10px; font-size: 11px; background: #d44; color: white;">Delete</button>
                                </div>
                            </div>
                            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                                <strong>Date:</strong> ${date} | <strong>Last Modified:</strong> ${lastModified} | <strong>Words:</strong> ${session.wordCount || 0}
                            </div>
                            ${session.campaignName ? `<div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Campaign:</strong> ${session.campaignName}</div>` : ''}
                            ${session.location ? `<div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Location:</strong> ${session.location}</div>` : ''}
                            ${session.gmName ? `<div style="font-size: 12px; color: #666;"><strong>GM:</strong> ${session.gmName}</div>` : ''}
                        </div>
                    `;
                });
                
                listHTML += '</div>';
                content.innerHTML = listHTML;
            }
            
            modal.style.display = 'block';
        }

        function closeSessionList() {
            document.getElementById('session-list-modal').style.display = 'none';
        }

        function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This cannot be undone.')) {
                return;
            }
            
            const sessionIndex = sessionNotes.findIndex(s => s.id === sessionId);
            if (sessionIndex === -1) return;
            
            sessionNotes.splice(sessionIndex, 1);
            saveSessionNotes();
            
            // If we deleted the current session, load another one or create new
            if (sessionId === currentSessionId) {
                if (sessionNotes.length > 0) {
                    loadSession(sessionNotes[sessionNotes.length - 1].id);
                } else {
                    createNewSession();
                }
            }
            
            // Refresh the session list if it's open
            const modal = document.getElementById('session-list-modal');
            if (modal.style.display === 'block') {
                showSessionList();
            }
        }

        // Export Functionality
        function exportCurrentSession() {
            if (!currentSessionId) {
                alert('No session to export.');
                return;
            }
            
            saveCurrentSession(); // Save current state first
            
            const session = sessionNotes.find(s => s.id === currentSessionId);
            if (!session) return;
            
            const characterName = document.getElementById('character-name').value || 'Unknown Character';
            const exportContent = generateSessionExport(session, characterName);
            
            downloadTextFile(`Session_${session.number}_${session.date}.txt`, exportContent);
        }

        function exportAllSessions() {
            if (sessionNotes.length === 0) {
                alert('No sessions to export.');
                return;
            }
            
            saveCurrentSession(); // Save current state first
            
            const characterName = document.getElementById('character-name').value || 'Unknown Character';
            const campaignName = sessionNotes.find(s => s.campaignName)?.campaignName || 'WFRP Campaign';
            
            let exportContent = `${campaignName} - Complete Session Log\n`;
            exportContent += `Character: ${characterName}\n`;
            exportContent += `Generated: ${new Date().toLocaleDateString()}\n`;
            exportContent += `Total Sessions: ${sessionNotes.length}\n`;
            exportContent += '='.repeat(60) + '\n\n';
            
            // Sort by session number
            const sortedSessions = [...sessionNotes].sort((a, b) => a.number - b.number);
            
            sortedSessions.forEach((session, index) => {
                if (index > 0) exportContent += '\n' + '='.repeat(60) + '\n\n';
                exportContent += generateSessionExport(session, characterName, false);
            });
            
            downloadTextFile(`${campaignName.replace(/\s+/g, '_')}_Complete_Log.txt`, exportContent);
        }

        function generateSessionExport(session, characterName, includeHeader = true) {
            let content = '';
            
            if (includeHeader) {
                content += `WFRP Session Notes Export\n`;
                content += `Character: ${characterName}\n`;
                content += `Generated: ${new Date().toLocaleDateString()}\n`;
                content += '='.repeat(40) + '\n\n';
            }
            
            content += `Session ${session.number}\n`;
            content += `Date: ${new Date(session.date).toLocaleDateString()}\n`;
            if (session.campaignName) content += `Campaign: ${session.campaignName}\n`;
            if (session.gmName) content += `GM: ${session.gmName}\n`;
            if (session.location) content += `Location: ${session.location}\n`;
            content += `Word Count: ${session.wordCount || 0}\n`;
            content += '-'.repeat(30) + '\n\n';
            
            // Convert HTML content to plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = session.content || 'No content recorded.';
            content += tempDiv.textContent || tempDiv.innerText || 'No content recorded.';
            
            return content;
        }

        function downloadTextFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Save session when metadata fields change
        document.addEventListener('DOMContentLoaded', function() {
            const metadataFields = ['session-number', 'session-date', 'gm-name', 'campaign-name', 'session-location'];
            metadataFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', function() {
                        updateAutoSaveStatus('â— Unsaved', '#ffc107');
                    });
                    field.addEventListener('change', function() {
                        saveCurrentSession();
                        updateAutoSaveStatus('âœ“ Saved', '#28a745');
                    });
                }
            });
        });

        // Clean up auto-save timer when page unloads
        window.addEventListener('beforeunload', function() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            // Save current session one last time
            saveCurrentSession();
        });

    </script>
</body>
</html>